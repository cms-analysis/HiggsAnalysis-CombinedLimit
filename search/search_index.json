{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p> These pages document the RooStats / RooFit - based software tool used for statistical analysis within the CMS experiment - Combine. Note that while this tool was originally developed in the Higgs Physics Analysis Group (PAG), its usage is now widespread within CMS. </p> <p>Combine provides a command-line interface to many different statistical techniques, available inside RooFit/RooStats, that are used widely inside CMS.</p> <p>The package exists on GitHub under https://github.com/cms-analysis/HiggsAnalysis-CombinedLimit</p> <p>For more information about Git, GitHub and its usage in CMS, see http://cms-sw.github.io/cmssw/faq.html</p> <p>The code can be checked out from GitHub and compiled on top of a CMSSW release that includes a recent RooFit/RooStats, or via standalone compilation without CMSSW dependencies. See the instructions for installation of Combine below.</p>"},{"location":"#installation-instructions","title":"Installation instructions","text":"<p>Installation instructions and recommended versions can be found below.  Since v9.0.0, the versioning follows the semantic versioning 2.0.0 standard. Earlier versions are not guaranteed to follow the standard.</p>"},{"location":"#within-cmssw-recommended-for-cms-users","title":"Within CMSSW (recommended for CMS users)","text":"<p>The instructions below are for installation within a CMSSW environment. For end users that do not need to commit or do any development, the following recipes should be sufficient. To choose a release version, you can find the latest releases on github under https://github.com/cms-analysis/HiggsAnalysis-CombinedLimit/releases</p>"},{"location":"#combine-v9-recommended-version","title":"Combine v9 - recommended version","text":"<p>The nominal installation method is inside CMSSW. The current release targets the CMSSW <code>11_3_X</code> series because this release has both python2 and python3 ROOT bindings, allowing a more gradual migration of user code to python3. Combine is fully python3-compatible and, with some adaptations, can also work in 12_X releases. </p> <p>CMSSW <code>11_3_X</code> runs on slc7, which can be setup using apptainer (see detailed instructions):</p> <pre><code>cmssw-el7\ncmsrel CMSSW_11_3_4\ncd CMSSW_11_3_4/src\ncmsenv\ngit clone https://github.com/cms-analysis/HiggsAnalysis-CombinedLimit.git HiggsAnalysis/CombinedLimit\ncd HiggsAnalysis/CombinedLimit\n</code></pre> <p>Update to a recommended tag - currently the recommended tag is v9.1.0: see release notes</p> <pre><code>cd $CMSSW_BASE/src/HiggsAnalysis/CombinedLimit\ngit fetch origin\ngit checkout v9.1.0\nscramv1 b clean; scramv1 b # always make a clean build\n</code></pre>"},{"location":"#combine-v8-cmssw_10_2_x-release-series","title":"Combine v8: <code>CMSSW_10_2_X</code> release series","text":"<p>Setting up the environment (once):</p> <pre><code>cmssw-el7\ncmsrel CMSSW_10_2_13\ncd CMSSW_10_2_13/src\ncmsenv\ngit clone https://github.com/cms-analysis/HiggsAnalysis-CombinedLimit.git HiggsAnalysis/CombinedLimit\ncd HiggsAnalysis/CombinedLimit\n</code></pre> <p>Update to a recommended tag - currently the recommended tag is v8.2.0: see release notes</p> <pre><code>cd $CMSSW_BASE/src/HiggsAnalysis/CombinedLimit\ngit fetch origin\ngit checkout v8.2.0\nscramv1 b clean; scramv1 b # always make a clean build\n</code></pre>"},{"location":"#slc6cc7-release-cmssw_8_1_x","title":"SLC6/CC7 release <code>CMSSW_8_1_X</code>","text":"<p>Setting up OS using apptainer (see detailed instructions):</p> <pre><code># For CC7:\ncmssw-el7\n# For SLC6:\ncmssw-el6\n\ncmsrel CMSSW_8_1_0\ncd CMSSW_8_1_0/src\ncmsenv\ngit clone https://github.com/cms-analysis/HiggsAnalysis-CombinedLimit.git HiggsAnalysis/CombinedLimit\ncd HiggsAnalysis/CombinedLimit\n</code></pre> <p>Update to a recommended tag - currently the recommended tag for CMSSW_8_1_X is v7.0.13:</p> <pre><code>cd $CMSSW_BASE/src/HiggsAnalysis/CombinedLimit\ngit fetch origin\ngit checkout v7.0.13\nscramv1 b clean; scramv1 b # always make a clean build\n</code></pre>"},{"location":"#oustide-of-cmssw-recommended-for-non-cms-users","title":"Oustide of CMSSW (recommended for non-CMS users)","text":"<p>Pre-compiled versions of the tool are available as container images from the CMS cloud. These containers can be downloaded and run using Docker. If you have docker running you can pull and run the latest image using, </p> <pre><code>docker run --name combine -it gitlab-registry.cern.ch/cms-cloud/combine-standalone:latest\n</code></pre> <p>You will now have the compiled Combine binary available as well as the complete package of tool.  The container can be re-started using <code>docker start -i combine</code>. </p>"},{"location":"#standalone-compilation","title":"Standalone compilation","text":"<p>The standalone version can be easily compiled using cvmfs as it relies on dependencies that are already installed at <code>/cvmfs/cms.cern.ch/</code>. Access to <code>/cvmfs/cms.cern.ch/</code> can be obtained from lxplus machines or via <code>CernVM</code>. See CernVM for further details on the latter. In case you do not want to use the <code>cvmfs</code> area, you will need to adapt the locations of the dependencies listed in both the <code>Makefile</code> and <code>env_standalone.sh</code> files.</p> <pre><code>git clone https://github.com/cms-analysis/HiggsAnalysis-CombinedLimit.git HiggsAnalysis/CombinedLimit\ncd HiggsAnalysis/CombinedLimit/ \n# git checkout &lt;some release&gt;\n. env_standalone.sh\nmake -j 4\n</code></pre> <p>You will need to source <code>env_standalone.sh</code> each time you want to use the package, or add it to your login environment.</p>"},{"location":"#standalone-compilation-with-lcg","title":"Standalone compilation with LCG","text":"<p>For compilation outside of CMSSW, for example to use ROOT versions not yet available in CMSSW, one can compile against LCG releases. The current default is to compile with LCG_102, which contains ROOT 6.26:</p> <pre><code>git clone https://github.com/cms-analysis/HiggsAnalysis-CombinedLimit.git HiggsAnalysis/CombinedLimit\ncd HiggsAnalysis/CombinedLimit\nsource env_lcg.sh \nmake LCG=1 -j 8\n</code></pre> <p>To change the LCG version, edit <code>env_lcg.sh</code>. </p> <p>The resulting binaries can be moved for use in a batch job if the following files are included in the job tarball:</p> <pre><code>tar -zcf Combine_LCG_env.tar.gz build interface src/classes.h --exclude=obj\n</code></pre>"},{"location":"#standalone-compilation-with-conda","title":"Standalone compilation with <code>conda</code>","text":"<p>This recipe will work both for linux and MacOS</p> <pre><code>git clone https://github.com/cms-analysis/HiggsAnalysis-CombinedLimit.git HiggsAnalysis/CombinedLimit\ncd HiggsAnalysis/CombinedLimit\n\nconda install --name base mamba # faster conda\nmamba env create -f conda_env.yml\n\nconda activate combine\nsource set_conda_env_vars.sh\n# Need to reactivate\nconda deactivate\nconda activate combine\n\nmake CONDA=1 -j 8\n</code></pre> <p>Using Combine from then on should only require sourcing the conda environment </p> <pre><code>conda activate combine\n</code></pre> <p>Note: on OS X, Combine can only accept workspaces, so run <code>text2workspace.py</code> first. This is due to an issue with child processes and <code>LD_LIBRARY_PATH</code> (see note in Makefile)</p>"},{"location":"#standalone-compilation-with-cernvm","title":"Standalone compilation with CernVM","text":"<p>Combine, either standalone or not, can be compiled via CVMFS using access to <code>/cvmfs/cms.cern.ch/</code>  obtained using a virtual machine - <code>CernVM</code>. To use <code>CernVM</code> You should have access to CERN IT resources. If you are a CERN user you can use your account, otherwise you can request a lightweight account. If you have a CERN user account, we strongly suggest you simply run one of the other standalone installations, which are simpler and faster than using a VM.</p> <p>You should have a working VM on your local machine, compatible with CernVM, such as <code>VirtualBox</code>. All the required software can be downloaded here. At least 2GB of disk space should be reserved on the virtual machine for Combine to work properly and the machine must be contextualized to add the <code>CMS</code> group to CVMFS. A minimal working setup is described below.</p> <ol> <li> <p>Download the CernVM-launcher for your operating system, following the instructions available [<code>here</code>] for your operating system (https://cernvm.readthedocs.io/en/stable/cpt-launch.html#installation</p> </li> <li> <p>Prepare a CMS context. You can use the CMS open data one already available on gitHub:  <code>wget https://raw.githubusercontent.com/cernvm/public-contexts/master/cms-opendata-2011.context)</code></p> </li> <li> <p>Launch the virtual machine <code>cernvm-launch create --name combine --cpus 2 cms-opendata-2011.context</code></p> </li> <li> <p>In the VM, proceed with an installation of combine</p> </li> </ol> <p>Installation through CernVM is maintained on a best-effort basis and these instructions may not be up to date. </p>"},{"location":"#what-has-changed-between-tags","title":"What has changed between tags?","text":"<p>You can generate a diff of any two tags (eg for <code>v9.1.0</code> and <code>v9.0.0</code>) by using the following url:</p> <p>https://github.com/cms-analysis/HiggsAnalysis-CombinedLimit/compare/v9.0.0...v9.1.0</p> <p>Replace the tag names in the url to any tags you would like to compare.</p>"},{"location":"#for-developers","title":"For developers","text":"<p>We use the Fork and Pull model for development: each user creates a copy of the repository on GitHub, commits their requests there, and then sends pull requests for the administrators to merge.</p> <p>Prerequisites</p> <ol> <li> <p>Register on GitHub, as needed anyway for CMSSW development: http://cms-sw.github.io/cmssw/faq.html</p> </li> <li> <p>Register your SSH key on GitHub: https://help.github.com/articles/generating-ssh-keys </p> </li> <li> <p>Fork the repository to create your copy of it: https://github.com/cms-analysis/HiggsAnalysis-CombinedLimit/fork (more documentation at https://help.github.com/articles/fork-a-repo )</p> </li> </ol> <p>You will now be able to browse your fork of the repository from https://github.com/your-github-user-name/HiggsAnalysis-CombinedLimit</p> <p>We strongly encourage you to contribute any developments you make back to the main repository.  See contributing.md for details about contributing. </p>"},{"location":"#combineharvestercombinetools","title":"CombineHarvester/CombineTools","text":"<p>CombineTools is an additional tool for submitting Combine jobs to batch systems or crab, which was originally developed in the context of Higgs to tau tau analyses. Since the repository contains a certain amount of analysis-specific code, the following scripts can be used to clone it with a sparse checkout for just the core <code>CombineHarvester/CombineTools</code> subpackage, speeding up the checkout and compile times:</p> <p>git clone via ssh:</p> <pre><code>bash &lt;(curl -s https://raw.githubusercontent.com/cms-analysis/CombineHarvester/main/CombineTools/scripts/sparse-checkout-ssh.sh)\n</code></pre> <p>git clone via https:</p> <pre><code>bash &lt;(curl -s https://raw.githubusercontent.com/cms-analysis/CombineHarvester/main/CombineTools/scripts/sparse-checkout-https.sh)\n</code></pre> <p>make sure to run <code>scram</code>  to compile the <code>CombineTools</code> package.</p> <p>See the <code>CombineHarvester</code> documentation pages for more details on using this tool and additional features available in the full package.</p>"},{"location":"CernVM/","title":"CernVM","text":""},{"location":"CernVM/#standalone-use-inside-cernvm","title":"Standalone use inside CernVM","text":"<p>Standalone by adding the <code>CMS</code> group to the CVMFS Configuration. A minimal <code>CernVM</code> working context setup can be found in the CernVM Marketplace under <code>Experimental/HiggsCombine</code> or at https://cernvm-online.cern.ch/context/view/9ee5960ce4b143f5829e72bbbb26d382. At least 2GB of disk space should be reserved on the virtual machine for Combine to work properly.</p>"},{"location":"CernVM/#available-machines-for-standalone-combine","title":"Available machines for standalone combine","text":"<p>The standalone version can be easily compiled via CVMFS as it relies on dependencies which are already installed at /cvmfs/cms.cern.ch/. Access to /cvmfs/cms.cern.ch/ can be obtained from lxplus machines or via <code>CernVM</code>. The only requirement will be to add the CMS group to the CVMFS configuration as shown in the picture</p> <p></p> <p>At least 2GB of disk space should be reserved on the virtual machine for combine to work properly. A minimal CernVM working context setup can be found in the CernVM Marketplace under <code>Experimental/HiggsCombine</code>. </p> <p>To use this predefined context, first locally launch the CernVM (eg you can use the .ova with VirtualBox, by downloading from here and launching the downloaded file. You can click on \"pair an instance of CernVM\" from the cernvm-online dashboard, which displays a PIN. In the VirtualBox terminal, pair the virtual machine with this PIN code (enter in the terminal using #PIN eg <code>#123456</code>. After this, you will be asked again for username (use <code>user</code>) and then a password (use <code>hcomb</code>).</p> <p>In case you do not want to use the cvmfs area, you will need to adapt the location of the dependencies listed in both the Makefile and env_standalone.sh files.</p>"},{"location":"releaseNotes/","title":"Release notes","text":""},{"location":"releaseNotes/#cmssw-10_2_x-v800","title":"CMSSW 10_2_X - v8.0.0","text":"<p>This release contains all of the changes listed for v7.0.13 below. In addition:</p> <ul> <li>New documentation pages, using the mkdocs framework. The documentation source is included in the repository as simple markdown files. Users are welcome to make additions and corrections as pull requests to this repo.</li> <li>It is now possible to include additional constraint terms for regularisiation when unfolding using combine. Detailed documentation for this is given here.</li> <li>The option <code>-S 0</code> to remove all systematic uncertainties has been removed. Instead, to freeze all constrained nuisance parameters the option <code>--freezeParameters allConstrainedNuisances</code> should be used, which replaces the previous shortcut of <code>--freezeParameters all</code>.</li> <li>The possibility to use some old method names has now been fully removed. When setting the <code>-M</code> option, <code>FitDiagnostics</code>, <code>AsymptoticLimits</code> and <code>Significance</code> must be used instead of, respectively, <code>MaxLikelihoodFit</code>, <code>Asymptotic</code> and <code>ProfileLikelihood</code>.</li> </ul>"},{"location":"releaseNotes/#cmssw-8_1_x-v7013","title":"CMSSW 8_1_X - v7.0.13","text":"<ul> <li>Nuisance <code>edit</code> selections for bins, processes or systematic names now require a complete string match. For example, <code>nuisance edit add procA binA [...]</code> will no longer match <code>procAB</code> and <code>binAB</code>. Note that regex selections can still be used to match multiple labels, but again are now required to match the full strings.</li> <li>Nuisance parameters can now be frozen using attributes that have been assigned to the corresponding RooRealVars. Syntax is <code>--freezeWithAttributes attr1,attr2,...,attrN</code>.</li> <li>For Higgs analyses: added YR4 cross sections, branching ratios and partial width uncertainties in <code>data/lhc-hxswg/sm/</code>, as used in HIG-17-031</li> <li>[EXPERIMENTAL] For binned analyses using autoMCStats a faster implementation of the vertical template morphing for shape uncertainties can be enabled at runtime with the option <code>--X-rtd FAST_VERTICAL_MORPH</code>. Any results using this flag should be validated carefully against the default.</li> </ul>"},{"location":"tutorials-part-2/","title":"Tutorials part 2","text":""},{"location":"tutorials-part-2/#datacard-for-shape-analyses","title":"Datacard for Shape analyses","text":"<p>The datacard has to be supplemented with two extensions: 1 a new block of lines defining how channels and processes are mapped into shapes 1 the block for systematics that can contain also rows with shape uncertainties.</p> <p>The expected shape can be parametric or not parametric. In the first case the parametric pdfs have to be given as input to the tool. In the latter case, for each channel, histograms have to be provided for the expected shape of each process. For what concerns data, they have to be provided as input to the tool as a histogram to perform a binned shape analysis and as a tree to perform an unbinned shape analysis.</p>"},{"location":"tutorials-part-2/#not-parametric-shapes-and-uncertainties","title":"Not parametric shapes and uncertainties","text":"<p>For each channel, histograms have to be provided for the observed shape and for the expected shape of each process.</p> <ul> <li>Within each channel, all histograms must have the same binning.</li> <li>The normalization of the data histogram must correspond to the number of observed events</li> <li>The normalization of the expected histograms must match the expected yields</li> </ul> <p>The combine tool can take as input histograms saved as TH1 or as RooAbsHist in a RooFit workspace (an example of how to create a RooFit workspace and save histograms is available in github).</p> <p>Shape uncertainties can be taken into account by vertical interpolation of the histograms, like in the HIG-10-002 analysis. The shapes are interpolated quadratically for shifts below 1\u03c3 and linearly beyond. The normalizations are interpolated linearly in log scale just like we do for log-normal uncertainties.</p> <p>For each shape uncertainty and process/channel affected by it, two additional input shapes have to be provided, obtained shifting that parameter up and down by one standard deviation. When building the likelihood, each shape uncertainty is associated to a nuisance parameter taken from a unit gaussian distribution, which is used to interpolate or extrapolate using the specified histograms.</p> <p>For each given source of shape uncertainty, in the part of the datacard containing shape uncertainties (last block), there must be a row</p> <ul> <li>_name %RED%shape effect for each process and channel_</li> </ul> <p>The effect can be \"-\" or 0 for no effect, 1 for normal effect, and possibly something different from 1 to test larger or smaller effects (in that case, the unit gaussian is scaled by that factor before using it as parameter for the interpolation) fre The block of lines defining the mapping (first block in the datacard) contains one or more rows in the form</p> <ul> <li> shapes  process channel file histogram [ _histogram_withsystematics ]</li> </ul> <p>In this line</p> <ul> <li>process is any one the process names, or * for all processes, or data_obs for the observed data</li> <li>channel is any one the process names, or * for all channels</li> <li>_file, histogram and _histogram_withsystematics_ identify the names of the files and of the histograms within the file, after doing some replacements (if any are found):<ul> <li>$PROCESS is replaced with the process name (or \"data_obs\" for the observed data)</li> <li>$CHANNEL is replaced with the channel name</li> <li>$SYSTEMATIC is replaced with the name of the systematic + (Up, Down)</li> <li>$MASS is replaced with the higgs mass value which is passed as option in the command line used to run the limit tool</li> </ul> </li> </ul> <p>The datacard in simple-shapes-TH1.txt is a clear example of how to include shapes in the datacard. In the first block the following line specifies the shape mapping:</p> <pre><code>shapes * * simple-shapes-TH1.root $PROCESS $PROCESS_$SYSTEMATIC\n</code></pre> <p>The last block concerns the treatment of the systematics affecting shapes. In this part the two uncertainties effecting on the shape are listed.</p> <pre><code>alpha  shape    -           1   uncertainty on background shape and normalization\nsigma  shape    0.5         -   uncertainty on signal resolution. Assume the histogram is a 2 sigma shift, \n#                                so divide the unit gaussian by 2 before doing the interpolation\n</code></pre> <p>There are two options for the interpolation algorithm in the \"shape\" uncertainty. Putting <code>shape</code> will result in a quadratic interpolation (within +/-1 sigma) and a linear extrapolation (beyond +/-1 sigma) of the fraction of events in each bin - i.e the histograms are first normalised before interpolation. Putting <code>shapeN</code> while instead base the interpolation on the logs of the fraction in each bin. The total normalisation is interpolated using an asymmetric log-normal so that the effect of the systematic on both the shape and normalisation are accounted for. The following image shows a comparison of those two algorithms for this datacard.</p> <p></p> <p>&lt;img alt=\"compare_shape_algo.png\" src=\"%ATTACHURLPATH%/compare_shape_algo.png\" /&gt;</p> <p></p> <p>In this case there are two processes, signal and background, and two uncertainties affecting background (alpha) and signal shape (sigma). Within the root file 2 histograms per systematic have to be provided, they are the shape obtained, for the specific process, shifting up and down the parameter associated to the uncertainty: _backgroundalphaUp and _background_alphaDown, _signalsigmaUp and _signalsigmaDown. This is the content of the root file simple-shapes-TH1.root  associated to the datacard simple-shapes-TH1.txt:</p> <pre><code>root [0] \nAttaching file simple-shapes-TH1.root as _file0...\nroot [1] _file0-&gt;ls()\nTFile**     simple-shapes-TH1.root  \n TFile*     simple-shapes-TH1.root  \n  KEY: TH1F signal;1    Histogram of signal__x\n  KEY: TH1F signal_sigmaUp;1    Histogram of signal__x\n  KEY: TH1F signal_sigmaDown;1  Histogram of signal__x\n  KEY: TH1F background;1    Histogram of background__x\n  KEY: TH1F background_alphaUp;1    Histogram of background__x\n  KEY: TH1F background_alphaDown;1  Histogram of background__x\n  KEY: TH1F data_obs;1  Histogram of data_obs__x\n  KEY: TH1F data_sig;1  Histogram of data_sig__x\n</code></pre> <p></p> <p>For example, without shape uncertainties you could have just one row with <code>shapes * * shapes.root $CHANNEL/$PROCESS</code> Then for a simple example for two channels \"e\", \"mu\" with three processes \"higgs\", \"zz\", \"top\" you should create a rootfile that contains the following</p> histogram meaning <code>e/data_obs</code> observed data in electron channel <code>e/higgs</code> expected shape for higgs in electron channel <code>e/zz</code> expected shape for ZZ in electron channel <code>e/top</code> expected shape for top in electron channel <code>mu/data_obs</code> observed data in muon channel <code>mu/higgs</code> expected shape for higgs in muon channel <code>mu/zz</code> expected shape for ZZ in muon channel <code>mu/top</code> expected shape for top in muon channel <p>If you also have one uncertainty that affects the shape, e.g. jet energy scale, you should create shape histograms for the jet energy scale shifted up by one sigma, you could for example do one folder for each process and write a like like <code>shapes * * shapes.root $CHANNEL/$PROCESS/nominal  $CHANNEL/$PROCESS/$SYSTEMATIC</code> or just attach a postifx to the name of the histogram <code>shapes * * shapes.root $CHANNEL/$PROCESS  $CHANNEL/$PROCESS_$SYSTEMATIC</code></p> <p></p> <p>Parametric shapes and uncertainties</p> <p>If you want to combine a channel with shapes with one that is a simple counting experiment, you have to declare some fake shapes in the datacard of the counting experiment. This can be done simply by adding a line to the datacard</p> <ul> <li> shapes  process channel %RED%FAKE%ENDCOLOR%</li> </ul> <p></p> <p>As of tag <code>T01-06-00</code>  (note the initial <code>T</code> instead of <code>V</code>, since it's still only for testing)</p> <ul> <li>Shapes: choice-yes<ul> <li> If doing toy mc generation, must run with <code>--generateBinnedWorkaround</code> (or <code>-U</code> / <code>--unbinned</code>), due to a bug in RooFit</li> </ul> </li> <li>Shape uncertainties: choice-yes<ul> <li>shapes with vertical shape morphing (quadratic up to 1 sigma, then linear)</li> <li>exponential morphing on the normalization (just like for an asymmetric log-normal uncertainty)</li> <li>one can select linear morphing (<code>shapeL</code>) or multiplicative morphing (<code>shapeN</code>) as well, but with some caveats:<ul> <li>only one morphing algorithm can be used for a given shape</li> <li>multiplicative morphing is applied to the normalized shapes, and then the normalization is interpolated separately. also, note that this is much slower than quadratic or linear morphing (factor 10-100)</li> </ul> </li> <li>if you get results that look unreasonable, it could be that the truncation effects due to some part of the shape becoming negative are sizable. you can partially recover from this problem forcing roofit to re-normalize explicitly the function (just replace <code>shape</code> with ==shape*==; note, will be much slower), but it's likely that you need some other approach to handle the shape systematics</li> </ul> </li> </ul> <p>This includes also a few other features not in this twiki:</p> <ul> <li>Support for RooFit shapes (specifying &lt;tt&gt; workspaceName :objectName&lt;/tt&gt; in place of histogramName):<ul> <li>Binned datasets (RooDataHist) for data and for mc processes: choice-yes</li> <li>Unbinned datasets (RooDataSet) for data: choice-yes</li> <li>Arbitrary shapes (RooAbsPdf) for mc processes: choice-yes<ul> <li>choice-yes Parametric shape uncertainties can be specified among the other systematics in a line     &lt;tt&gt;name param mean uncertainty [range] &lt;/tt&gt;.     The uncertainty can be either the sigma of a gaussian or <code>-xx/+yy</code> (with no spaces) for a bifurcated gaussian.     The range is optional. if present, it should be <code>[hi,lo]</code> (with no spaces).</li> <li> Normalization will always be taken from text datacard</li> </ul> </li> <li>Unbinned templates (RooDataSet) for mc processes : choice-yes (but not tested)</li> <li> arbitrary shapes must have unique parameter names and they should match with the names of the systematics</li> </ul> </li> <li>Support for plain <code>TTrees</code> as inputs instead of RooDataSet: choice-yes (but not tested)</li> <li>Mixing of histograms with RooFit shapes is not supported.</li> </ul> <p></p>"},{"location":"tutorials-part-2/#binned-shape-analysis","title":"Binned shape analysis","text":"<p>See the 2014 Data Analysis School tutorial.</p>"},{"location":"tutorials-part-2/#unbinned-shape-analysis","title":"Unbinned shape analysis","text":"<p>This example is taken from 2014 Data Analysis School and use H-&gt;gg datacards as an example. This is an example of an unbinned, parametric analysis.</p> <p>In some cases, it can be convenient to describe the expected signal and background shapes in terms of analytical functions rather than templates; a typical example are the searches where the signal is apparent as a narrow peak over a smooth continuum background. In this context, uncertainties affecting the shapes of the signal and backgrounds can be implemented naturally as uncertainties on the parameters of those analytical functions. It is also possible to adapt an agnostic approach in which the parameters of the background model are left freely floating in the fit to the data, i.e. only requiring the background to be well described by a smooth function.</p> <p>Technically, this is implemented by means of the RooFit package, that allows writing generic probability density functions, and saving them into ROOT files. The pdfs can be either taken from RooFit's standard library of functions (e.g. Gaussians, polynomials, ...) or hand-coded in C++, and combined together to form even more complex shapes.</p> <p>A prototypical case for this kind of analysis is H\u2192\u03b3\u03b3 analysis. For this excercise, we will use a datacard that contains only the 8 TeV data for four event categories: cat0 and cat1 are categories of untagged events containing good quality diphotons, the former of the two with a higer purity but lower event yield obtained preferentially selecting high p&lt;sub&gt;T&lt;/sub&gt; diphotons; cat4 and cat5 are categories of di-jet events with different levels of tightness (and so also different level of signal contamination from gluon fusion).</p> <p>The datacard is the following:</p> <pre><code>imax 4 number of bins\njmax 5 number of processes minus 1\nkmax * number of nuisance parameters\n----------------------------------------------------------------------------------------------------------------------------------\nshapes WH        cat0      hgg.inputsig_8TeV_MVA.root wsig_8TeV:hggpdfrel_wh_cat0\nshapes ZH        cat0      hgg.inputsig_8TeV_MVA.root wsig_8TeV:hggpdfrel_zh_cat0\nshapes bkg_mass  cat0      hgg.inputbkgdata_8TeV_MVA.root cms_hgg_workspace:pdf_data_pol_model_8TeV_cat0\nshapes data_obs  cat0      hgg.inputbkgdata_8TeV_MVA.root cms_hgg_workspace:roohist_data_mass_cat0\nshapes ggH       cat0      hgg.inputsig_8TeV_MVA.root wsig_8TeV:hggpdfrel_ggh_cat0\nshapes qqH       cat0      hgg.inputsig_8TeV_MVA.root wsig_8TeV:hggpdfrel_vbf_cat0\nshapes ttH       cat0      hgg.inputsig_8TeV_MVA.root wsig_8TeV:hggpdfrel_tth_cat0\n[... same as above for cat1, cat4, cat5 ...]\n----------------------------------------------------------------------------------------------------------------------------------\nbin          cat0         cat1         cat4         cat5       \nobservation  -1.0         -1.0         -1.0         -1.0       \n----------------------------------------------------------------------------------------------------------------------------------\nbin                                      cat0         cat0         cat0         cat0         cat0         cat0         cat1         cat1         cat1         cat1         cat1         cat1         cat4         cat4         cat4         cat4         cat4         cat4         cat5         cat5         cat5         cat5         cat5         cat5       \nprocess                                  ZH           qqH          WH           ttH          ggH          bkg_mass     ZH           qqH          WH           ttH          ggH          bkg_mass     ZH           qqH          WH           ttH          ggH          bkg_mass     ZH           qqH          WH           ttH          ggH          bkg_mass   \nprocess                                  -4           -3           -2           -1           0            1            -4           -3           -2           -1           0            1            -4           -3           -2           -1           0            1            -4           -3           -2           -1           0            1          \nrate                                     6867.0000    19620.0000   12753.0000   19620.0000   19620.0000   1.0000       7259.4000    19620.0000   12360.6000   19620.0000   19620.0000   1.0000       7063.2000    19620.0000   12556.8000   19620.0000   19620.0000   1.0000       3924.0000    19620.0000   15696.0000   19620.0000   19620.0000   1.0000     \n----------------------------------------------------------------------------------------------------------------------------------\nCMS_eff_j               lnN              0.999125     0.964688     0.999125     0.998262     0.996483     -            0.999616     0.980982     0.999616     0.99934      0.999012     -            1.02         1.02         1.02         1.02         1.02         -            1.02         1.02         1.02         1.02         1.02         -          \nCMS_hgg_JECmigration    lnN              -            -            -            -            -            -            -            -            -            -            -            -            0.853986     0.995971     0.853986     0.846677     0.927283     -            1.025        1.005        1.025        1.025        1.025        -          \nCMS_hgg_UEPSmigration   lnN              -            -            -            -            -            -            -            -            -            -            -            -            0.737174     0.991941     0.737174     0.724019     0.86911      -            1.045        1.01         1.045        1.045        1.045        -          \nCMS_hgg_eff_MET         lnN              -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -          \nCMS_hgg_eff_e           lnN              -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -          \nCMS_hgg_eff_m           lnN              -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -            -          \nCMS_hgg_eff_trig        lnN              1.01         1.01         1.01         1.01         1.01         -            1.01         1.01         1.01         1.01         1.01         -            1.01         1.01         1.01         1.01         1.01         -            1.01         1.01         1.01         1.01         1.01         -          \nCMS_hgg_n_id            lnN              1.034/0.958  1.039/0.949  1.034/0.958  1.053/0.915  1.035/0.958  -            1.042/0.936  1.038/0.948  1.042/0.936  1.053/0.909  1.038/0.954  -            1.016/0.972  1.022/0.963  1.016/0.972  1.017/0.967  1.019/0.964  -            1.024/0.959  1.030/0.948  1.024/0.959  1.014/0.975  1.023/0.962  -          \nCMS_hgg_n_pdf_1         lnN              -            0.998/0.996  -            -            1.002/0.998  -            -            0.992/0.999  -            -            1.001/1.000  -            -            0.999/0.998  -            -            1.003/0.999  -            -            0.996/1.000  -            -            1.002/0.999  -          \nCMS_hgg_n_pdf_10        lnN              -            1.028/1.004  -            -            0.998/0.998  -            -            1.051/0.997  -            -            1.004/0.999  -            -            1.020/1.000  -            -            1.000/0.998  -            -            1.010/0.999  -            -            0.999/1.000  -          \n[... and more rows like this ...]\nCMS_hgg_n_sc_gf         lnN              -            -            -            -            0.842/1.123  -            -            -            -            -            0.976/1.031  -            -            -            -            -            0.858/1.095  -            -            -            -            -            0.880/1.083  -          \nCMS_hgg_n_sc_vbf        lnN              -            0.993/1.010  -            -            -            -            -            0.994/0.994  -            -            -            -            -            0.997/1.001  -            -            -            -            -            0.999/0.996  -            -            -            -          \nCMS_hgg_n_sigmae        lnN              0.950/1.099  0.943/1.114  0.950/1.099  0.956/1.089  0.944/1.112  -            0.954/1.093  0.948/1.104  0.954/1.093  0.971/1.057  0.919/1.165  -            0.996/1.006  0.992/1.016  0.996/1.006  0.995/1.010  0.994/1.012  -            0.991/1.019  0.985/1.031  0.991/1.019  0.995/1.010  0.988/1.026  -          \nCMS_id_eff_eb           lnN              1.01999      1.020047     1.01999      1.02002      1.020022     -            1.018535     1.019332     1.018535     1.018642     1.019654     -            1.017762     1.017952     1.017762     1.018824     1.01812      -            1.016723     1.016872     1.016723     1.01884      1.017172     -          \nCMS_id_eff_ee           lnN              1.000284     1.000137     1.000284     1.000206     1.0002       -            1.004035     1.001979     1.004035     1.003759     1.001148     -            1.006058     1.005556     1.006058     1.003308     1.005127     -            1.008752     1.008351     1.008752     1.003254     1.007586     -          \nJEC                     lnN              0.995187     0.938204     0.995187     0.990442     0.980656     -            0.997891     0.966719     0.997891     0.996368     0.994567     -            1.11         1.035        1.11         1.11         1.11         -            1.11         1.035        1.11         1.11         1.11         -          \nQCDscale_VH             lnN              0.982/1.021  -            0.982/1.021  -            -            -            0.982/1.021  -            0.982/1.021  -            -            -            0.982/1.021  -            0.982/1.021  -            -            -            0.982/1.021  -            0.982/1.021  -            -            -          \nQCDscale_ggH            lnN              -            -            -            -            0.918/1.076  -            -            -            -            -            0.918/1.076  -            -            -            -            -            0.918/1.076  -            -            -            -            -            0.918/1.076  -          \nQCDscale_qqH            lnN              -            0.992/1.003  -            -            -            -            -            0.992/1.003  -            -            -            -            -            0.992/1.003  -            -            -            -            -            0.992/1.003  -            -            -            -          \nQCDscale_ttH            lnN              -            -            -            0.906/1.041  -            -            -            -            -            0.906/1.041  -            -            -            -            -            0.906/1.041  -            -            -            -            -            0.906/1.041  -            -          \nUEPS                    lnN              0.988624     0.858751     0.988624     0.977408     0.954278     -            0.995014     0.923929     0.995014     0.991416     0.987158     -            1.26         1.08         1.26         1.26         1.26         -            1.26         1.08         1.26         1.26         1.26         -          \nlumi_8TeV               lnN              1.044        1.044        1.044        1.044        1.044        -            1.044        1.044        1.044        1.044        1.044        -            1.044        1.044        1.044        1.044        1.044        -            1.044        1.044        1.044        1.044        1.044        -          \npdf_gg                  lnN              -            -            -            0.920/1.080  0.930/1.076  -            -            -            -            0.920/1.080  0.930/1.076  -            -            -            -            0.920/1.080  0.930/1.076  -            -            -            -            0.920/1.080  0.930/1.076  -          \npdf_qqbar               lnN              0.958/1.042  0.972/1.026  0.958/1.042  -            -            -            0.958/1.042  0.972/1.026  0.958/1.042  -            -            -            0.958/1.042  0.972/1.026  0.958/1.042  -            -            -            0.958/1.042  0.972/1.026  0.958/1.042  -            -            -          \nvtxEff                  lnN              0.991/1.025  0.989/1.030  0.991/1.025  0.993/1.020  0.989/1.030  -            0.990/1.026  0.990/1.027  0.990/1.026  0.994/1.016  0.984/1.042  -            1.000/0.999  0.997/1.007  1.000/0.999  1.000/1.003  0.998/1.006  -            0.999/1.004  0.998/1.006  0.999/1.004  1.000/1.000  0.997/1.007  -          \nCMS_hgg_nuissancedeltamcat4  param  0.0 0.001458\nCMS_hgg_nuissancedeltafracright_8TeV  param  1.0 0.002000\nCMS_hgg_nuissancedeltamcat1  param  0.0 0.001470\nCMS_hgg_nuissancedeltamcat0  param  0.0 0.001530\nCMS_hgg_nuissancedeltasmearcat4  param  0.0 0.001122\nCMS_hgg_nuissancedeltasmearcat1  param  0.0 0.001167\nCMS_hgg_nuissancedeltasmearcat0  param  0.0 0.001230\nCMS_hgg_globalscale  param  0.0 0.004717\n</code></pre> <p>The first difference compared to the template datacard is in the <code>shapes</code> line; let's take for example these two lines</p> <pre><code>shapes ggH       cat0      hgg.inputsig_8TeV_MVA.root wsig_8TeV:hggpdfrel_ggh_cat0\nshapes data_obs  cat0      hgg.inputbkgdata_8TeV_MVA.root cms_hgg_workspace:roohist_data_mass_cat0\n</code></pre> <p>In the datacard using templates, the column after the file name would have been the name of the histogram. Here, instead, we found two names, separated by a colon (<code>:</code>): the first part identifies the name of the RooWorkspace containing the pdf, and the second part the name of the RooAbsPdf inside it (or, for the observed data, the RooAbsData).</p> <p>Let's inspect this workspace, starting with the data</p> <pre><code>%CODE{\"cpp\"}%\nTFile *fDat = TFile::Open(\"hgg.inputbkgdata_8TeV_MVA.root\");\nRooAbsData *data = cms_hgg_workspace-&amp;gt;data(\"roohist_data_mass_cat0\");\ndata-&amp;gt;Print(\"\")\n// --&amp;gt; RooDataHist::roohist_data_mass_cat0[CMS_hgg_mass] = 160 bins (1449 weights)\n// so, we have a binned dataset, whose variable is called CMS_hgg_mass:\nRooRealVar *mass = cms_hgg_workspace-&amp;gt;var(\"CMS_hgg_mass\");\nmass-&amp;gt;Print(\"\");\n// RooRealVar::CMS_hgg_mass = 140  L(100 - 180)\n\n// we can make a plot of the dataset with the following\nRooPlot *plot = mass-&amp;gt;frame();\ndata-&amp;gt;plotOn(plot);\nplot-&amp;gt;Draw();\n%ENDCODE%\n</code></pre> <p>&lt;img alt=\"datacards_Hgg_data_cat0.png\" src=\"%ATTACHURLPATH%/datacards_Hgg_data_cat0.png\" /&gt;</p> <p>Now let's look also at the signal</p> <pre><code>%CODE{\"cpp\"}%\nTFile *sig = TFile::Open(\"hgg.inputsig_8TeV_MVA.root\");\nRooWorkspace *wsig_8TeV = (RooWorkspace*)sig-&amp;gt;Get(\"wsig_8TeV\")  // necessary to Get the workspace in ROOT6 to avoid reloading\nRooAbsPdf *ggH = wsig_8TeV-&amp;gt;pdf(\"hggpdfrel_ggh_cat0\");\nggH-&amp;gt;Print(\"\");\n// --&amp;gt; RooAddPdf::hggpdfrel_ggh_cat0[ hist_func_frac_g0_ggh_cat0 * hgg_gaus_g0_ggh_cat0 + hist_func_frac_g1_ggh_cat0 * hgg_gaus_g1_ggh_cat0 + const_func_frac_g2_ggh_cat0 * hgg_gaus_g2_ggh_cat0 ] = 0.604097\n// this appears to be a linear combination of multiple gaussian pdfs (hgg_gaus_g0_ggh_cat0, hgg_gaus_g1_ggh_cat0, ...) with coefficents hist_func_frac_g0_ggh_cat0, hist_func_frac_g1_ggh_cat0\n\n// let's get the list of the parameters that describe it\nRooArgSet *params = ggH-&amp;gt;getParameters(*data);\nparams-&amp;gt;Print(\"\");\n// --&amp;gt; RooArgSet::parameters = (CMS_hgg_globalscale,CMS_hgg_nuissancedeltamcat0,CMS_hgg_nuissancedeltasmearcat0,MH)\n\n// MH is a special parameter, which combine and text2workspace set to the Higgs mass hypothesis.\n// now since we're just looking into the input workspace, we can set it by hand\nwsig_8TeV-&amp;gt;var(\"MH\")-&amp;gt;setVal(125.7);\n\n// Now we can make a plot of the pdf, and show also the contributions from the different gaussians from which it is composed\nRooPlot *plot =  wsig_8TeV-&amp;gt;var(\"CMS_hgg_mass\")-&amp;gt;frame();\nggH-&amp;gt;plotOn(plot);\nggH-&amp;gt;plotOn(plot, RooFit::Components(\"hgg_gaus_g0_ggh_cat0\"), RooFit::LineColor(kRed));\nggH-&amp;gt;plotOn(plot, RooFit::Components(\"hgg_gaus_g1_ggh_cat0\"), RooFit::LineColor(209));\nggH-&amp;gt;plotOn(plot, RooFit::Components(\"hgg_gaus_g2_ggh_cat0\"), RooFit::LineColor(222));\nplot-&amp;gt;Draw();\n%ENDCODE%\n</code></pre> <p>&lt;img alt=\"datacards_Hgg_ggH_cat0.png\" src=\"%ATTACHURLPATH%/datacards_Hgg_ggH_cat0.png\" /&gt;</p>"},{"location":"tutorials-part-2/#parametric-signal-normalization","title":"Parametric signal normalization","text":"<p>There is also another feature of the H\u2192\u03b3\u03b3 datacard that should catch your eye quicky: the event yields are remarkably strange: the the signal yield is <code>19620.0000</code> events for ggH, qqH and ttH, the background yield is <code>1.0</code>, and observed event yield is <code>-1.0</code>.</p> <p>Let's start with the simple case: an event yield of <code>-1</code> just instructs text2workspace and combine to take the yield from the corresponding dataset in the input rootfile, avoiding the need of writing it in the text datacard, but also making the datacard less human-readable. Incidentally, this feature can be used also for datacards that use root histograms like the H\u2192\u03c4\u03c4 example above.</p> <p>Now, the signal and background yields: 19k signal events from each production mode with just one background event would be really nice to have, but of course it can't be true. The way the H\u2192\u03b3\u03b3 works is by relying on an additional feature of text2workspace: in addition to providing generic shapes for the signals and backgrounds, it is also possible to provide generic functions that describe the expected signal and background yields. This additional functions are multiplied by the number in the <code>rate</code> column of the datacard to obtain the final expected event yield. This feature allows e.g. to use the very same datacard to describe all possible different Higgs boson mass hypotheses by just parameterizing properly the expected yield as function of the <code>MH</code> variable.</p> <p>At present, this feature is not indicated by any special line the datacard: simply, whenever a RooAbsPdf is loaded, text2workspace will search also for a RooAbsReal object with the same name but a <code>_norm</code> postfix, and if present it will use it to scale the event yield.  WARNING  As with all parameters in the workspace, if this RooAbsReal object is not set constant, (i.e is a RooRealVar which you have not set constant or a function of non-constant vars) it will be floating in the fit. This is especially problematic for the signal as the default parameter added to models for limits/p-values <code>r</code> (the floating signal strength) will be degenerate with this <code>_norm</code> parameter. In this H\u2192\u03b3&amp;gamma example, the object has been setup to be constant to avoid this.</p> <p>Note: The newest version of combine will not accept RooExtendedPdfs as an input anymore. This is to alleviate a bug that lead to improper treatment of normalization when using multiple RooExtendedPdfs to describe a single process. Simply follow the above instructions and combine will create the appropriate extended pdf as long as the name of the RooAbsReal is pdfname_norm. Make sure the variable is not set to constant if you intend to have the normalization float.</p> <p>Armed with this new piece of knowledge, we can now determine what is the expected signal yield for ggH in category 0:</p> <pre><code>%CODE{\"cpp\"}%\nTFile *sig = TFile::Open(\"hgg.inputsig_8TeV_MVA.root\");\nRooWorkspace *wsig_8TeV = (RooWorkspace*)sig-&amp;gt;Get(\"wsig_8TeV\")  // necessary to Get the workspace in ROOT6 to avoid reloading\nwsig_8TeV-&amp;gt;var(\"MH\")-&amp;gt;setVal(125.7);\nRooAbsPdf *ggH = wsig_8TeV-&amp;gt;pdf(\"hggpdfrel_ggh_cat0\");\nRooAbsReal *ggH_norm = wsig_8TeV-&amp;gt;function(\"hggpdfrel_ggh_cat0_norm\");\ncout &amp;lt;&amp;lt; ggH_norm-&amp;gt;getVal()*19620.0000 &amp;lt;&amp;lt; endl;\n// --&amp;gt; 12.3902\n%ENDCODE%\n</code></pre> <p>This approach can also be used to make a background freely floating, by associating to them as normalization term a floating RooRealVar. However, this can be achieved in a more transparent way by putting instead a normalization uncertainty on that background using a flat pdf: e.g. to leave the background floating between 50% and 200% of its input prediction, a <code>lnU</code> systematic can be used with \u03ba<code>2 ( ==lnU=</code> has a syntax like <code>lnN</code>, but produces a uniform pdf between 1/\u03ba and \u03ba rather than a log-normal; see SWGuideHiggsAnalysisCombinedLimit)</p>"},{"location":"tutorials-part-2/#shape-uncertainties-using-parameters","title":"Shape uncertainties using parameters","text":"<p>The part of the H\u2192\u03b3\u03b3 datacard related to the systematics starts with many lines of log-normals that should already be familiar, except possibly for the notation with two numbers separated by a slash (e.g. 0.950/1.099). This notation is used for asymmetrical uncertainties: a log-normal with 0.950/1.099 means that at -1\u03c3 the yield is scaled down by a factor 0.95, while at +1\u03c3 the yield is scaled up by a factor 1.099.</p> <p>The last part of the datacard contains some lines that use a different syntax, e.g.</p> <pre><code>CMS_hgg_globalscale  param  0.0 0.004717\n</code></pre> <p>These lines encode uncertainties on the parameters of the signal and background pdfs. The example line quoted here informs text2workspace that the parameter <code>CMS_hgg_globalscale</code> is to be assigned a Gaussian uncertainty of \u00b10.004717 around its mean value of zero (0.0). One can change the mean value from 0 to 1 (or really any value, if one so chooses) if the parameter in question is multiplicative instead of additive.</p> <p>The effect can be visualized from RooFit, e.g.</p> <pre><code>%CODE{\"cpp\"}%\nTFile *sig = TFile::Open(\"hgg.inputsig_8TeV_MVA.root\");\nRooWorkspace *wsig_8TeV = (RooWorkspace*)sig-&amp;gt;Get(\"wsig_8TeV\")  // necessary to Get the workspace in ROOT6 to avoid reloading\n\nwsig_8TeV-&amp;gt;var(\"MH\")-&amp;gt;setVal(125.7);\nRooAbsPdf *ggH = wsig_8TeV-&amp;gt;pdf(\"hggpdfrel_ggh_cat0\");\n\n// prepare the canvas\nRooPlot *plot =  wsig_8TeV-&amp;gt;var(\"CMS_hgg_mass\")-&amp;gt;frame();\n\n// plot nominal pdf\nggH-&amp;gt;plotOn(plot, RooFit::LineColor(kBlack));\n\n// plot minus 3 sigma pdf\nwsig_8TeV-&amp;gt;var(\"CMS_hgg_globalscale\")-&amp;gt;setVal(-3*0.004717);\nggH-&amp;gt;plotOn(plot, RooFit::LineColor(kBlue));\n\n// plot plus 3 sigma pdf\nwsig_8TeV-&amp;gt;var(\"CMS_hgg_globalscale\")-&amp;gt;setVal(+3*0.004717);\nggH-&amp;gt;plotOn(plot, RooFit::LineColor(kRed));\nplot-&amp;gt;Draw();\n%ENDCODE%\n</code></pre> <p>&lt;img alt=\"datacards_Hgg_ggH_cat0_syst.png\" src=\"%ATTACHURLPATH%/datacards_Hgg_ggH_cat0_syst.png\" /&gt;</p> <p>Note that if one wants to specify a parameter that is freely floating across its given range, and not gaussian constrained, the following syntax is used:</p> <pre><code> CMS_my_bg_param1  flatParam\n</code></pre> <p>The Hgg and HZg analyses use this syntax when adding in the parameters that correspond to their background shapes.</p> <p>#ParametricModelAndBinnedData</p>"},{"location":"tutorials-part-2/#caveat-on-using-parametric-pdfs-with-binned-datasets","title":"Caveat on using parametric pdfs with binned datasets","text":"<p>Users should be aware of a feature that affects the use of parametric pdfs together with binned datasets.</p> <p>RooFit uses the integral of the pdf, computed analytically (or numerically, but disregarding the binning), to normalize it, but then computes the expected event yield in each bin evaluating only the pdf at the bin center. This means that if the variation of the pdf is sizeable within the bin then there is a mismatch between the sum of the event yields per bin and the pdf normalization, and that can cause a bias in the fits (more properly, the bias is there if the contribution of the second derivative integrated on the bin size is not negligible, since for linear functions evaluating them at the bin center is correct).</p> <p>So, it is recommended to use bins that are significantly finer than the characteristic scale of the pdfs - which would anyway be the recommended thing even in the absence of this feature.</p> <p>Obviously, this caveat does not apply to analyses using templates (they're constant across each bin, so there's no bias), or using unbinned datasets.</p> <p></p>"},{"location":"tutorials-part-2/#analysis-with-more-generic-models","title":"Analysis with more generic models","text":""},{"location":"tutorials-part-2/#multidimensional-fits","title":"Multidimensional fits","text":""},{"location":"tutorials-part-2/#feldman-cousins-regions","title":"Feldman-Cousins regions","text":"<p>The F-C procedure for a generic model is:</p> <ul> <li>use as test statistics the profile likelihood q(x) = - 2 ln L(data|x)/L(data|x-hat) where x is a point in the parameter space, and x-hat are the point corresponding to the best fit (nuisance parameters are profiled both at numerator and at denominator)</li> <li>for each point x:<ul> <li>compute the observed test statistics q&lt;sub&gt;obs&lt;/sub&gt;(x)</li> <li>compute the expected distribution of q(x) under the hypothesis of x.</li> <li>accept the point in the region if P(q(x) &lt; q&lt;sub&gt;obs&lt;/sub&gt;(x) | x) &lt; CL</li> </ul> </li> </ul> <p>In combine, you can perform this test on each individual point (param1,param2,...) = (value1,value2,...) by doing</p> <pre><code>combine workspace.root -M HybridNew --freq --testStat=PL --rule=Pmu --singlePoint  param1=value1,param2=value2,param3=value3,...   [other options of HybridNew]\n</code></pre> <p>The point belongs to your confidence region if CL&lt;sub&gt;s+b&lt;/sub&gt; is larger than 1-CL (e.g. 0.3173 for a 1-sigma region, CL=0.6827).</p> <p>Imposing physical boundaries (such as requiring mu&gt;0) can be achieved by setting the ranges of the physics model parameters using</p> <pre><code> --setPhysicsModelParameterRanges param1=param1_min,param1_max:param2=param2_min,param2_max ....\n</code></pre> <p>. If there is no upper/lower boundary, just set that value to something far from the region of interest.</p> <p>As in general for HybridNew, you can split the task into multiple tasks and then merge the outputs, as described in the HybridNew chapter.</p> <p>For uni-dimensional models only, and if the parameter behaves like a cross-section, the code is somewhat able to do interpolation and determine the values of your parameter on the contour (just like it does for the limits). In that case, the syntax is the same as per the CLs limits with HybridNew chapter except that you want <code>--testStat=PL --rule=Pmu</code> .</p> <p>Extracting Contours</p> <p>There is a tool for extracting confidence intervals and 2D contours from the output of HybridNew located in <code>test/makeFCcontour.py</code> providing the option <code>--saveToys</code> was included when running HybridNew. I can be run taking as input, the toys files (or several of them) as,</p> <pre><code>./makeFCcontour.py  toysfile1.root toysfile2.root .... [options] -out outputfile.root\n</code></pre> <p>The tool has two modes (1D and 2D). For the 1D, add the option <code>--d1</code> and the name of the parameter of interest <code>--xvar poi_name</code>. For each confidence interval desired, add any confidence level of interest using <code>--cl 0.68,0.95...</code> The intervals corresponding to each confidence level will be printed to the terminal. The output file will contain a graph of the parameter of interest (x) vs 1-CL&lt;sub&gt;s+b&lt;/sub&gt; used to compute the intervals.</p> <p>To extract 2D contours, the names of each parameter must be given <code>--xvar poi_x --yvar poi_y</code>. The output will be a root file containing a 2D histogram of the confidence level (1-CL&lt;sub&gt;s+b&lt;/sub&gt;) for each point which can be used to draw 2D contours. There will also be a histogram containing the number of toys found for each point.</p> <p>There are several options for reducing the running time (such as setting limits on the region of interest or the minimum number of toys required for a point to be included) Finally, adding the option <code>--storeToys</code> will add histograms in for each point to the output file of the test-statistic distribution. This will increase the momory usage however as all of the toys will be stored.</p>"},{"location":"tutorials-part-2/#signal-hypothesis-separation","title":"Signal Hypothesis separation","text":"<p>In some cases, instead of separating a signal from a background, you might want to separate a signal of one type from a signal of another type (e.g. scalar vs pseudo-scalar Higgs boson).</p> <p>This is documented at SWGuideHiggsCombinationSignalSeparation</p>"},{"location":"tutorials-part-2/#throwing-post-fit-toys","title":"Throwing post-fit toys","text":"<p>From here:</p> <pre><code>#build workspace for mu-mh fit\ntext2workspace.py ../cards/hgg_datacard_mva_comb_bernsteins.txt -m 125 -P HiggsAnalysis.CombinedLimit.PhysicsModel:floatingHiggsMass --PO higgsMassRange=105,155 -o testmasshggcomb.root\n\n#perform s+b fit and save workspace+snapshot\ncombine testmasshggcomb.root -m 125 -M MultiDimFit --saveWorkspace --verbose 9 -n mumhfit\n\n#throw post-fit toy with b from s+b(floating mu,mh) fit, s with r=1.0, m=best fit MH, using nuisance values and constraints re-centered on s+b(floating mu-mh) fit values (aka frequentist post-fit expected)\n#and compute post-fit expected mu uncertainty profiling MH\ncombine higgsCombinemumhfit.MultiDimFit.mH125.root --snapshotName MultiDimFit -M MultiDimFit --verbose 9 -n randomtest --toysFrequentist --bypassFrequentistFit  -t -1 --expectSignal=1 -P r --floatOtherPOIs=1 --algo singles\n\n#throw post-fit toy with b from s+b(floating mu,mh) fit, s with r=1.0, m=128.0, using nuisance values and constraints re-centered on s+b(floating mu-mh) fit values (aka frequentist post-fit expected)\n#and compute post-fit expected significance (with MH fixed at 128 implicitly)\ncombine higgsCombinemumhfit.MultiDimFit.mH125.root -m 128 --snapshotName MultiDimFit -M ProfileLikelihood --significance --verbose 9 -n randomtest --toysFrequentist --bypassFrequentistFit --overrideSnapshotMass -t -1 --expectSignal=1 --redefineSignalPOIs r --freezeNuisances MH\n\n#throw post-fit toy with b from s+b(floating mu,mh) fit, s with r=0.0, using nuisance values and constraints re-centered on s+b(floating mu-mh) fit values (aka frequentist post-fit expected)\n#and compute post-fit expected and observed asymptotic limit (with MH fixed at 128 implicitly)\ncombine higgsCombinemumhfit.MultiDimFit.mH125.root -m 128 --snapshotName MultiDimFit -M Asymptotic --verbose 9 -n randomtest --bypassFrequentistFit --overrideSnapshotMass--redefineSignalPOIs r --freezeNuisances MH\n</code></pre>"},{"location":"tutorials-part-2/#modifying-parameters-of-interest-on-the-command-line","title":"Modifying parameters of interest on the command line","text":"<p>Normally, the parameters of interest of a model are defined by the PhysicsModel used by text2workspace.</p> <p>However, combine provides command line options to redefine on the fly what are the parameters of interest (useful also if the workspaces are built from external tools and not text2workspace), for setting the values of the parameters and their ranges. The MultiDimFit method already provides conventient handles to specify which parameter to analyze and how to deal with the others (floating or fixed), but these commands are more general as they apply to all statistical methods and they can affect any kind of parameters in the model, not only those that were pre-defined as parameters of interest (the wording \"physics model parameter\" or \"nuisance\" in the names of the options is there only because that's typically what they are applied to, not because their functionality is restricted to parameters of that kind)</p> <ul> <li><code>--setPhysicsModelParameters name=value[,name2=value2,...]</code> sets the starting values of the parameters, useful e.g. when generating toy MC or when also setting the parameters as fixed.</li> <li><code>--setPhysicsModelParameterRanges name=min,max[:name2=min2,max2:...]</code> sets the ranges of the parameters (useful e.g. for scanning in MultiDimFit, or for Bayesian integration)</li> <li><code>--redefineSignalPOIs name[,name2,...]</code> redefines the set of parameters of interest.<ul> <li>if the parameters where constant in the input workspace, they are re-defined to be floating.</li> <li>nuisances promoted to parameters of interest are removed from the list of nuisances, and thus they are not randomized in methods that randomize nuisances (e.g. HybridNew in non-frequentist mode, or BayesianToyMC, or in toy generation with <code>-t</code> but without <code>--toysFreq</code>).     This doesn't have any impact on algorithms that don't randomize nuisances (e.g. fits, Asymptotic, or HybridNew in fequentist mode) or on algorithms that treat all parameters in the same way (e.g. MarkovChainMC).</li> <li>Note that constraint terms for the nuisances are dropped after promotion to a POI using <code>--redefineSignalPOI</code>. To produce a likelihood scan for a nuisance parameter, using MultiDimFit with <code>--algo grid</code>, you should instead use the <code>--poi</code> option which will not cause the loss of the constraint term when scanning.</li> <li>parameters of interest of the input workspace that are not selected by this command become unconstrained nuisance parameters, but they are not added to the list of nuisances so they will not be randomized (see above)</li> </ul> </li> <li><code>--freezeNuisances &lt;name&gt;</code> sets the given parameters to constant</li> </ul> <p>A combination of the MultiSignalModel (defined above) and <code>redefineSignalPOIs</code> can be used to alter the way a datacard is interpreted to transform one signal or ordinary background process into a background with freely floating normalization, or with a fixed but different normalization (useful e.g. for cross-checks):</p> <ul> <li>First, use the MultiSignalModel to create a workspace in which that process has its own associated signal strenght parameter (e.g. <code>r_B</code>) different from that of the nomal signal (e.g. <code>r</code>)</li> <li>Then, fits or upper limits on <code>r</code> can be obtained running combine with <code>--redefineSignalPOIs r</code> so that <code>r_B</code> becomes freely floating.</li> <li><code>setPhysicsModelParameterRanges</code> can be used to redefine the range to make the process freely float only in some range (this is equivalent to adding a flat uncertainty to it, <code>lnU</code> or <code>unif</code>) while <code>freezeNuisances</code> and <code>setPhysicsModelParameters</code> can instead be used to pin it to some value.</li> <li>fits and likelihood scans of <code>r_B</code> can be used to check whether the information on this process from the data in the signal region is consistent with the a-priori prediction for it within the respective uncertainties (and <code>freezeNuisances</code> can be used to shut off the uncertainties on the a-priori prediction if one wants to see only the uncertainty from the data)</li> </ul>"},{"location":"tutorials-part-2/#advanced-tutorials","title":"Advanced Tutorials","text":"<p>Follow this link for advanced tutorials and non-standard uses of combine</p>"},{"location":"part2/bin-wise-stats/","title":"Automatic statistical uncertainties","text":""},{"location":"part2/bin-wise-stats/#introduction","title":"Introduction","text":"<p>The <code>text2workspace.py</code> script is able to produce a type of workspace, using a set of new histogram classes, in which bin-wise statistical uncertainties are added automatically. This can be built for shape-based datacards where the inputs are in TH1 format. Datacards that use RooDataHists are not supported. The bin errrors (i.e. values returned by <code>TH1::GetBinError</code>) are used to model the uncertainties.</p> <p>By default the script will attempt to assign a single nuisance parameter to scale the sum of the process yields in each bin, constrained by the total uncertainty, instead of requiring separate parameters, one per process. This is sometimes referred to as the Barlow-Beeston-lite approach, and is useful as it minimises the number of parameters required in the maximum likelihood fit. A useful description of this approach may be found in section 5 of this report.</p>"},{"location":"part2/bin-wise-stats/#usage-instructions","title":"Usage instructions","text":"<p>The following line should be added at the bottom of the datacard, underneath the systematics, to produce a new-style workspace and optionally enable the automatic bin-wise uncertainties:</p> <pre><code>[channel] autoMCStats [threshold] [include-signal = 0] [hist-mode = 1]\n</code></pre> <p>The first string <code>channel</code> should give the name of the channels (bins) in the datacard for which the new histogram classes should be used. The wildcard <code>*</code> is supported for selecting multiple channels in one go. The value of <code>threshold</code> should be set to a value greater than or equal to zero to enable the creation of automatic bin-wise uncertainties, or <code>-1</code> to use the new histogram classes without these uncertainties. A positive value sets the threshold on the effective number of unweighted events above which the uncertainty will be modeled with the Barlow-Beeston-lite approach described above. Below the threshold an individual uncertainty per-process will be created. The algorithm is described in more detail below.</p> <p>The last two settings are optional. The first of these, <code>include-signal</code> has a default value of <code>0</code> but can be set to <code>1</code> as an alternative. By default, the total nominal yield and uncertainty used to test the threshold excludes signal processes. The reason for this is that typically the initial signal normalization is arbitrary, and could unduly lead to a bin being considered well-populated despite poorly populated background templates. Setting this flag will include the signal processes in the uncertainty analysis. Note that this option only affects the logic for creating a single Barlow-Beeston-lite parameter vs. separate per-process parameters - the uncertainties on all signal processes are always included in the actual model! The second flag changes the way the normalization effect of shape-altering uncertainties is handled. In the default mode (<code>1</code>) the normalization is handled separately from the shape morphing via a an asymmetric log-normal term. This is identical to how Combine has always handled shape morphing. When set to <code>2</code>, the normalization will be adjusted in the shape morphing directly. Unless there is a strong motivation we encourage users to leave this on the default setting.</p>"},{"location":"part2/bin-wise-stats/#description-of-the-algorithm","title":"Description of the algorithm","text":"<p>When <code>threshold</code> is set to a number of effective unweighted events greater than or equal to zero, denoted n^{\\text{threshold}}, the following algorithm is applied to each bin:</p> <ol> <li>Sum the yields n_{i} and uncertainties e_{i} of each background process i in the bin. Note that the n_i and e_i include the nominal effect of any scaling parameters that have been set in the datacard, for example <code>rateParams</code>. n_{\\text{tot}} = \\sum_{i\\,\\in\\,\\text{bkg}}n_i, e_{\\text{tot}} = \\sqrt{\\sum_{i\\,\\in\\,\\text{bkg}}e_i^{2}}</li> <li>If e_{\\text{tot}} = 0, the bin is skipped and no parameters are created. If this is the case, it is a good idea to check why there is no uncertainty in the background prediction in this bin!</li> <li>The effective number of unweighted events is defined as n_{\\text{tot}}^{\\text{eff}} = n_{\\text{tot}}^{2} / e_{\\text{tot}}^{2}, rounded to the nearest integer.</li> <li>If n_{\\text{tot}}^{\\text{eff}} \\leq n^{\\text{threshold}}: separate uncertainties will be created for each process. Processes where e_{i} = 0 are skipped. If the number of effective events for a given process is lower than n^{\\text{threshold}} a Poisson-constrained parameter will be created. Otherwise a Gaussian-constrained parameter is used.</li> <li>If n_{\\text{tot}}^{\\text{eff}} \\gt n^{\\text{threshold}}: A single Gaussian-constrained Barlow-Beeston-lite parameter is created that will scale the total yield in the bin.</li> <li>Note that the values of e_{i}, and therefore e_{tot}, will be updated automatically in the model whenever the process normalizations change.</li> <li>A Gaussian-constrained parameter x has a nominal value of zero and scales the yield as n_{\\text{tot}} + x \\cdot e_{\\text{tot}}. The Poisson-constrained parameters are expressed as a yield multiplier with nominal value one: n_{\\text{tot}} \\cdot x.</li> </ol> <p>The output from <code>text2workspace.py</code> will give details on how each bin has been treated by this algorithm, for example:</p> Show example output <pre><code>============================================================\nAnalysing bin errors for: prop_binhtt_et_6_7TeV\nPoisson cut-off: 10\nProcesses excluded for sums: ZH qqH WH ggH\n============================================================\nBin        Contents        Error           Notes\n0          0.000000        0.000000        total sum\n0          0.000000        0.000000        excluding marked processes\n  =&gt; Error is zero, ignore\n------------------------------------------------------------\n1          0.120983        0.035333        total sum\n1          0.120983        0.035333        excluding marked processes\n1          12.000000       3.464102        Unweighted events, alpha=0.010082\n  =&gt; Total parameter prop_binhtt_et_6_7TeV_bin1[0.00,-7.00,7.00] to be gaussian constrained\n------------------------------------------------------------\n2          0.472198        0.232096        total sum\n2          0.472198        0.232096        excluding marked processes\n2          4.000000        2.000000        Unweighted events, alpha=0.118049\n  =&gt; Number of weighted events is below poisson threshold\n    ZH                   0.000000        0.000000\n      =&gt; Error is zero, ignore\n  ----------------------------------------------------------\n    W                    0.050606        0.029220\n                         3.000000        1.732051        Unweighted events, alpha=0.016869\n      =&gt; Product of prop_binhtt_et_6_7TeV_bin2_W[1.00,0.00,12.15] and const [3] to be poisson constrained\n  ----------------------------------------------------------\n    ZJ                   0.142444        0.140865\n                         1.000000        1.000000        Unweighted events, alpha=0.142444\n      =&gt; Product of prop_binhtt_et_6_7TeV_bin2_ZJ[1.00,0.00,30.85] and const [1] to be poisson constrained\n  ----------------------------------------------------------\n</code>"},{"location":"part2/bin-wise-stats/#analytic-minimisation","title":"Analytic minimisation","text":"<p>One significant advantage of the Barlow-Beeston-lite approach is that the maximum likelihood estimate of each nuisance parameter has a simple analytic form that depends only on n_{\\text{tot}}, e_{\\text{tot}} and the observed number of data events in the relevant bin. Therefore when minimising the negative log-likelihood of the whole model it is possible to remove these parameters from the fit and set them to their best-fit values automatically. For models with large numbers of bins this can reduce the fit time and increase the fit stability. The analytic minimisation is enabled by default starting in combine v8.2.0, you can disable it by adding the option <code>--X-rtd MINIMIZER_no_analytic</code> when running Combine.</p>\n<p>The figure below shows a performance comparison of the analytical minimisation versus the number of bins in the likelihood function. The real time (in sections) for a typical minimisation of a binned likelihood is shown as a function of the number of bins when invoking the analytic minimisation of the nuisance parameters versus the default numerical approach.</p>\n\nShow Comparison\n<p></p>"},{"location":"part2/bin-wise-stats/#technical-details","title":"Technical details","text":"<p>Up until recently <code>text2workspace.py</code> would only construct the PDF for each channel using a <code>RooAddPdf</code>, i.e. each component process is represented by a separate PDF and normalization coefficient. However, in order to model bin-wise statistical uncertainties, the alternative <code>RooRealSumPdf</code> can be more useful, as each process is represented by a RooFit function object instead of a PDF, and we can vary the bin yields directly. As such, a new RooFit histogram class <code>CMSHistFunc</code> is introduced, which offers the same vertical template morphing algorithms offered by the current default histogram PDF, <code>FastVerticalInterpHistPdf2</code>. Accompanying this is the <code>CMSHistErrorPropagator</code> class. This evaluates a sum of <code>CMSHistFunc</code> objects, each multiplied by a coefficient. It is also able to scale the summed yield of each bin to account for bin-wise statistical uncertainty nuisance parameters.</p>\n\n<p>Warning</p>\n<p>One disadvantage of this new approach comes when evaluating the expectation for individual processes, for example when using the <code>--saveShapes</code> option in the <code>FitDiagnostics</code> mode of Combine. The Barlow-Beeston-lite parameters scale the sum of the process yields directly, so extra work is needed to distribute this total scaling back to each individual process. To achieve this, an additional class <code>CMSHistFuncWrapper</code> has been created that, given a particular <code>CMSHistFunc</code>, the <code>CMSHistErrorPropagator</code> will distribute an appropriate fraction of the total yield shift to each bin. As a consequence of the extra computation needed to distribute the yield shifts in this way, the evaluation of individual process shapes in <code>--saveShapes</code> can take longer then previously.</p>"},{"location":"part2/physicsmodels/","title":"Physics Models","text":"<p>Combine can be run directly on the text-based datacard. However, for more advanced physics models, the internal step to convert the datacard to a binary workspace should be performed by the user. To create a binary workspace starting from a <code>datacard.txt</code>, you can run </p> <pre><code>text2workspace.py datacard.txt -o workspace.root\n</code></pre> <p>By default (without the <code>-o</code> option), the binary workspace will be named <code>datacard.root</code> - i.e the .txt suffix will be replaced by .root.</p> <p>A full set of options for <code>text2workspace</code> can be found by running <code>text2workspace.py --help</code>.</p> <p>The default model that will be produced when running <code>text2workspace</code> is one in which all processes identified as signal are multiplied by a common multiplier r. This is all that is needed for simply setting limits or calculating significances.</p> <p><code>text2workspace</code> will convert the datacard into a PDF that summarizes the analysis. For example, let's take a look at the data/tutorials/counting/simple-counting-experiment.txt datacard.</p> <pre><code># Simple counting experiment, with one signal and one background process\n# Extremely simplified version of the 35/pb H-&gt;WW analysis for mH = 200 GeV,\n# for 4th generation exclusion (EWK-10-009, arxiv:1102.5429v1)\nimax 1  number of channels\njmax 1  number of backgrounds\nkmax 2  number of nuisance parameters (sources of systematical uncertainties)\n------------\n# we have just one channel, in which we observe 0 events\nbin         1\nobservation 0\n------------\n# now we list the expected events for signal and all backgrounds in that bin\n# the second 'process' line must have a positive number for backgrounds, and 0 for signal\n# then we list the independent sources of uncertainties, and give their effect (syst. error)\n# on each process and bin\nbin             1      1\nprocess       ggh4G  Bckg\nprocess         0      1\nrate           4.76  1.47\n------------\ndeltaS  lnN    1.20    -    20% uncertainty on signal\ndeltaB  lnN      -   1.50   50% uncertainty on background\n</code></pre> <p>If we run <code>text2workspace.py</code> on this datacard and take a look at the workspace (<code>w</code>) inside the <code>.root</code> file produced, we will find a number of different objects representing the signal, background, and observed event rates, as well as the nuisance parameters and signal strength r. Note that often in the statistics literature, this parameter is referred to as \\mu. </p> <p>From these objects, the necessary PDF has been constructed (named <code>model_s</code>). For this counting experiment we will expect a simple PDF of the form</p>  p(n_{\\mathrm{obs}}| r,\\nu_{S},\\nu_{B})\\propto \\dfrac{[r\\cdot n_{S}(\\nu_{S})+n_{B}(\\nu_{B})]^{n_{\\mathrm{obs}}} } {n_{\\mathrm{obs}}!}e^{-[r\\cdot n_{S}(\\nu_{S})+n_{B}(\\nu_{B})]} \\cdot e^{-\\frac{1}{2}(\\nu_{S}- y_{S})^{2}} \\cdot e^{-\\frac{1}{2}(\\nu_{B}- y_{B})^{2}}  <p>where the expected signal and background rates are expressed as functions of the nuisance parameters, n_{S}(\\nu_{S}) = 4.76(1+0.2)^{\\nu_{S}}~ and ~n_{B}(\\nu_{B}) = 1.47(1+0.5)^{\\nu_{B}}. The y_{S},~y_{B} are the auxiliary observables. In the code, these will have the same name as the corresponding nuisance parameter, with the extension <code>_In</code>. </p> <p>The first term represents the usual Poisson expression for observing n_{\\mathrm{obs}} events, while the second two are the Gaussian constraint terms for the nuisance parameters. In this case {y_S}={y_B}=0, and the widths of both Gaussians are 1.</p> <p>A combination of counting experiments (or a binned shape datacard) will look like a product of PDFs of this kind. For parametric/unbinned analyses, the PDF for each process in each channel is provided instead of the using the Poisson terms and a product runs over the bin counts/events.</p>"},{"location":"part2/physicsmodels/#model-building","title":"Model building","text":"<p>For more complex models, <code>PhysicsModels</code> can be produced. To use a different physics model instead of the default one, use the option <code>-P</code> as in</p> <pre><code>text2workspace.py datacard -P HiggsAnalysis.CombinedLimit.PythonFile:modelName\n</code></pre> <p>Generic models can be implemented by writing a python class that:</p> <ul> <li>defines the model parameters (by default it is just the signal strength modifier <code>r</code>)</li> <li>defines how signal and background yields depend on the parameters (by default, the signal scales linearly with <code>r</code>, backgrounds are constant)</li> <li>potentially also modifies the systematic uncertainties (e.g. switch off theory uncertainties on cross section when measuring the cross section itself)</li> </ul> <p>In the case of SM-like Higgs boson measurements, the class should inherit from <code>SMLikeHiggsModel</code> (redefining <code>getHiggsSignalYieldScale</code>), while beyond that one can inherit from <code>PhysicsModel</code>. You can find some examples in PhysicsModel.py.</p> <p>In the 4-process model (<code>PhysicsModel:floatingXSHiggs</code>, you will see that each of the 4 dominant Higgs boson production modes get separate scaling parameters, <code>r_ggH</code>, <code>r_qqH</code>, <code>r_ttH</code> and <code>r_VH</code> (or <code>r_ZH</code> and <code>r_WH</code>) as defined in,</p> <pre><code>def doParametersOfInterest(self):\n  \"\"\"Create POI and other parameters, and define the POI set.\"\"\"\n  # --- Signal Strength as only POI ---\n  if \"ggH\" in self.modes: self.modelBuilder.doVar(\"r_ggH[1,%s,%s]\" % (self.ggHRange[0], self.ggHRange[1]))\n  if \"qqH\" in self.modes: self.modelBuilder.doVar(\"r_qqH[1,%s,%s]\" % (self.qqHRange[0], self.qqHRange[1]))\n  if \"VH\"  in self.modes: self.modelBuilder.doVar(\"r_VH[1,%s,%s]\"  % (self.VHRange [0], self.VHRange [1]))\n  if \"WH\"  in self.modes: self.modelBuilder.doVar(\"r_WH[1,%s,%s]\"  % (self.WHRange [0], self.WHRange [1]))\n  if \"ZH\"  in self.modes: self.modelBuilder.doVar(\"r_ZH[1,%s,%s]\"  % (self.ZHRange [0], self.ZHRange [1]))\n  if \"ttH\" in self.modes: self.modelBuilder.doVar(\"r_ttH[1,%s,%s]\" % (self.ttHRange[0], self.ttHRange[1]))\n  poi = \",\".join([\"r_\"+m for m in self.modes])\n  if self.pois: poi = self.pois\n  ...\n</code></pre> <p>The mapping of which POI scales which process is handled via the following function,</p> <pre><code>def getHiggsSignalYieldScale(self,production,decay, energy):\n  if production == \"ggH\": return (\"r_ggH\" if \"ggH\" in self.modes else 1)\n  if production == \"qqH\": return (\"r_qqH\" if \"qqH\" in self.modes else 1)\n  if production == \"ttH\": return (\"r_ttH\" if \"ttH\" in self.modes else (\"r_ggH\" if self.ttHasggH else 1))\n  if production in [ \"WH\", \"ZH\", \"VH\" ]: return (\"r_VH\" if \"VH\" in self.modes else 1)\n  raise RuntimeError, \"Unknown production mode '%s'\" % production\n</code></pre> <p>You should note that <code>text2workspace</code> will look for the python module in <code>PYTHONPATH</code>. If you want to keep your model local, you'll need to add the location of the python file to <code>PYTHONPATH</code>.</p> <p>A number of models used in the LHC Higgs combination paper can be found in LHCHCGModels.py. These can be easily accessed by providing for example <code>-P HiggsAnalysis.CombinedLimit.HiggsCouplings:c7</code> and others defined un HiggsCouplings.py.</p> <p>Below are some (more generic) example models that also exist in GitHub.</p>"},{"location":"part2/physicsmodels/#multisignalmodel-ready-made-model-for-multiple-signal-processes","title":"MultiSignalModel ready made model for multiple signal processes","text":"<p>Combine already contains a model <code>HiggsAnalysis.CombinedLimit.PhysicsModel:multiSignalModel</code> that can be used to assign different signal strengths to multiple processes in a datacard, configurable from the command line.</p> <p>The model is configured by passing one or more mappings in the form <code>--PO 'map=bin/process:parameter'</code> to text2workspace:</p> <ul> <li><code>bin</code> and <code>process</code> can be arbitrary regular expressions matching the bin names and process names in the datacard.     Note that mappings are applied both to signals and to background processes; if a line matches multiple mappings, precedence is given to the last one in the order they are in the command line.     It is suggested to put quotes around the argument of <code>--PO</code> so that the shell does not try to expand any <code>*</code> signs in the patterns.</li> <li><code>parameter</code> is the POI to use to scale that process (<code>name[starting_value,min,max]</code> the first time a parameter is defined, then just <code>name</code> if used more than once).     Special values are <code>1</code> and <code>0==; ==0</code> means \"drop the process completely from the model\", while <code>1</code> means to \"keep the yield as is in the card with no scaling\" (as normally done for backgrounds); <code>1</code> is the default that is applied to processes that have no mappings. Therefore it is normally not needed, but it may be used to override a previous more generic match in the same command line (e.g. <code>--PO 'map=.*/ggH:r[1,0,5]' --PO 'map=bin37/ggH:1'</code> would treat ggH as signal in general, but count it as background in the channel <code>bin37</code>).</li> </ul> <p>Passing the additional option <code>--PO verbose</code> will set the code to verbose mode, printing out the scaling factors for each process; we encourage the use this option to make sure that the processes are being scaled correctly.</p> <p>The MultiSignalModel will define all parameters as parameters of interest, but that can be then changed from the command line, as described in the following subsection.</p> <p>Some examples, taking as reference the toy datacard test/multiDim/toy-hgg-125.txt:</p> <ul> <li>Scale both <code>ggH</code> and <code>qqH</code> with the same signal strength <code>r</code> (that is what the default physics model of Combine does for all signals; if they all have the same systematic uncertainties, it is also equivalent to adding up their yields and writing them as a single column in the card)</li> </ul> <pre><code>  $ text2workspace.py -P HiggsAnalysis.CombinedLimit.PhysicsModel:multiSignalModel  --PO verbose --PO 'map=.*/ggH:r[1,0,10]' --PO 'map=.*/qqH:r' toy-hgg-125.txt -o toy-1d.root\n  [...]\n  Will create a POI  r  with factory  r[1,0,10]\n  Mapping  r  to  ['.*/ggH']  patterns\n  Mapping  r  to  ['.*/qqH']  patterns\n  [...]\n  Will scale  incl/bkg  by  1\n  Will scale  incl/ggH  by  r\n  Will scale  incl/qqH  by  r\n  Will scale  dijet/bkg  by  1\n  Will scale  dijet/ggH  by  r\n  Will scale  dijet/qqH  by  r\n</code></pre> <ul> <li>Define two independent parameters of interest <code>r_ggH</code> and <code>r_qqH</code></li> </ul> <pre><code>  $ text2workspace.py -P HiggsAnalysis.CombinedLimit.PhysicsModel:multiSignalModel  --PO verbose --PO 'map=.*/ggH:r_ggH[1,0,10]' --PO 'map=.*/qqH:r_qqH[1,0,20]' toy-hgg-125.txt -o toy-2d.root\n  [...]\n  Will create a POI  r_ggH  with factory  r_ggH[1,0,10]\n  Mapping  r_ggH  to  ['.*/ggH']  patterns\n  Will create a POI  r_qqH  with factory  r_qqH[1,0,20]\n  Mapping  r_qqH  to  ['.*/qqH']  patterns\n  [...]\n  Will scale  incl/bkg  by  1\n  Will scale  incl/ggH  by  r_ggH\n  Will scale  incl/qqH  by  r_qqH\n  Will scale  dijet/bkg  by  1\n  Will scale  dijet/ggH  by  r_ggH\n  Will scale  dijet/qqH  by  r_qqH\n</code></pre> <ul> <li>Fix <code>ggH</code> to SM, define only <code>qqH</code> as parameter</li> </ul> <pre><code>  $ text2workspace.py -P HiggsAnalysis.CombinedLimit.PhysicsModel:multiSignalModel  --PO verbose --PO 'map=.*/ggH:1' --PO 'map=.*/qqH:r_qqH[1,0,20]' toy-hgg-125.txt -o toy-1d-qqH.root\n  [...]\n  Mapping  1  to  ['.*/ggH']  patterns\n  Will create a POI  r_qqH  with factory  r_qqH[1,0,20]\n  Mapping  r_qqH  to  ['.*/qqH']  patterns\n  [...]\n  Will scale  incl/bkg  by  1\n  Will scale  incl/ggH  by  1\n  Will scale  incl/qqH  by  r_qqH\n  Will scale  dijet/bkg  by  1\n  Will scale  dijet/ggH  by  1\n  Will scale  dijet/qqH  by  r_qqH\n</code></pre> <ul> <li>Drop <code>ggH</code> , and define only <code>qqH</code> as parameter</li> </ul> <pre><code> $ text2workspace.py -P HiggsAnalysis.CombinedLimit.PhysicsModel:multiSignalModel  --PO verbose --PO 'map=.*/ggH:0' --PO 'map=.*/qqH:r_qqH[1,0,20]' toy-hgg-125.txt -o toy-1d-qqH0-only.root\n [...]\n Mapping  0  to  ['.*/ggH']  patterns\n Will create a POI  r_qqH  with factory  r_qqH[1,0,20]\n Mapping  r_qqH  to  ['.*/qqH']  patterns\n [...]\n Will scale  incl/bkg  by  1\n Will scale  incl/ggH  by  0\n Will scale  incl/qqH  by  r_qqH\n Will scale  dijet/bkg  by  1\n Will scale  dijet/ggH  by  0\n Will scale  dijet/qqH  by  r_qqH\n</code></pre>"},{"location":"part2/physicsmodels/#two-hypothesis-testing","title":"Two Hypothesis testing","text":"<p>The <code>PhysicsModel</code> that encodes the signal model above is the twoHypothesisHiggs, which assumes signal processes with suffix _ALT will exist in the datacard. An example of such a datacard can be found under data/benchmarks/simple-counting/twoSignals-3bin-bigBSyst.txt</p> <pre><code> $ text2workspace.py twoSignals-3bin-bigBSyst.txt -P HiggsAnalysis.CombinedLimit.HiggsJPC:twoHypothesisHiggs -m 125.7 --PO verbose -o jcp_hww.root\n\n MH (not there before) will be assumed to be 125.7\n Process  S  will get norm  not_x\n Process  S_ALT  will get norm  x\n Process  S  will get norm  not_x\n Process  S_ALT  will get norm  x\n Process  S  will get norm  not_x\n Process  S_ALT  will get norm  x\n</code></pre> <p>The two processes (S and S_ALT) will get different scaling parameters. The LEP-style likelihood for hypothesis testing can now be used by setting x or not_x to 1 and 0 and comparing the two likelihood evaluations.</p>"},{"location":"part2/physicsmodels/#signal-background-interference","title":"Signal-background interference","text":"<p>Since negative probability distribution functions do not exist, the recommended way to implement this is to start from the expression for the individual amplitudes A and the parameter of interest k,</p>  \\mathrm{Yield} = |k * A_{s} + A_{b}|^2 = k^2 * |A_{s}|^2 + k * 2 \\Re(A_{s}^* A_{b}) + |A_{b}|^2 = \\mu * S + \\sqrt{\\mu} * I + B  <p>where</p> <p>\\mu = k^2, ~S = |A_{s}|^2,~B = |A_b|^2 and S+B+I = |A_s + A_b|^2.</p> <p>With some algebra you can work out that,</p> <p>\\mathrm{Yield} = \\sqrt{\\mu} * \\left[S+B+I\\right] + (\\mu-\\sqrt{\\mu}) * \\left[S\\right] + (1-\\sqrt{\\mu}) * \\left[B\\right]</p> <p>where square brackets represent the input (histograms as <code>TH1</code> or <code>RooDataHists</code>) that one needs to provide.</p> <p>An example of this scheme is implemented in a HiggsWidth and is completely general, since all of the three components above are strictly positive. In this example, the POI is <code>CMS_zz4l_mu</code> and the equations for the three components are scaled (separately for the qqH and ggH processes) as,</p> <pre><code> self.modelBuilder.factory_( \"expr::ggH_s_func(\\\"@0-sqrt(@0)\\\", CMS_zz4l_mu)\")\n self.modelBuilder.factory_(  \"expr::ggH_b_func(\\\"1-sqrt(@0)\\\", CMS_zz4l_mu)\")\n self.modelBuilder.factory_(  \"expr::ggH_sbi_func(\\\"sqrt(@0)\\\", CMS_zz4l_mu)\")\n\n self.modelBuilder.factory_( \"expr::qqH_s_func(\\\"@0-sqrt(@0)\\\", CMS_zz4l_mu)\")\n self.modelBuilder.factory_(  \"expr::qqH_b_func(\\\"1-sqrt(@0)\\\", CMS_zz4l_mu)\")\n self.modelBuilder.factory_(  \"expr::qqH_sbi_func(\\\"sqrt(@0)\\\", CMS_zz4l_mu)\")\n</code></pre>"},{"location":"part2/physicsmodels/#multi-process-interference","title":"Multi-process interference","text":"<p>The above formulation can be extended to multiple parameters of interest (POIs). See AnalyticAnomalousCoupling for an example. However, the computational performance scales quadratically with the number of POIs, and can get extremely expensive for 10 or more, as may be encountered often with EFT analyses. To alleviate this issue, an accelerated interference modeling technique is implemented for template-based analyses via the <code>interferenceModel</code> physics model. In this model, each bin yield y is parameterized</p>  y(\\vec{\\mu}) = y_0 (\\vec{\\mu}^\\top M \\vec{\\mu})  <p>as a function of the POI vector \\vec{\\mu}, a nominal template y_0, and a scaling matrix M. To see how this parameterization relates to that of the previous section, we can define:</p>  y_0 = A_b^2, \\qquad M = \\frac{1}{A_b^2} \\begin{bmatrix}  |A_s|^2 &amp; \\Re(A_s^* A_b) \\\\  \\Re(A_s A_b^*) &amp; |A_b|^2  \\end{bmatrix}, \\qquad \\vec{\\mu} = \\begin{bmatrix}  \\sqrt{\\mu} \\\\  1  \\end{bmatrix}  <p>which leads to the same parameterization. At present, this technique only works with <code>CMSHistFunc</code>-based workspaces, as these are the most common workspace types encountered and the default when using autoMCStats. To use this model, for each bin find y_0 and put it into the datacard as a signal process, then find M and save the lower triangular component as an array in a <code>scaling.json</code> file with a syntax as follows:</p> <pre><code>[\n  {\n    \"channel\": \"my_channel\",\n    \"process\": \"my_nominal_process\",\n    \"parameters\": [\"sqrt_mu[1,0,2]\", \"Bscaling[1]\"],\n    \"scaling\": [\n      [0.5, 0.1, 1.0],\n      [0.6, 0.2, 1.0],\n      [0.7, 0.3, 1.0]\n    ]\n  }\n]\n</code></pre> <p>where the parameters are declared using RooFit's factory syntax and each row of the <code>scaling</code> field represents the scaling information of a bin, e.g. if y_0 = |A_b|^2 then each row would contain three entries:</p>  |A_s|^2 / |A_b|^2,\\quad \\Re(A_s^* A_b)/|A_b|^2,\\quad 1  <p>For several coefficients, one would enumerate as follows:</p> <pre><code>scaling = []\nfor ibin in range(nbins):\n    binscaling = []\n    for icoef in range(ncoef):\n        for jcoef in range(icoef + 1):\n            binscaling.append(amplitude_squared_for(ibin, icoef, jcoef))\n    scaling.append(binscaling)\n</code></pre> <p>Then, to construct the workspace, run</p> <pre><code>text2workspace.py card.txt -P HiggsAnalysis.CombinedLimit.InterferenceModels:interferenceModel \\\n    --PO verbose --PO scalingData=scaling.json\n</code></pre> <p>For large amounts of scaling data, you can optionally use gzipped json (<code>.json.gz</code>) or pickle (<code>.pkl.gz</code>) files with 2D numpy arrays for the scaling coefficients instead of lists. The function <code>numpy.tril_indices(ncoef)</code> is helpful for extracting the lower triangle of a square matrix.</p> <p>You could pick any nominal template, and adjust the scaling as appropriate. Generally it is advisable to use a nominal template corresponding to near where you expect the best-fit values of the POIs to be so that the shape systematic effects are well-modeled in that region.</p> <p>It may be the case that the relative contributions of the terms are themselves a function of the POIs. For example, in VBF di-Higgs production, BSM modifications to the production rate can be parameterized in the \"kappa\" framework via three diagrams, with scaling coefficients \\kappa_V \\kappa_\\lambda, \\kappa_V^2, and \\kappa_{2V}, respectively, that interfere.  In that case, you can declare formulas with the factory syntax to represent each amplitude as follows:</p> <pre><code>[\n  {\n    \"channel\": \"a_vbf_channel\",\n    \"process\": \"VBFHH\",\n    \"parameters\": [\"expr::a0('@0*@1', kv[1,0,2], kl[1,0,2])\", \"expr::a1('@0*@0', kv[1,0,2])\", \"k2v[1,0,2]\"],\n    \"scaling\": [\n      [3.30353674666415, -8.54170982038222, 22.96464188467882, 4.2353483207128, -11.07996258835088, 5.504469544697623],\n      [2.20644332142891, -7.076836641962523, 23.50989689214267, 4.053185685866683, -13.08569222837996, 7.502346155380032]\n    ]\n  }\n]\n</code></pre> <p>However, you will need to manually specify what the POIs should be when creating the workspace using the <code>POIs=</code> physics option, e.g.</p> <pre><code>text2workspace.py card.txt -P HiggsAnalysis.CombinedLimit.InterferenceModels:interferenceModel \\\n  --PO scalingData=scaling.json --PO 'POIs=kl[1,0,2]:kv[1,0,2]:k2v[1,0,2]'\n</code></pre>"},{"location":"part2/settinguptheanalysis/","title":"Preparing the datacard","text":"<p>The input to Combine, which defines the details of the analysis, is a plain ASCII file we will refer to as datacard. This is true whether the analysis is a simple counting experiment or a shape analysis.</p>"},{"location":"part2/settinguptheanalysis/#a-simple-counting-experiment","title":"A simple counting experiment","text":"<p>The file data/tutorials/counting/realistic-counting-experiment.txt shows an example of a counting experiment.</p> <p>The first lines can be used to add some descriptive information. Those lines must start with a \"#\", and they are not parsed by Combine:</p> <pre><code># Simple counting experiment, with one signal and a few background processes\n# Simplified version of the 35/pb H-&gt;WW analysis for mH = 160 GeV\n</code></pre> <p>Following this, one declares the number of observables, <code>imax</code>, that are present in the model used to set limits / extract confidence intervals. The number of observables will typically be the number of channels in a counting experiment. The value <code>*</code> can be specified for <code>imax</code>, which tells Combine to determine the number of observables from the rest of the datacard. In order to better catch mistakes, it is recommended to explicitly specify the value. </p> <pre><code>imax 1  number of channels\n</code></pre> <p>This declaration is followed by a specification of the number of background sources to be considered, <code>jmax</code>, and the number of independent sources of systematic uncertainty, <code>kmax</code>:</p> <pre><code>jmax 3  number of backgrounds\nkmax 5  number of nuisance parameters (sources of systematic uncertainty)\n</code></pre> <p>In the example there is 1 channel, there are 3 background sources, and there are 5 independent sources of systematic uncertainty.</p> <p>After providing this information, the following lines describe what is observed in data: the number of events observed in each channel. The first line, starting with <code>bin</code>, defines the label used for each channel. In the example we have 1 channel, labelled <code>1</code>, and in the following line, <code>observation</code>, the number of observed events is given: <code>0</code> in this example.</p> <pre><code># we have just one channel, in which we observe 0 events\nbin bin1\nobservation 0\n</code></pre> <p>This is followed by information related to the expected number of events, for each bin and process, arranged in (#channels)*(#processes) columns.</p> <pre><code>bin          bin1     bin1     bin1     bin1\nprocess         ggH  qqWW  ggWW  others\nprocess          0     1     2     3\nrate           1.47  0.63  0.06  0.22\n</code></pre> <ul> <li>The <code>bin</code> line identifies the channel that the column refers to. It ranges from <code>1</code> to the value of <code>imax</code> declared above.</li> <li>The first <code>process</code> line contains the names of the various process sources</li> <li>The second <code>process</code> line is a numerical process identifier. Backgrounds are given a positive number, while <code>0</code> and negative numbers are used for signal processes. Different process identifiers must be used for different processes.</li> <li>The last line, <code>rate</code>, gives the expected number of events for the given process in the specified bin</li> </ul> <p>If a process does not contribute in a given bin, it can be removed from the datacard, or the rate can be set to 0.</p> <p>The final section of the datacard describes the systematic uncertainties:</p> <pre><code>lumi    lnN    1.11    -   1.11    -    lumi affects both signal and gg-&gt;WW (mc-driven). lnN = lognormal\nxs_ggH  lnN    1.16    -     -     -    gg-&gt;H cross section + signal efficiency + other minor ones.\nWW_norm gmN 4    -   0.16    -     -    WW estimate of 0.64 comes from sidebands: 4 events in sideband times 0.16 (=&gt; ~50% statistical uncertainty)\nxs_ggWW lnN      -     -   1.50    -    50% uncertainty on gg-&gt;WW cross section\nbg_others lnN    -     -     -   1.30   30% uncertainty on the rest of the backgrounds\n</code></pre> <ul> <li>The first column is the name of the nuisance parameter, a label that is used to identify the uncertainty</li> <li>The second column identifies the type of distribution used to describe the nuisance parameter<ul> <li><code>lnN</code> stands for Log-normal, which is the recommended choice for multiplicative corrections (efficiencies, cross sections, ...).     If \u0394x/x is the relative uncertainty in the multiplicative correction, one should put 1+\u0394x/x in the column corresponding to the process and channel. Asymmetric log-normals are instead supported by providing \u03ba<sub>down</sub>/\u03ba<sub>up</sub> where \u03ba<sub>down</sub> is the ratio of the the yield to the nominal value for a -1\u03c3 deviation of the nuisance parameter and \u03ba<sub>up</sub> is the ratio of the yield to the nominal value for a +1\\sigma deviation. Note that for a single-value log-normal with value \\kappa=1+\\Delta x/x, the yield of the process it is associated with is multiplied by \\kappa^{\\theta}. At \\theta=0 the nominal yield is retained, at \\theta=1\\sigma the yield is multiplied by \\kappa and at \\theta=-1\\sigma the yield is multiplied by 1/\\kappa. This means that an uncertainty represented as <code>1.2</code> does not multiply the nominal yield by 0.8 for \\theta=-1\\sigma; but by 0.8333. It may therefore be desirable to encode large uncertainties that have a symmetric effect on the yield as asymmetric log-normals instead. </li> <li><code>gmN</code> stands for Gamma, and is the recommended choice for the statistical uncertainty in a background determined from the number of events in a control region (or in an MC sample with limited sample size).     If the control region or simulated sample contains N events, and the extrapolation factor from the control region to the signal region is \u03b1, one shoud put N just after the <code>gmN</code> keyword, and then the value of \u03b1 in the relevant (bin,process) column. The yield specified in the <code>rate</code> line for this (bin,process) combination should equal N\u03b1.</li> <li><code>lnU</code> stands for log-uniform distribution. A value of 1+\u03b5 in the column will imply that the yield of this background is allowed to float freely between x(1+\u03b5) and x/(1+\u03b5). In particular, if \u03b5 is small, this is approximately (x-\u0394x,x+\u0394x) with \u03b5=\u0394x/x.     This distribution is typically useful when you want to set a large a-priori uncertainty on a given background process, and then rely on the correlation between channels to constrain it. Note that for this use case, we usually recommend using a <code>rateParam</code> instead. If you do use <code>lnU</code>, please be aware that while Gaussian-like uncertainties behave in a similar way under profiling and marginalization, uniform uncertainties do not. This means the impact of the uncertainty on the result will depend on how the nuisance parameters are treated. </li> </ul> </li> <li>The next (#channels)*(#processes) columns indicate the relative effect of the systematic uncertainty on the rate of each process in each channel. The columns are aligned with those in the previous lines declaring bins, processes, and rates.</li> </ul> <p>In the example, there are 5 uncertainties:</p> <ul> <li>The first uncertainty has an 11% effect on the signal and on the <code>ggWW</code> process.</li> <li>The second uncertainty affects the signal by 16%, but leaves the background processes unaffected</li> <li>The third line specifies that the <code>qqWW</code> background comes from a sideband with 4 observed events and an extrapolation factor of 0.16; the resulting uncertainty in the expected yield is 1/\\sqrt{4+1} = 45%</li> <li>The fourth uncertainty does not affect the signal, has a 50% effect on the <code>ggWW</code> background, and leaves the other backgrounds unaffected</li> <li>The fifth uncertainty does not affect the signal, has a 30% effect on the <code>others</code> background process, and does not affect the remaining backgrounds.</li> </ul>"},{"location":"part2/settinguptheanalysis/#shape-analyses","title":"Shape analyses","text":"<p>The datacard has to be supplemented with two extensions:</p> <ul> <li>A new block of lines defining how channels and processes are mapped into shapes.</li> <li>The block for systematics can now also contain rows with shape uncertainties.</li> </ul> <p>The expected shape can be parametric, or not. In the first case the parametric PDFs have to be given as input to the tool. In the latter case, for each channel, histograms have to be provided for the expected shape of each process. The data have to be provided as input as a histogram to perform a binned shape analysis, and as a RooDataSet to perform an unbinned shape analysis.</p> <p>Warning</p> <p>If using RooFit-based inputs (RooDataHists/RooDataSets/RooAbsPdfs) then you need to ensure you are using different RooRealVars as the observable in each category entering the statistical analysis. It is possible to use the same RooRealVar if the observable has the same range (and binning if using binned data) in each category, although in most cases it is simpler to avoid doing this.</p>"},{"location":"part2/settinguptheanalysis/#rates-for-shape-analyses","title":"Rates for shape analyses","text":"<p>As with the counting experiment, the total nominal rate of a given process must be identified in the rate line of the datacard. However, there are special options for shape-based analyses, as follows:</p> <ul> <li>A value of -1 in the rate line means Combine will calculate the rate from the input TH1 (via TH1::Integral) or RooDataSet/RooDataHist (via RooAbsData::sumEntries).</li> <li>For parametric shapes (RooAbsPdf), if a parameter with the name pdfname_norm is found in the input workspace, the rate will be multiplied by the value of that parameter. Note that since this parameter can be freely floating, the normalization of a process can be set freely float this way. This can also be achieved through the use of <code>rateParams</code>.</li> </ul>"},{"location":"part2/settinguptheanalysis/#binned-shape-analyses","title":"Binned shape analyses","text":"<p>For each channel, histograms have to be provided for the observed shape and for the expected shape of each process.</p> <ul> <li>Within each channel, all histograms must have the same binning.</li> <li>The normalization of the data histogram must correspond to the number of observed events.</li> <li>The normalization of the expected histograms must match the expected event yields.</li> </ul> <p>The Combine tool can take as input histograms saved as TH1, as RooAbsHist in a RooFit workspace (an example of how to create a RooFit workspace and save histograms is available in github), or from a pandas dataframe (example).</p> <p>The block of lines defining the mapping (first block in the datacard) contains one or more rows of the form</p> <ul> <li>shapes process channel file histogram [histogram_with_systematics] **</li> </ul> <p>In this line,</p> <ul> <li>process is any one the process names, or * for all processes, or data_obs for the observed data;</li> <li>channel is any one the process names, or * for all channels;</li> <li>file, histogram and histogram_with_systematics identify the names of the files and of the histograms within the file, after making some replacements (if any are found):<ul> <li>$PROCESS is replaced with the process name (or \"data_obs\" for the observed data);</li> <li>$CHANNEL is replaced with the channel name;</li> <li>$SYSTEMATIC is replaced with the name of the systematic + (Up, Down);</li> <li>$MASS is replaced with the chosen (Higgs boson) mass value that is passed as a command-line option when running the tool</li> </ul> </li> </ul> <p>In addition, user-defined keywords can be used. Any word in the datacard $WORD will be replaced by VALUE when including the option <code>--keyword-value WORD=VALUE</code>. This option can be repeated multiple times for multiple keywords.</p>"},{"location":"part2/settinguptheanalysis/#template-shape-uncertainties","title":"Template shape uncertainties","text":"<p>Shape uncertainties can be taken into account by vertical interpolation of the histograms. The shapes (fraction of events f in each bin) are interpolated using a spline for shifts below +/- 1\u03c3 and linearly outside of that. Specifically, for nuisance parameter values |\\nu|\\leq 1 </p>  f(\\nu) = \\frac{1}{2} \\left( (\\delta^{+}-\\delta^{-})\\nu + \\frac{1}{8}(\\delta^{+}+\\delta^{-})(3\\nu^6 - 10\\nu^4 + 15\\nu^2) \\right)  <p>and for |\\nu|&gt; 1 (|\\nu|&lt;-1), f(\\nu) is a straight line with gradient \\delta^{+} (\\delta^{-}), where \\delta^{+}=f(\\nu=1)-f(\\nu=0), and \\delta^{-}=f(\\nu=-1)-f(\\nu=0), derived using the nominal and up/down histograms. This interpolation is designed so that the values of f(\\nu) and its derivatives are continuous for all values of \\nu. </p> <p>The normalizations are interpolated linearly in log scale, just like we do for log-normal uncertainties. If the value in a given bin is negative for some value of \\nu, the value will be truncated at 0.</p> <p>For each shape uncertainty and process/channel affected by it, two additional input shapes have to be provided. These are obtained by shifting the parameter up and down by one standard deviation. When building the likelihood, each shape uncertainty is associated to a nuisance parameter taken from a unit gaussian distribution, which is used to interpolate or extrapolate using the specified histograms.</p> <p>For each given shape uncertainty, the part of the datacard describing shape uncertainties must contain a row</p> <ul> <li>** name shape effect_for_each_process_and_channel **</li> </ul> <p>The effect can be \"-\" or 0 for no effect, 1 for the normal effect, and something different from 1 to test larger or smaller effects (in that case, the unit gaussian is scaled by that factor before using it as parameter for the interpolation).</p> <p>The datacard in data/tutorials/shapes/simple-shapes-TH1.txt provides an example of how to include shapes in the datacard. In the first block the following line specifies the shape mapping:</p> <pre><code>shapes * * simple-shapes-TH1.root $PROCESS $PROCESS_$SYSTEMATIC\n</code></pre> <p>The last block concerns the treatment of the systematic uncertainties that affect shapes. In this case there are two uncertainties with a shape-altering effect.</p> <pre><code>alpha  shape    -           1   uncertainty on background shape and normalization\nsigma  shape    0.5         -   uncertainty on signal resolution. Assume the histogram is a 2 sigma shift,\n#                                so divide the unit gaussian by 2 before doing the interpolation\n</code></pre> <p>There are two options for the interpolation algorithm in the \"shape\" uncertainty. Putting <code>shape</code> will result in an interpolation of the fraction of events in each bin. That is, the histograms are first normalized before interpolation. Putting <code>shapeN</code> while instead base the interpolation on the logs of the fraction in each bin. For both <code>shape</code>  and <code>shapeN</code>, the total normalization is interpolated using an asymmetric log-normal, so that the effect of the systematic on both the shape and normalization are accounted for. The following image shows a comparison of the two algorithms for the example datacard.</p> <p></p> <p>In this case there are two processes, signal and background, and two uncertainties affecting the background (alpha) and signal shapes (sigma). In the ROOT file, two histograms per systematic have to be provided, they are the shapes obtained, for the specific process, by shifting the parameter associated with the uncertainty up and down by a standard deviation: <code>background_alphaUp</code> and <code>background_alphaDown</code>, <code>signal_sigmaUp</code> and <code>signal_sigmaDown</code>.</p> <p>The content of the ROOT file simple-shapes-TH1.root  associated with the datacard data/tutorials/shapes/simple-shapes-TH1.txt is:</p> <pre><code>root [0]\nAttaching file simple-shapes-TH1.root as _file0...\nroot [1] _file0-&gt;ls()\nTFile**     simple-shapes-TH1.root\n TFile*     simple-shapes-TH1.root\n  KEY: TH1F signal;1    Histogram of signal__x\n  KEY: TH1F signal_sigmaUp;1    Histogram of signal__x\n  KEY: TH1F signal_sigmaDown;1  Histogram of signal__x\n  KEY: TH1F background;1    Histogram of background__x\n  KEY: TH1F background_alphaUp;1    Histogram of background__x\n  KEY: TH1F background_alphaDown;1  Histogram of background__x\n  KEY: TH1F data_obs;1  Histogram of data_obs__x\n  KEY: TH1F data_sig;1  Histogram of data_sig__x\n</code></pre> <p>For example, without shape uncertainties there would only be one row with <code>shapes * * shapes.root $CHANNEL/$PROCESS</code> Then, to give a simple example for two channels (\"e\", \"mu\") with three processes ()\"higgs\", \"zz\", \"top\"), the ROOT file contents should look like:</p> histogram meaning <code>e/data_obs</code> observed data in electron channel <code>e/higgs</code> expected shape for higgs in electron channel <code>e/zz</code> expected shape for ZZ in electron channel <code>e/top</code> expected shape for top in electron channel <code>mu/data_obs</code> observed data in muon channel <code>mu/higgs</code> expected shape for higgs in muon channel <code>mu/zz</code> expected shape for ZZ in muon channel <code>mu/top</code> expected shape for top in muon channel <p>If there is also an uncertainty that affects the shape, e.g. the jet energy scale, shape histograms for the jet energy scale shifted up and down by one sigma need to be included. This could be done by creating a folder for each process and writing a line like</p> <p><code>shapes * * shapes.root $CHANNEL/$PROCESS/nominal  $CHANNEL/$PROCESS/$SYSTEMATIC</code></p> <p>or a postifx can be added to the histogram name:</p> <p><code>shapes * * shapes.root $CHANNEL/$PROCESS  $CHANNEL/$PROCESS_$SYSTEMATIC</code></p> <p>Warning</p> <p>If you have a nuisance parameter that has shape effects on some processes (using <code>shape</code>) and rate effects on other processes (using <code>lnN</code>) you should use a single line for the systematic uncertainty with <code>shape?</code>. This will tell Combine to fist look for Up/Down systematic templates for that process and if it doesnt find them, it will interpret the number that you put for the process as a <code>lnN</code> instead. </p> <p>For a detailed example of a template-based binned analysis, see the H\u2192\u03c4\u03c4 2014 DAS tutorial, or in our Tutorial pages. </p>"},{"location":"part2/settinguptheanalysis/#unbinned-or-parametric-shape-analyses","title":"Unbinned or parametric shape analyses","text":"<p>In some cases, it can be convenient to describe the expected signal and background shapes in terms of analytical functions, rather than templates. Typical examples are searches/measurements where the signal is apparent as a narrow peak over a smooth continuum background. In this context, uncertainties affecting the shapes of the signal and backgrounds can be implemented naturally as uncertainties in the parameters of those analytical functions. It is also possible to adopt an agnostic approach in which the parameters of the background model are left freely floating in the fit to the data, i.e. only requiring the background to be well described by a smooth function.</p> <p>Technically, this is implemented by means of the RooFit package, which allows writing generic probability density functions, and saving them into ROOT files. The PDFs can be either taken from RooFit's standard library of functions (e.g. Gaussians, polynomials, ...) or hand-coded in C++, and combined together to form even more complex shapes.</p> <p>In the datacard using templates, the column after the file name would have been the name of the histogram. For parametric analysis we need two names to identify the mapping, separated by a colon (<code>:</code>).</p> <p>shapes process channel shapes.root workspace_name:pdf_name</p> <p>The first part identifies the name of the input RooWorkspace containing the PDF, and the second part the name of the RooAbsPdf inside it (or, for the observed data, the RooAbsData). It is possible to have multiple input workspaces, just as there can be multiple input ROOT files. You can use any of the usual RooFit pre-defined PDFs for your signal and background models.</p> <p>Warning</p> <p>If in your model you are using RooAddPdfs, in which the coefficients are not defined recursively, Combine will not interpret them correctly. You can add the option <code>--X-rtd ADDNLL_RECURSIVE=0</code> to any Combine command in order to recover the correct interpretation, however we recommend that you instead re-define your PDF so that the coefficients are recursive (as described in the RooAddPdf documentation) and keep the total normalization (i.e the extended term) as a separate object, as in the case of the tutorial datacard.</p> <p>For example, take a look at the data/tutorials/shapes/simple-shapes-parametric.txt. We see the following line:</p> <pre><code>shapes * * simple-shapes-parametric_input.root w:$PROCESS\n[...]\nbin          1          1\nprocess      sig    bkg\n</code></pre> <p>which indicates that the input file <code>simple-shapes-parametric_input.root</code> should contain an input workspace (<code>w</code>) with PDFs named <code>sig</code> and <code>bkg</code>, since these are the names of the two processes in the datacard. Additionally, we expect there to be a data set named <code>data_obs</code>. If we look at the contents of the workspace in <code>data/tutorials/shapes/simple-shapes-parametric_input.root</code>, this is indeed what we see:</p> <pre><code>root [1] w-&gt;Print()\n\nRooWorkspace(w) w contents\n\nvariables\n---------\n(MH,bkg_norm,cc_a0,cc_a1,cc_a2,j,vogian_sigma,vogian_width)\n\np.d.f.s\n-------\nRooChebychev::bkg[ x=j coefList=(cc_a0,cc_a1,cc_a2) ] = 2.6243\nRooVoigtian::sig[ x=j mean=MH width=vogian_width sigma=vogian_sigma ] = 0.000639771\n\ndatasets\n--------\nRooDataSet::data_obs(j)\n</code></pre> <p>In this datacard, the signal is parameterized in terms of the hypothesized mass (<code>MH</code>). Combine will use this variable, instead of creating its own, which will be interpreted as the value for <code>-m</code>. For this reason, we should add the option <code>-m 30</code> (or something else within the observable range) when running Combine. You will also see there is a variable named <code>bkg_norm</code>. This is used to normalize the background rate (see the section on Rate parameters below for details).</p> <p>Warning</p> <p>Combine will not accept RooExtendedPdfs as input. This is to alleviate a bug that lead to improper treatment of the normalization when using multiple RooExtendedPdfs to describe a single process. You should instead use RooAbsPdfs and provide the rate as a separate object (see the Rate parameters section).</p> <p>The part of the datacard related to the systematics can include lines with the syntax</p> <ul> <li>name param  X Y</li> </ul> <p>These lines encode uncertainties in the parameters of the signal and background PDFs. The parameter is to be assigned a Gaussian uncertainty of Y around its mean value of X. One can change the mean value from 0 to 1 (or any value, if one so chooses) if the parameter in question is multiplicative instead of additive.</p> <p>In the data/tutorials/shapes/simple-shapes-parametric.txt datacard, there are lines for one such parametric uncertainty,</p> <pre><code>sigma   param 1.0      0.1\n</code></pre> <p>meaning there is a parameter in the input workspace called <code>sigma</code>, that should be constrained with a Gaussian centered at 1.0 with a width of 0.1. Note that the exact interpretation of these parameters is left to the user since the signal PDF is constructed externally by you. All Combine knows is that 1.0 should be the most likely value and 0.1 is its 1\u03c3 uncertainy. Asymmetric uncertainties are written using the syntax -1\u03c3/+1\u03c3 in the datacard, as is the case for <code>lnN</code> uncertainties. </p> <p>If one wants to specify a parameter that is freely floating across its given range, and not Gaussian constrained, the following syntax is used:</p> <ul> <li>name flatParam **</li> </ul> <p>Though this is not strictly necessary in frequentist methods using profiled likelihoods, as Combine will still profile these nuisances when performing fits (as is the case for the <code>simple-shapes-parametric.txt</code> datacard).</p> <p>Warning</p> <p>All parameters that are floating or constant in the user's input workspaces will remain floating or constant. Combine will not modify those for you!</p> <p>A full example of a parametric analysis can be found in this H\u2192\u03b3\u03b3 2014 DAS tutorial or in our Tutorial pages.</p>"},{"location":"part2/settinguptheanalysis/#caveat-on-using-parametric-pdfs-with-binned-datasets","title":"Caveat on using parametric PDFs with binned datasets","text":"<p>Users should be aware of a feature that affects the use of parametric PDFs together with binned datasets.</p> <p>RooFit uses the integral of the PDF, computed analytically (or numerically, but disregarding the binning), to normalize it, but computes the expected event yield in each bin by evaluating the PDF at the bin center. This means that if the variation of the pdf is sizeable within the bin, there is a mismatch between the sum of the event yields per bin and the PDF normalization, which can cause a bias in the fits. More specifically, the bias is present if the contribution of the second derivative integrated in the bin size is not negligible. For linear functions, an evaluation at the bin center is correct. There are two recommended ways to work around this issue:</p> <p>1. Use narrow bins</p> <p>It is recommended to use bins that are significantly finer than the characteristic scale of the PDFs. Even in the absence of this feature, this would be advisable. Note that this caveat does not apply to analyses using templates (they are constant across each bin, so there is no bias), or using unbinned datasets.</p> <p>2. Use a RooParametricShapeBinPdf</p> <p>Another solution (currently only implemented for 1-dimensional histograms) is to use a custom PDF that performs the correct integrals internally, as in RooParametricShapeBinPdf.</p> <p>Note that this PDF class now allows parameters that are themselves RooAbsReal objects (i.e. functions of other variables). The integrals are handled internally by calling the underlying PDF's <code>createIntegral()</code> method with named ranges created for each of the bins. This means that if the analytical integrals for the underlying PDF are available, they will be used.</p> <p>The constructor for this class requires a RooAbsReal (eg any RooAbsPdf) along with a list of RooRealVars (the parameters, excluding the observable x),</p> <pre><code>RooParametricShapeBinPdf(const char *name, const char *title,  RooAbsReal&amp; _pdf, RooAbsReal&amp; _x, RooArgList&amp; _pars, const TH1 &amp;_shape )\n</code></pre> <p>Below is a comparison of a fit to a binned dataset containing 1000 events with one observable 0 \\leq x \\leq 100. The fit function is a RooExponential of the form e^{xp}.</p> <p> </p> <p>In the upper plot, the data are binned in 100 evenly-spaced bins, while in the lower plot, there are three irregular bins. The blue lines show the result of the fit when using the RooExponential directly, while the red lines show the result when wrapping the PDF inside a RooParametricShapeBinPdf. In the narrow binned case, the two agree well, while for wide bins, accounting for the integral over the bin yields a better fit.</p> <p>You should note that using this class will result in slower fits, so you should first decide whether the added accuracy is enough to justify the reduced efficiency.</p>"},{"location":"part2/settinguptheanalysis/#beyond-simple-datacards","title":"Beyond simple datacards","text":"<p>Datacards can be extended in order to provide additional functionality and flexibility during runtime. These can also allow for the production of more complicated models and for producing more advanced results.</p>"},{"location":"part2/settinguptheanalysis/#rate-parameters","title":"Rate parameters","text":"<p>The overall rate \"expected\" of a particular process in a particular bin does not necessarily need to be a fixed quantity. Scale factors can be introduced to modify the rate directly in the datacards for ANY type of analysis. This can be achieved using the directive <code>rateParam</code> in the datacard with the following syntax,</p> <pre><code>name rateParam bin process initial_value [min,max]\n</code></pre> <p>The <code>[min,max]</code> argument is optional. If it is not included, Combine  will remove the range of this parameter. This will produce a new parameter, which multiplies the rate of that particular process in the given bin by its value, in the model (unless it already exists).</p> <p>You can attach the same <code>rateParam</code> to multiple processes/bins by either using a wild card (eg <code>*</code> will match everything, <code>QCD_*</code> will match everything starting with <code>QCD_</code>, etc.) in the name of the bin and/or process, or by repeating the <code>rateParam</code> line in the datacard for different bins/processes with the same name.</p> <p>Warning</p> <p><code>rateParam</code> is not a shortcut to evaluate the post-fit yield of a process since other nuisance parameters can also change the normalization. E.g., finding that the <code>rateParam</code> best-fit value is 0.9 does not necessarily imply that the process yield is 0.9 times the initial yield. The best is to evaluate the yield taking into account the values of all nuisance parameters using <code>--saveNormalizations</code>.</p> <p>This parameter is, by default, freely floating. It is possible to include a Gaussian constraint on any <code>rateParam</code> that is floating (i.e not a <code>formula</code> or spline) by adding a <code>param</code> nuisance line in the datacard with the same name.</p> <p>In addition to rate modifiers that are freely floating, modifiers that are functions of other parameters can be included using the following syntax,</p> <pre><code>name rateParam bin process formula args\n</code></pre> <p>where <code>args</code> is a comma-separated list of the arguments for the string <code>formula</code>. You can include other nuisance parameters in the <code>formula</code>, including ones that are Gaussian constrained (i,e via the <code>param</code> directive.)</p> <p>Below is an example datacard that uses the <code>rateParam</code> directive to implement an ABCD-like method in Combine. For a more realistic description of its use for ABCD, see the single-lepton SUSY search implementation described here.</p> <pre><code>imax 4  number of channels\njmax 0  number of processes -1\nkmax *  number of nuisance parameters (sources of systematical uncertainties)\n-------\nbin                   B      C       D        A\nobservation           50    100      500      10\n-------\nbin                   B      C       D        A\nprocess               bkg    bkg     bkg      bkg\nprocess               1      1       1         1\nrate                  1      1       1         1\n-------\n\nalpha rateParam A bkg (@0*@1/@2) beta,gamma,delta\nbeta  rateParam B bkg 50\ngamma rateParam C bkg 100\ndelta rateParam D bkg 500\n</code></pre> <p>For more examples of using <code>rateParam</code> (eg for fitting process normalizations in control regions and signal regions simultaneously) see this 2016 CMS tutorial</p> <p>Finally, any pre-existing RooAbsReal inside some ROOT file with a workspace can be imported using the following:</p> <pre><code>name rateParam bin process rootfile:workspacename\n</code></pre> <p>The name should correspond to the name of the object that is being picked up inside the RooWorkspace. A simple example using the SM XS and BR splines available in HiggsAnalysis/CombinedLimit can be found under data/tutorials/rate_params/simple_sm_datacard.txt</p>"},{"location":"part2/settinguptheanalysis/#extra-arguments","title":"Extra arguments","text":"<p>If a parameter is intended to be used, and it is not a user-defined <code>param</code> or <code>rateParam</code>, it can be picked up by first issuing an <code>extArgs</code> directive before this line in the datacard. The syntax for <code>extArgs</code> is:</p> <pre><code>name extArg rootfile:workspacename\n</code></pre> <p>The string \":RecycleConflictNodes\" can be added at the end of the final argument (i.e. rootfile:workspacename:RecycleConflictNodes) to apply the corresponding RooFit option when the object is imported into the workspace. It is also possible to simply add a RooRealVar using <code>extArg</code> for use in function <code>rateParams</code> with the following</p> <pre><code>name extArg init [min,max]\n</code></pre> <p>Note that the <code>[min,max]</code> argument is optional and if not included, the code will remove the range of this parameter.</p>"},{"location":"part2/settinguptheanalysis/#manipulation-of-nuisance-parameters","title":"Manipulation of Nuisance parameters","text":"<p>It can often be useful to modify datacards, or the runtime behavior, without having to modify individual systematic lines. This can be achieved through nuisance parameter modifiers.</p>"},{"location":"part2/settinguptheanalysis/#nuisance-modifiers","title":"Nuisance modifiers","text":"<p>If a nuisance parameter needs to be renamed for certain processes/channels, it can be done using a single <code>nuisance edit</code> directive at the end of a datacard</p> <pre><code>nuisance edit rename process channel oldname newname [options]\n</code></pre> <p>Note that the wildcard (*) can be used for either a process, a channel, or both.  This will have the effect that nuisance parameters affecting a given process/channel will be renamed, thereby de-correlating between processes/channels.  Use the option <code>ifexists</code> to skip/avoid an error if the nuisance paremeter is not found.  This kind of command will only affect nuisances of the type <code>shape[N]</code>, <code>lnN</code>. Instead, if you also want to change the names of <code>param</code> type nuisances, you can use a global version </p> <pre><code>nuisance edit rename oldname newname\n</code></pre> <p>which will rename all <code>shape[N]</code>, <code>lnN</code> and <code>param</code> nuisances found in one go. You should make sure these commands come after any process/channel specific ones in the datacard. This version does not accept options.  </p> <p>Other edits are also supported, as follows:</p> <ul> <li><code>nuisance edit add process channel name pdf value [options]</code>  -&gt; add a new nuisance parameter to a process</li> <li><code>nuisance edit drop process channel name [options]</code>  -&gt; remove this nuisance from the process/channel. Use the option <code>ifexists</code> to skip/avoid errors if the nuisance parameter is not found.</li> <li><code>nuisance edit changepdf name newpdf</code> -&gt; change the PDF type of a given nuisance parameter to <code>newpdf</code>.</li> <li><code>nuisance edit split process channel oldname newname1 newname2 value1 value2</code> -&gt; split a nuisance parameter line into two separate nuisance parameters called <code>newname1</code> and <code>newname2</code> with values <code>value1</code> and <code>value2</code>. This will produce two separate lines so that the original nuisance parameter <code>oldname</code> is split into two uncorrelated nuisances.</li> <li><code>nuisance edit freeze name [options]</code>  -&gt; set nuisance parameter frozen by default. Can be overridden on the command line using the <code>--floatNuisances</code> option. Use the option <code>ifexists</code> to skip/avoid errors if the nuisance parameter not found.</li> <li><code>nuisance edit merge process channel name1 name2</code> -&gt; merge systematic <code>name2</code> into <code>name1</code> by adding their values in quadrature and removing <code>name2</code>. This only works if, for each process and channel included, the uncertainties both increase or both reduce the process yield. For example, you can add 1.1 to 1.2, but not to 0.9.</li> </ul> <p>The above edits (excluding the renaming) support nuisance parameters of the types <code>shape[N]</code>, <code>lnN</code>, <code>lnU</code>, <code>gmN</code>, <code>param</code>, <code>flatParam</code>, <code>rateParam</code>, or <code>discrete</code>.</p>"},{"location":"part2/settinguptheanalysis/#groups-of-nuisances","title":"Groups of nuisances","text":"<p>Often it is desirable to freeze one or more nuisance parameters to check the impact they have on limits, likelihood scans, significances etc.</p> <p>However, for large groups of nuisance parameters (eg everything associated to theory) it is easier to define nuisance groups in the datacard. The following line in a datacard will, for example, produce a group of nuisance parameters with the group name <code>theory</code> that contains two parameters, <code>QCDscale</code> and <code>pdf</code>.</p> <pre><code>theory group = QCDscale pdf\n</code></pre> <p>Multiple groups can be defined in this way. It is also possible to extend nuisance parameters groups in datacards using += in place of =.</p> <p>These groups can be manipulated at runtime (eg for freezing all nuisance parameterss associated to a group at runtime, see Running the tool). You can find more info on groups of nuisances here</p> <p>Note that when using the automatic addition of statistical uncertainties (autoMCStats), the corresponding nuisance parameters are created by <code>text2workspace.py</code> and so do not exist in the datacards. It is therefore not possible to add autoMCStats parameters to groups of nuisances in the way described above. However, <code>text2workspace.py</code> will automatically create a group labelled <code>autoMCStats</code>, which contains all autoMCStats parameters.</p> <p>This group is useful for freezing all parameters created by autoMCStats. For freezing subsets of the parameters, for example if the datacard contains two categories, cat_label_1 and cat_label_2, to only freeze the autoMCStat parameters created for category cat_label_1, the regular expression features can be used. In this example this can be achieved by using <code>--freezeParameters 'rgx{prop_bincat_label_1_bin.*}'</code>.</p>"},{"location":"part2/settinguptheanalysis/#combination-of-multiple-datacards","title":"Combination of multiple datacards","text":"<p>If you have separate channels, each with their own datacard, it is possible to produce a combined datacard using the script <code>combineCards.py</code></p> <p>The syntax is simple: <code>combineCards.py Name1=card1.txt Name2=card2.txt .... &gt; card.txt</code> If the input datacards had just one bin each, the output channels will be called <code>Name1</code>, <code>Name2</code>, and so on. Otherwise, a prefix <code>Name1_</code> ... <code>Name2_</code> will be added to the bin labels in each datacard. The supplied bin names <code>Name1</code>, <code>Name2</code>, etc. must themselves conform to valid C++/python identifier syntax.</p> <p>Warning</p> <p>When combining datacards, you should keep in mind that systematic uncertainties that have different names will be assumed to be uncorrelated, and those with the same name will be assumed 100% correlated. An uncertainty correlated across channels must have the same PDF. in all cards (i.e. always <code>lnN</code>, or all <code>gmN</code> with same <code>N</code>. Note that <code>shape</code> and <code>lnN</code> can be interchanged via the <code>shape?</code> directive). Furthermore, when using parametric models, \"parameter\" objects such as <code>RooRealVar</code>, <code>RooAbsReal</code>, and <code>RooAbsCategory</code> (parameters, PDF indices etc) with the same name will be assumed to be the same object. If this is not intended, you may encounter unexpected behaviour, such as the order of combining cards having an impact on the results. Make sure that such objects are named differently in your inputs if they represent different things! Instead, Combine will try to rename other \"shape\" objects (such as PDFs) automatically. </p> <p>The <code>combineCards.py</code> script will fail if you are trying to combine a shape datacard with a counting datacard. You can however convert a counting datacard into an equivalent shape-based one by adding a line <code>shapes * * FAKE</code> in the datacard after the <code>imax</code>, <code>jmax</code>, and <code>kmax</code> section. Alternatively, you can add the option <code>-S</code> to <code>combineCards.py</code>, which will do this for you while creating the combined datacard.</p>"},{"location":"part2/settinguptheanalysis/#automatic-production-of-datacards-and-workspaces","title":"Automatic production of datacards and workspaces","text":"<p>For complicated analyses or cases in which multiple datacards are needed (e.g. optimization studies), you can avoid writing these by hand. The object Datacard defines the analysis and can be created as a python object. The template python script below will produce the same workspace as running <code>textToWorkspace.py</code> (see the section on Physics Models) on the realistic-counting-experiment.txt datacard.</p> <pre><code>from HiggsAnalysis.CombinedLimit.DatacardParser import *\nfrom HiggsAnalysis.CombinedLimit.ModelTools import *\nfrom HiggsAnalysis.CombinedLimit.ShapeTools import *\nfrom HiggsAnalysis.CombinedLimit.PhysicsModel import *\n\nfrom sys import exit\nfrom optparse import OptionParser\nparser = OptionParser()\naddDatacardParserOptions(parser)\noptions,args = parser.parse_args()\noptions.bin = True # make a binary workspace\n\nDC = Datacard()\nMB = None\n\n############## Setup the datacard (must be filled in) ###########################\n\nDC.bins =   ['bin1'] # &lt;type 'list'&gt;\nDC.obs =    {'bin1': 0.0} # &lt;type 'dict'&gt;\nDC.processes =  ['ggH', 'qqWW', 'ggWW', 'others'] # &lt;type 'list'&gt;\nDC.signals =    ['ggH'] # &lt;type 'list'&gt;\nDC.isSignal =   {'qqWW': False, 'ggWW': False, 'ggH': True, 'others': False} # &lt;type 'dict'&gt;\nDC.keyline =    [('bin1', 'ggH', True), ('bin1', 'qqWW', False), ('bin1', 'ggWW', False), ('bin1', 'others', False)] # &lt;type 'list'&gt;\nDC.exp =    {'bin1': {'qqWW': 0.63, 'ggWW': 0.06, 'ggH': 1.47, 'others': 0.22}} # &lt;type 'dict'&gt;\nDC.systs =  [('lumi', False, 'lnN', [], {'bin1': {'qqWW': 0.0, 'ggWW': 1.11, 'ggH': 1.11, 'others': 0.0}}), ('xs_ggH', False, 'lnN', [], {'bin1': {'qqWW': 0.0, 'ggWW': 0.0, 'ggH': 1.16, 'others': 0.0}}), ('WW_norm', False, 'gmN', [4], {'bin1': {'qqWW': 0.16, 'ggWW': 0.0, 'ggH': 0.0, 'others': 0.0}}), ('xs_ggWW', False, 'lnN', [], {'bin1': {'qqWW': 0.0, 'ggWW': 1.5, 'ggH': 0.0, 'others': 0.0}}), ('bg_others', False, 'lnN', [], {'bin1': {'qqWW': 0.0, 'ggWW': 0.0, 'ggH': 0.0, 'others': 1.3}})] # &lt;type 'list'&gt;\nDC.shapeMap =   {} # &lt;type 'dict'&gt;\nDC.hasShapes =  False # &lt;type 'bool'&gt;\nDC.flatParamNuisances =  {} # &lt;type 'dict'&gt;\nDC.rateParams =  {} # &lt;type 'dict'&gt;\nDC.extArgs =    {} # &lt;type 'dict'&gt;\nDC.rateParamsOrder  =  set([]) # &lt;type 'set'&gt;\nDC.frozenNuisances  =  set([]) # &lt;type 'set'&gt;\nDC.systematicsShapeMap =  {} # &lt;type 'dict'&gt;\nDC.nuisanceEditLines    =  [] # &lt;type 'list'&gt;\nDC.groups   =  {} # &lt;type 'dict'&gt;\nDC.discretes    =  [] # &lt;type 'list'&gt;\n\n\n###### User defined options #############################################\n\noptions.out      = \"combine_workspace.root\"     # Output workspace name\noptions.fileName = \"./\"             # Path to input ROOT files\noptions.verbose  = \"1\"              # Verbosity\n\n##########################################################################\n\nif DC.hasShapes:\n    MB = ShapeBuilder(DC, options)\nelse:\n    MB = CountingModelBuilder(DC, options)\n\n# Set physics models\nMB.setPhysics(defaultModel)\nMB.doModel()\n</code></pre> <p>Any existing datacard can be converted into such a template python script by using the <code>--dump-datacard</code> option in <code>text2workspace.py</code>, in case a more complicated template is needed.</p> <p>Warning</p> <p>The above is not advised for final results, as this script is not easily combined with other analyses so should only be used for internal studies.</p> <p>For the automatic generation of datacards that are combinable, you should instead use the CombineHarvester package, which includes many features for producing complex datacards in a reliable, automated way.</p>"},{"location":"part2/settinguptheanalysis/#sanity-checking-the-datacard","title":"Sanity checking the datacard","text":"<p>For large combinations with multiple channels/processes etc, the <code>.txt</code> file can get unwieldy to read through. There are some simple tools to help check and disseminate the contents of the cards. </p> <p>In order to get a quick view of the systematic uncertainties included in the datacard, you can use the <code>test/systematicsAnalyzer.py</code> tool. This will produce a list of the systematic uncertainties (normalization and shape), indicating what type they are, which channels/processes they affect and the size of the effect on the normalization (for shape uncertainties, this will just be the overall uncertainty on the normalization).</p> <p>The default output is a <code>.html</code> file that can be expanded to give more details about the effect of the systematic uncertainty for each channel/process. Add the option <code>--format brief</code> to obtain a simpler summary report direct to the terminal. An example output for the tutorial card <code>data/tutorials/shapes/simple-shapes-TH1.txt</code> is shown below.</p> <pre><code>$ python test/systematicsAnalyzer.py data/tutorials/shapes/simple-shapes-TH1.txt --all -f html &gt; out.html\n</code></pre> <p>This will produce the following output in html format: </p> Nuisance Report Nuisance Report Nuisance (types)RangeProcessesChannels lumi  (lnN) 1.0001.100  background, signal  bin1(1) [+] bin1signal(1.1), background(1.0) alpha  (shape) 1.1111.150  background  bin1(1) [+] bin1background(0.900/1.150 (shape)) bgnorm  (lnN) 1.0001.300  background, signal  bin1(1) [+] bin1signal(1.0), background(1.3) sigma  (shape) 1.0001.000  signal  bin1(1) [+] bin1signal(1.000/1.000 (shape)) <p>In case you only have a counting experiment datacard, include the option <code>--noshape</code>.</p> <p>If you have a datacard that uses several <code>rateParams</code> or a Physics model that includes a complicated product of normalization terms in each process, you can check the values of the normalization (and which objects in the workspace comprise them) using the <code>test/printWorkspaceNormalisations.py</code> tool. As an example, the first few blocks of output for the tutorial card <code>data/tutorials/counting/realistic-multi-channel.txt</code> are given below:</p> Show example output <pre><code>\n$ text2workspace.py data/tutorials/shapes/simple-shapes-parametric.txt -m 30\n$ python test/printWorkspaceNormalisations.py data/tutorials/counting/realistic-multi-channel.root                                                                                                           \n\n---------------------------------------------------------------------------\n---------------------------------------------------------------------------\nChannel - mu_tau\n---------------------------------------------------------------------------\n  Top-level normalisation for process ZTT -&gt; n_exp_binmu_tau_proc_ZTT\n  -------------------------------------------------------------------------\nDumping ProcessNormalization n_exp_binmu_tau_proc_ZTT @ 0x6bbb610\n    nominal value: 329\n    log-normals (3):\n         kappa = 1.23, logKappa = 0.207014, theta = tauid = 0\n         kappa = 1.04, logKappa = 0.0392207, theta = ZtoLL = 0\n         kappa = 1.04, logKappa = 0.0392207, theta = effic = 0\n    asymm log-normals (0):\n    other terms (0):\n\n  -------------------------------------------------------------------------\n  default value =  329.0\n---------------------------------------------------------------------------\n  Top-level normalisation for process QCD -&gt; n_exp_binmu_tau_proc_QCD\n  -------------------------------------------------------------------------\nDumping ProcessNormalization n_exp_binmu_tau_proc_QCD @ 0x6bbcaa0\n    nominal value: 259\n    log-normals (1):\n         kappa = 1.1, logKappa = 0.0953102, theta = QCDmu = 0\n    asymm log-normals (0):\n    other terms (0):\n\n  -------------------------------------------------------------------------\n  default value =  259.0\n---------------------------------------------------------------------------\n  Top-level normalisation for process higgs -&gt; n_exp_binmu_tau_proc_higgs\n  -------------------------------------------------------------------------\nDumping ProcessNormalization n_exp_binmu_tau_proc_higgs @ 0x6bc6390\n    nominal value: 0.57\n    log-normals (3):\n         kappa = 1.11, logKappa = 0.10436, theta = lumi = 0\n         kappa = 1.23, logKappa = 0.207014, theta = tauid = 0\n         kappa = 1.04, logKappa = 0.0392207, theta = effic = 0\n    asymm log-normals (0):\n    other terms (1):\n         term r (class RooRealVar), value = 1\n\n  -------------------------------------------------------------------------\n  default value =  0.57\n---------------------------------------------------------------------------\n---------------------------------------------------------------------------\nChannel - e_mu\n---------------------------------------------------------------------------\n  Top-level normalisation for process ZTT -&gt; n_exp_bine_mu_proc_ZTT\n  -------------------------------------------------------------------------\nDumping ProcessNormalization n_exp_bine_mu_proc_ZTT @ 0x6bc8910\n    nominal value: 88\n    log-normals (2):\n         kappa = 1.04, logKappa = 0.0392207, theta = ZtoLL = 0\n         kappa = 1.04, logKappa = 0.0392207, theta = effic = 0\n    asymm log-normals (0):\n    other terms (0):\n\n  -------------------------------------------------------------------------\n  default value =  88.0\n---------------------------------------------------------------------------\n</code></pre> <p>As you can see, for each channel, a report is given for the top-level rate object in the workspace, for each process contributing to that channel. You can also see the various terms that make up that rate. The default value is for the default parameters in the workspace (i.e when running <code>text2workspace</code>, these are the values created as default).</p> <p>Another example is shown below for the workspace produced from the data/tutorials/shapes/simple-shapes-parametric.txt datacard.</p> Show example output <pre><code>\n  text2workspace.py data/tutorials/shapes/simple-shapes-parametric.txt\n  python test/printWorkspaceNormalisations.py data/tutorials/shapes/simple-shapes-parametric.root\n  ...\n\n  ---------------------------------------------------------------------------\n  ---------------------------------------------------------------------------\n  Channel - bin1\n  ---------------------------------------------------------------------------\n    Top-level normalisation for process bkg -&gt; n_exp_final_binbin1_proc_bkg\n    -------------------------------------------------------------------------\n  RooProduct::n_exp_final_binbin1_proc_bkg[ n_exp_binbin1_proc_bkg * shapeBkg_bkg_bin1__norm ] = 521.163\n   ... is a product, which contains  n_exp_binbin1_proc_bkg\n  RooRealVar::n_exp_binbin1_proc_bkg = 1 C  L(-INF - +INF)\n    -------------------------------------------------------------------------\n    default value =  521.163204829\n  ---------------------------------------------------------------------------\n    Top-level normalisation for process sig -&gt; n_exp_binbin1_proc_sig\n    -------------------------------------------------------------------------\n  Dumping ProcessNormalization n_exp_binbin1_proc_sig @ 0x464f700\n      nominal value: 1\n      log-normals (1):\n           kappa = 1.1, logKappa = 0.0953102, theta = lumi = 0\n      asymm log-normals (0):\n      other terms (1):\n           term r (class RooRealVar), value = 1\n\n    -------------------------------------------------------------------------\n    default value =  1.0\n</code></pre> <p>This tells us that the normalization for the background process, named <code>n_exp_final_binbin1_proc_bkg</code> is a product of two objects <code>n_exp_binbin1_proc_bkg * shapeBkg_bkg_bin1__norm</code>. The first object is just from the rate line in the datacard (equal to 1) and the second is a floating parameter. For the signal, the normalisation is called <code>n_exp_binbin1_proc_sig</code> and is a <code>ProcessNormalization</code> object that contains the rate modifications due to the systematic uncertainties. You can see that it also has a \"nominal value\", which again is just from the value given in the rate line of the datacard (again=1).</p>"},{"location":"part3/commonstatsmethods/","title":"Common Statistical Methods","text":"<p>In this section, the most commonly used statistical methods from Combine will be covered, including specific instructions on how to obtain limits, significances, and likelihood scans. For all of these methods, the assumed parameter of interest (POI) is the overall signal strength r (i.e the default PhysicsModel). In general however, the first POI in the list of POIs (as defined by the PhysicsModel) will be taken instead of r. This may or may not make sense for any particular method, so care must be taken. </p> <p>This section will assume that you are using the default physics model, unless otherwise specified.</p>"},{"location":"part3/commonstatsmethods/#asymptotic-frequentist-limits","title":"Asymptotic Frequentist Limits","text":"<p>The <code>AsymptoticLimits</code> method can be used to quickly compute an estimate of the observed and expected limits, which is accurate when the event yields are not too small and the systematic uncertainties do not play a major role in the result. The limit calculation relies on an asymptotic approximation of the distributions of the LHC test statistic, which is based on a profile likelihood ratio, under the signal and background hypotheses to compute two p-values p_{\\mu}, p_{b} and therefore CL_s=p_{\\mu}/(1-p_{b}) (see the FAQ section for a description). This means it is the asymptotic approximation for evaluating limits with frequentist toys using the LHC test statistic for limits. In the definition below, the parameter \\mu=r. </p> <ul> <li>The test statistic is defined using the ratio of likelihoods q_{\\mu} = -2\\ln[\\mathcal{L}(\\mu,\\hat{\\hat{\\nu}}(\\mu))/\\mathcal{L}(\\hat{\\mu},\\hat{\\nu})] , in which the nuisance parameters are profiled separately for \\mu=\\hat{\\mu} and \\mu. The value of q_{\\mu} is set to 0 when \\hat{\\mu}&gt;\\mu, giving a one-sided limit. Furthermore, the constraint \\mu&gt;0 is enforced in the fit. This means that if the unconstrained value of \\hat{\\mu} would be negative, the test statistic q_{\\mu} is evaluated as -2\\ln[\\mathcal{L}(\\mu,\\hat{\\hat{\\nu}}(\\mu))/\\mathcal{L}(0,\\hat{\\hat{\\nu}}(0))]</li> </ul> <p>This method is the default Combine method: if you call Combine without specifying <code>-M</code>, the <code>AsymptoticLimits</code> method will be run.</p> <p>A realistic example of a datacard for a counting experiment can be found in the HiggsCombination package: data/tutorials/counting/realistic-counting-experiment.txt</p> <p>The <code>AsymptoticLimits</code> method can be run using</p> <pre><code>combine -M AsymptoticLimits realistic-counting-experiment.txt\n</code></pre> <p>The program will print the limit on the signal strength r (number of signal events / number of expected signal events) e .g. <code>Observed Limit: r &lt; 1.6297 @ 95% CL</code> , the median expected limit <code>Expected 50.0%: r &lt; 2.3111</code>, and edges of the 68% and 95% ranges for the expected limits.</p> <pre><code> &lt;&lt;&lt; Combine &gt;&gt;&gt;\n&gt;&gt;&gt; including systematics\n&gt;&gt;&gt; method used to compute upper limit is AsymptoticLimits\n[...]\n -- AsymptoticLimits ( CLs ) --\nObserved Limit: r &lt; 1.6281\nExpected  2.5%: r &lt; 0.9640\nExpected 16.0%: r &lt; 1.4329\nExpected 50.0%: r &lt; 2.3281\nExpected 84.0%: r &lt; 3.9800\nExpected 97.5%: r &lt; 6.6194\n\nDone in 0.01 min (cpu), 0.01 min (real)\n</code></pre> <p>By default, the limits are calculated using the CL<sub>s</sub> prescription, as noted in the output, which takes the ratio of p-values under the signal plus background and background only hypothesis. This can be altered to using the strict p-value by using the option <code>--rule CLsplusb</code> (note that <code>CLsplusb</code> is the jargon for calculating the p-value p_{\\mu}). You can also change the confidence level (default is 95%) to 90% using the option <code>--cl 0.9</code> or any other confidence level. You can find the full list of options for <code>AsymptoticLimits</code> using <code>--help -M AsymptoticLimits</code>.</p> <p>Warning</p> <p>You may find that Combine issues a warning that the best fit for the background-only Asimov dataset returns a nonzero value for the signal strength;</p> <p><code>WARNING: Best fit of asimov dataset is at r = 0.220944 (0.011047 times</code> <code>rMax), while it should be at zero</code></p> <p>If this happens, you should check to make sure that there are no issues with the datacard or the Asimov generation used for your setup. For details on debugging, it is recommended that you follow the simple checks used by the HIG PAG here.</p> <p>The program will also create a ROOT file <code>higgsCombineTest.AsymptoticLimits.mH120.root</code> containing a ROOT tree <code>limit</code> that contains the limit values and other bookkeeping information. The important columns are <code>limit</code> (the limit value) and <code>quantileExpected</code> (-1 for observed limit, 0.5 for median expected limit, 0.16/0.84 for the edges of the 65% interval band of expected limits, 0.025/0.975 for 95%).</p> <pre><code>$ root -l higgsCombineTest.AsymptoticLimits.mH120.root\nroot [0] limit-&gt;Scan(\"*\")\n************************************************************************************************************************************\n*    Row   *     limit *  limitErr *        mh *      syst *      iToy *     iSeed *  iChannel *     t_cpu *    t_real * quantileE *\n************************************************************************************************************************************\n*        0 * 0.9639892 *         0 *       120 *         1 *         0 *    123456 *         0 *         0 *         0 * 0.0250000 *\n*        1 * 1.4329109 *         0 *       120 *         1 *         0 *    123456 *         0 *         0 *         0 * 0.1599999 *\n*        2 *  2.328125 *         0 *       120 *         1 *         0 *    123456 *         0 *         0 *         0 *       0.5 *\n*        3 * 3.9799661 *         0 *       120 *         1 *         0 *    123456 *         0 *         0 *         0 * 0.8399999 *\n*        4 * 6.6194028 *         0 *       120 *         1 *         0 *    123456 *         0 *         0 *         0 * 0.9750000 *\n*        5 * 1.6281188 * 0.0050568 *       120 *         1 *         0 *    123456 *         0 * 0.0035000 * 0.0055123 *        -1 *\n************************************************************************************************************************************\n</code></pre>"},{"location":"part3/commonstatsmethods/#blind-limits","title":"Blind limits","text":"<p>The <code>AsymptoticLimits</code> calculation follows the frequentist paradigm for calculating expected limits. This means that the routine will first fit the observed data, conditionally for a fixed value of r, and set the nuisance parameters to the values obtained in the fit for generating the Asimov data set. This means it calculates the post-fit or a-posteriori expected limit. In order to use the pre-fit nuisance parameters (to calculate an a-priori limit), you must add the option <code>--noFitAsimov</code> or <code>--bypassFrequentistFit</code>.</p> <p>For blinding the results completely (i.e not using the data) you can include the option <code>--run blind</code>.</p> <p>Warning</p> <p>While you can use <code>-t -1</code> to get blind limits, if the correct options are passed, we strongly recommend to use <code>--run blind</code>.</p>"},{"location":"part3/commonstatsmethods/#splitting-points","title":"Splitting points","text":"<p>In case your model is particularly complex, you can perform the asymptotic calculation by determining the value of CL<sub>s</sub> for a set grid of points (in <code>r</code>) and merging the results. This is done by using the option <code>--singlePoint X</code> for multiple values of X, hadd'ing the output files and reading them back in,</p> <pre><code>combine -M AsymptoticLimits realistic-counting-experiment.txt --singlePoint 0.1 -n 0.1\ncombine -M AsymptoticLimits realistic-counting-experiment.txt --singlePoint 0.2 -n 0.2\ncombine -M AsymptoticLimits realistic-counting-experiment.txt --singlePoint 0.3 -n 0.3\n...\n\nhadd limits.root higgsCombine*.AsymptoticLimits.*\n\ncombine -M AsymptoticLimits realistic-counting-experiment.txt --getLimitFromGrid limits.root\n</code></pre>"},{"location":"part3/commonstatsmethods/#asymptotic-significances","title":"Asymptotic Significances","text":"<p>The significance of a result is calculated using a ratio of profiled likelihoods, one in which the signal strength is set to 0 and the other in which it is free to float. The evaluated quantity is -2\\ln[\\mathcal{L}(\\mu=0,\\hat{\\hat{\\nu}}(0))/\\mathcal{L}(\\hat{\\mu},\\hat{\\nu})], in which the nuisance parameters are profiled separately for \\mu=\\hat{\\mu} and \\mu=0.</p> <p>The distribution of this test statistic can be determined using Wilks' theorem provided the number of events is large enough (i.e in the Asymptotic limit). The significance (or p-value) can therefore be calculated very quickly. The <code>Significance</code> method can be used for this.</p> <p>It is also possible to calculate the ratio of likelihoods between the freely floating signal strength to that of a fixed signal strength other than 0, by specifying it with the option <code>--signalForSignificance=X</code>.</p> <p>Info</p> <p>This calculation assumes that the signal strength can only be positive (i.e we are not interested in negative signal strengths). This behaviour can be altered by including the option <code>--uncapped</code>.</p>"},{"location":"part3/commonstatsmethods/#compute-the-observed-significance","title":"Compute the observed significance","text":"<p>The observed significance is calculated using the <code>Significance</code> method, as</p> <p><code>combine -M Significance datacard.txt</code></p> <p>The printed output will report the significance and the p-value, for example, when using the realistic-counting-experiment.txt datacard, you will see</p> <pre><code> &lt;&lt;&lt; Combine &gt;&gt;&gt;\n&gt;&gt;&gt; including systematics\n&gt;&gt;&gt; method used is Significance\n[...]\n -- Significance --\nSignificance: 0\n       (p-value = 0.5)\nDone in 0.00 min (cpu), 0.01 min (real)\n</code></pre> <p>which is not surprising since 0 events were observed in that datacard.</p> <p>The output ROOT file will contain the significance value in the branch limit. To store the p-value instead, include the option <code>--pval</code>. The significance and p-value can be converted between one another using the RooFit functions <code>RooFit::PValueToSignificance</code> and <code>RooFit::SignificanceToPValue</code>.</p> <p>When calculating the significance, you may find it useful to resort to a brute-force fitting algorithm that scans the nll (repeating fits until a certain tolerance is reached), bypassing MINOS, which can be activated with the option <code>bruteForce</code>. This can be tuned using the options <code>setBruteForceAlgo</code>, <code>setBruteForceTypeAndAlgo</code> and <code>setBruteForceTolerance</code>.</p>"},{"location":"part3/commonstatsmethods/#computing-the-expected-significance","title":"Computing the expected significance","text":"<p>The expected significance can be computed from an Asimov data set of signal+background. There are two options for this:</p> <ul> <li>a-posteriori expected: will depend on the observed dataset.</li> <li>a-priori expected (the default behavior): does not depend on the observed dataset, and so is a good metric for optimizing an analysis when still blinded.</li> </ul> <p>The a-priori expected significance from the Asimov dataset is calculated as</p> <pre><code>combine -M Significance datacard.txt -t -1 --expectSignal=1\n</code></pre> <p>In order to produce the a-posteriori expected significance, just generate a post-fit Asimov data set by adding the option <code>--toysFreq</code> in the command above.</p> <p>The output format is the same as for observed significances: the variable limit in the tree will be filled with the significance (or with the p-value if you put also the option <code>--pvalue</code>)</p>"},{"location":"part3/commonstatsmethods/#bayesian-limits-and-credible-regions","title":"Bayesian Limits and Credible regions","text":"<p>Bayesian calculation of limits requires the user to assume a particular prior distribution for the parameter of interest (default r). You can specify the prior using the <code>--prior</code> option, the default is a flat pior in r.</p>"},{"location":"part3/commonstatsmethods/#computing-the-observed-bayesian-limit-for-simple-models","title":"Computing the observed bayesian limit (for simple models)","text":"<p>The <code>BayesianSimple</code> method computes a Bayesian limit performing classical numerical integration. This is very fast and accurate, but only works for simple models (a few channels and nuisance parameters).</p> <pre><code>combine -M BayesianSimple simple-counting-experiment.txt\n[...]\n\n -- BayesianSimple --\nLimit: r &lt; 0.672292 @ 95% CL\nDone in 0.04 min (cpu), 0.05 min (real)\n</code></pre> <p>The output tree will contain a single entry corresponding to the observed 95% confidence level upper limit. The confidence level can be modified to 100*X% using <code>--cl X</code>.</p>"},{"location":"part3/commonstatsmethods/#computing-the-observed-bayesian-limit-for-arbitrary-models","title":"Computing the observed bayesian limit (for arbitrary models)","text":"<p>The <code>MarkovChainMC</code> method computes a Bayesian limit performing a Monte Carlo integration. From the statistical point of view it is identical to the <code>BayesianSimple</code> method, only the technical implementation is different. The method is slower, but can also handle complex models. For this method you can increase the accuracy of the result by increasing the number of Markov Chains, at the expense of a longer running time (option <code>--tries</code>, default is 10). Let's use the realistic counting experiment datacard to test the method.</p> <p>To use the MarkovChainMC method, users need to specify this method in the command line, together with the options they want to use. For instance, to set the number of times the algorithm will run with different random seeds, use option <code>--tries</code>:</p> <pre><code>combine -M MarkovChainMC realistic-counting-experiment.txt --tries 100 \n[...]\n\n -- MarkovChainMC --\nLimit: r &lt; 2.20438 +/- 0.0144695 @ 95% CL (100 tries)\nAverage chain acceptance: 0.078118\nDone in 0.14 min (cpu), 0.15 min (real)\n</code></pre> <p>Again, the resulting limit tree will contain the result. You can also save the chains using the option <code>--saveChain</code>, which will then also be included in the output file.</p> <p>Exclusion regions can be made from the posterior once an ordering principle is defined to decide how to grow the contour (there is an infinite number of possible regions that contain 68% of the posterior pdf). Below is a simple example script that can be used to plot the posterior distribution from these chains and calculate the smallest such region. Note that in this example we are ignoring the burn-in. This can be added by e.g. changing <code>for i in range(mychain.numEntries()):</code> to <code>for i in range(200,mychain.numEntries()):</code> for a burn-in of 200. </p> Show example script <pre><code>\nimport ROOT\n\nrmin = 0\nrmax = 30\nnbins = 100\nCL = 0.95\nchains = \"higgsCombineTest.MarkovChainMC.blahblahblah.root\"\n\ndef findSmallestInterval(hist,CL):\n bins = hist.GetNbinsX()\n best_i = 1\n best_j = 1\n bd = bins+1\n val = 0;\n for i in range(1,bins+1):\n   integral = hist.GetBinContent(i)\n   for j in range(i+1,bins+2):\n    integral += hist.GetBinContent(j)\n    if integral &gt; CL :\n      val = integral\n      break\n   if integral &gt; CL and  j-i &lt; bd :\n     bd = j-i\n     best_j = j+1\n     best_i = i\n     val = integral\n return hist.GetBinLowEdge(best_i), hist.GetBinLowEdge(best_j), val\n\nfi_MCMC = ROOT.TFile.Open(chains)\n# Sum up all of the chains (or we could take the average limit)\nmychain=0\nfor k in fi_MCMC.Get(\"toys\").GetListOfKeys():\n    obj = k.ReadObj\n    if mychain ==0:\n        mychain = k.ReadObj().GetAsDataSet()\n    else :\n        mychain.append(k.ReadObj().GetAsDataSet())\nhist = ROOT.TH1F(\"h_post\",\";r;posterior probability\",nbins,rmin,rmax)\nfor i in range(mychain.numEntries()):\n#for i in range(200,mychain.numEntries()): burn-in of 200 \n  mychain.get(i)\n  hist.Fill(mychain.get(i).getRealValue(\"r\"), mychain.weight())\nhist.Scale(1./hist.Integral())\nhist.SetLineColor(1)\nvl,vu,trueCL = findSmallestInterval(hist,CL)\nhistCL = hist.Clone()\nfor b in range(nbins):\n  if histCL.GetBinLowEdge(b+1) &lt; vl or histCL.GetBinLowEdge(b+2)&gt;vu: histCL.SetBinContent(b+1,0)\nc6a = ROOT.TCanvas()\nhistCL.SetFillColor(ROOT.kAzure-3)\nhistCL.SetFillStyle(1001)\nhist.Draw()\nhistCL.Draw(\"histFsame\")\nhist.Draw(\"histsame\")\nll = ROOT.TLine(vl,0,vl,2*hist.GetBinContent(hist.FindBin(vl))); ll.SetLineColor(2); ll.SetLineWidth(2)\nlu = ROOT.TLine(vu,0,vu,2*hist.GetBinContent(hist.FindBin(vu))); lu.SetLineColor(2); lu.SetLineWidth(2)\nll.Draw()\nlu.Draw()\n\nprint \" %g %% (%g %%) interval (target)  = %g &lt; r &lt; %g \"%(trueCL,CL,vl,vu)\n</code></pre> <p>Running the script on the output file produced for the same datacard (including the <code>--saveChain</code> option) will produce the following output</p> <pre><code>0.950975 % (0.95 %) interval (target)  = 0 &lt; r &lt; 2.2\n</code></pre> <p>along with a plot of the posterior distribution shown below. This is the same as the output from Combine, but the script can also be used to find lower limits (for example) or credible intervals.</p> <p></p> <p>An example to make contours when ordering by probability density can be found in bayesContours.cxx. Note that the implementation is simplistic, with no clever handling of bin sizes nor smoothing of statistical fluctuations.</p> <p>The <code>MarkovChainMC</code> algorithm has many configurable parameters, and you are encouraged to experiment with those. The default configuration might not be the best for your analysis.</p>"},{"location":"part3/commonstatsmethods/#iterations-burn-in-tries","title":"Iterations, burn-in, tries","text":"<p>Three parameters control how the MCMC integration is performed:</p> <ul> <li>the number of tries (option <code>--tries</code>): the algorithm will run multiple times with different random seeds. The truncated mean and RMS of the different results are reported. The default value is 10, which should be sufficient for a quick computation. For a more accurate result you might want to increase this number up to even ~200.</li> <li>the number of iterations (option <code>-i</code>) determines how many points are proposed to fill a single Markov Chain. The default value is 10k, and a plausible range is between 5k (for quick checks) and 20-30k for lengthy calculations. Beyond 30k, the time vs accuracy can be balanced better by increasing the number of chains (option <code>--tries</code>).</li> <li>the number of burn-in steps (option <code>-b</code>) is the number of points that are removed from the beginning of the chain before using it to compute the limit. The default is 200. If the chain is very long, we recommend to increase this value a bit (e.g. to several hundreds). Using a number of burn-in steps below 50 is likely to result in a bias towards earlier stages of the chain before a reasonable convergence.</li> </ul>"},{"location":"part3/commonstatsmethods/#proposals","title":"Proposals","text":"<p>The option <code>--proposal</code> controls the way new points are proposed to fill in the MC chain.</p> <ul> <li>uniform: pick points at random. This works well if you have very few nuisance parameters (or none at all), but normally fails if you have many.</li> <li>gaus: Use a product of independent gaussians, one for each nuisance parameter. The sigma of the gaussian for each variable is 1/5 of the range of the variable. This behaviour can be controlled using the parameter <code>--propHelperWidthRangeDivisor</code>. This proposal appears to work well for up to around 15 nuisance parameters, provided that the range of the nuisance parameters is in the range \u00b15\u03c3. This method does not work when there are no nuisance parameters.</li> <li>ortho (default): This proposal is similar to the multi-gaussian proposal. However, at every step only a single coordinate of the point is varied, so that the acceptance of the chain is high even for a large number of nuisance parameters (i.e. more than 20).</li> <li>fit: Run a fit and use the uncertainty matrix from HESSE to construct a proposal (or the one from MINOS if the option <code>--runMinos</code> is specified). This can give biased results, so this method is not recommended in general.</li> </ul> <p>If you believe there is something going wrong, e.g. if your chain remains stuck after accepting only a few events, the option <code>--debugProposal</code> can be used to obtain a printout of the first N proposed points. This can help you understand what is happening; for example if you have a region of the phase space with probability zero, the gaus and fit proposal can get stuck there forever.</p>"},{"location":"part3/commonstatsmethods/#computing-the-expected-bayesian-limit","title":"Computing the expected bayesian limit","text":"<p>The expected limit is computed by generating many toy MC data sets and computing the limit for each of them. This can be done passing the option <code>-t</code> . E.g. to run 100 toys with the <code>BayesianSimple</code> method, you can run</p> <pre><code>combine -M BayesianSimple datacard.txt -t 100\n</code></pre> <p>The program will print out the mean and median limit, as well as the 68% and 95% quantiles of the distributions of the limits. This time, the output ROOT tree will contain one entry per toy.</p> <p>For more heavy methods (eg the <code>MarkovChainMC</code>) you will probably want to split this calculation into multiple jobs. To do this, just run Combine multiple times specifying a smaller number of toys (as low as <code>1</code>), using a different seed to initialize the random number generator each time. The option <code>-s</code> can be used for this; if you set it to -1, the starting seed will be initialized randomly at the beginning of the job. Finally, you can merge the resulting trees with <code>hadd</code> and look at the distribution in the merged file.</p>"},{"location":"part3/commonstatsmethods/#multidimensional-bayesian-credible-regions","title":"Multidimensional bayesian credible regions","text":"<p>The <code>MarkovChainMC</code> method allows the user to produce the posterior PDF as a function of (in principle) any number of POIs. In order to do so, you first need to create a workspace with more than one parameter, as explained in the physics models section.</p> <p>For example, let us use the toy datacard data/tutorials/multiDim/toy-hgg-125.txt (counting experiment that vaguely resembles an early H\u2192\u03b3\u03b3 analysis at 125 GeV) and convert the datacard into a workspace with 2 parameters, the ggH and qqH cross sections, using <code>text2workspace</code>.</p> <pre><code>text2workspace.py data/tutorials/multiDim/toy-hgg-125.txt -P HiggsAnalysis.CombinedLimit.PhysicsModel:floatingXSHiggs --PO modes=ggH,qqH -o workspace.root\n</code></pre> <p>Now we just run one (or more) MCMC chain(s) and save them in the output tree. By default, the nuisance parameters will be marginalized (integrated) over their PDFs. You can ignore the complaints about not being able to compute an upper limit (since for more than 1D, this is not well-defined),</p> <pre><code>combine -M MarkovChainMC workspace.root --tries 1 --saveChain -i 1000000 -m 125 -s 12345\n</code></pre> <p>The output of the Markov Chain is again a RooDataSet of weighted events distributed according to the posterior PDF (after you cut out the burn in part), so it can be used to make histograms or other distributions of the posterior PDF. See as an example bayesPosterior2D.cxx.</p> <p>Below is an example of the output of the macro,</p> <pre><code>$ root -l higgsCombineTest.MarkovChainMC....\n.L bayesPosterior2D.cxx\nbayesPosterior2D(\"bayes2D\",\"Posterior PDF\")\n</code></pre> <p></p>"},{"location":"part3/commonstatsmethods/#computing-limits-with-toys","title":"Computing Limits with toys","text":"<p>The <code>HybridNew</code> method is used to compute either the hybrid bayesian-frequentist limits, popularly known as \"CL<sub>s</sub> of LEP or Tevatron type\", or the fully frequentist limits, which are the current recommended method by the LHC Higgs Combination Group. Note that these methods can be resource intensive for complex models.</p> <p>It is possible to define the criterion used for setting limits using <code>--rule CLs</code> (to use the CL<sub>s</sub> criterion) or <code>--rule CLsplusb</code> (to calculate the limit using p_{\\mu}) and as always the confidence level desired using <code>--cl=X</code>.</p> <p>The choice of test statistic can be made via the option <code>--testStat</code>. Different methodologies for the treatment of the nuisance parameters are available. While it is possible to mix different test statistics with different nuisance parameter treatments, we strongly do not recommend  this. Instead one should follow one of the following three procedures. Note that the signal strength r here is given the more common notation \\mu. </p> <ul> <li> <p>LEP-style: <code>--testStat LEP --generateNuisances=1 --fitNuisances=0</code></p> <ul> <li>The test statistic is defined using the ratio of likelihoods q_{\\mathrm{LEP}}=-2\\ln[\\mathcal{L}(\\mu=0)/\\mathcal{L}(\\mu)].</li> <li>The nuisance parameters are fixed to their nominal values for the purpose of evaluating the likelihood, while for generating toys, the nuisance parameters are first randomized within their PDFs before generation of the toy.</li> </ul> </li> <li> <p>TEV-style: <code>--testStat TEV --generateNuisances=0 --generateExternalMeasurements=1 --fitNuisances=1</code></p> <ul> <li>The test statistic is defined using the ratio of likelihoods q_{\\mathrm{TEV}}=-2\\ln[\\mathcal{L}(\\mu=0,\\hat{\\hat{\\mu}}(0))/\\mathcal{L}(\\mu,\\hat{\\hat{\\nu}}(\\mu))], in which the nuisance parameters are profiled separately for \\mu=0 and \\mu.</li> <li>For the purposes of toy generation, the nuisance parameters are fixed to their post-fit values from the data (conditional on \\mu), while the constraint terms are randomized for the evaluation of the likelihood.</li> </ul> </li> <li> <p>LHC-style: <code>--LHCmode LHC-limits</code> , which is the shortcut for <code>--testStat LHC --generateNuisances=0 --generateExternalMeasurements=1 --fitNuisances=1</code></p> <ul> <li>The test statistic is defined using the ratio of likelihoods q_{\\mu} = -2\\ln[\\mathcal{L}(\\mu,\\hat{\\hat{\\nu}}(\\mu))/\\mathcal{L}(\\hat{\\mu},\\hat{\\nu})] , in which the nuisance parameters are profiled separately for mu=\\hat{\\mu} and \\mu.</li> <li>The value of q_{\\mu} set to 0 when \\hat{\\mu}&gt;\\mu giving a one-sided limit. Furthermore, the constraint \\mu&gt;0 is enforced in the fit. This means that if the unconstrained value of \\hat{\\mu} would be negative, the test statistic q_{\\mu} is evaluated as -2\\ln[\\mathcal{L}(\\mu,\\hat{\\hat{\\nu}}(\\mu))/\\mathcal{L}(0,\\hat{\\hat{\\nu}}(0))].</li> <li>For the purposes of toy generation, the nuisance parameters are fixed to their post-fit values from the data (conditionally on the value of \\mu), while the constraint terms are randomized in the evaluation of the likelihood.</li> </ul> </li> </ul> <p>Warning</p> <p>The recommended style is the LHC-style. Please note that this method is sensitive to the observation in data since the post-fit (after a fit to the data) values of the nuisance parameters (assuming different values of r) are used when generating the toys. For completely blind limits you can first generate a pre-fit asimov toy data set (described in the toy data generation section) and use that in place of the data.  You can use this toy by passing the argument <code>-D toysFileName.root:toys/toy_asimov</code></p> <p>While the above shortcuts are the commonly used versions, variations can be tested. The treatment of the nuisances can be changed to the so-called \"Hybrid-Bayesian\" method, which effectively integrates over the nuisance parameters. This is especially relevant when you have very few expected events in your data, and you are using those events to constrain background processes. This can be achieved by setting <code>--generateNuisances=1 --generateExternalMeasurements=0</code>. In case you want to avoid first fitting to the data to choose the nominal values you can additionally pass <code>--fitNuisances=0</code>. </p> <p>Warning</p> <p>If you have unconstrained parameters in your model (<code>rateParam</code>, or if you are using a <code>_norm</code> variable for a PDF) and you want to use the \"Hybrid-Bayesian\" method, you must declare these as <code>flatParam</code> in your datacard. When running text2workspace you must add the option <code>--X-assign-flatParam-prior</code> in the command line. This will create uniform priors for these parameters. These are needed for this method and they would otherwise not get created.   </p> <p>Info</p> <p>Note that (observed and expected) values of the test statistic stored in the instances of <code>RooStats::HypoTestResult</code> when the option <code>--saveHybridResult</code> is passed are defined without the factor 2. They are therefore twice as small as the values given by the formulas above. This factor is however included automatically by all plotting scripts supplied within the Combine package. If you use your own plotting scripts, you need to make sure to incorporate the factor 2. </p>"},{"location":"part3/commonstatsmethods/#simple-models","title":"Simple models","text":"<p>For relatively simple models, the observed and expected limits can be calculated interactively. Since the LHC-style is the recommended set of options for calculating limits using toys, we will use that in this section. However, the same procedure can be followed with the other sets of options.</p> <pre><code>combine realistic-counting-experiment.txt -M HybridNew --LHCmode LHC-limits\n</code></pre> Show output <pre><code> &lt;&lt;&lt; Combine &gt;&gt;&gt;\n&gt;&gt;&gt; including systematics\n&gt;&gt;&gt; using the Profile Likelihood test statistics modified for upper limits (Q_LHC)\n&gt;&gt;&gt; method used is HybridNew\n&gt;&gt;&gt; random number generator seed is 123456\nComputing results starting from observation (a-posteriori)\nSearch for upper limit to the limit\n  r = 20 +/- 0\n    CLs = 0 +/- 0\n    CLs      = 0 +/- 0\n    CLb      = 0.264 +/- 0.0394263\n    CLsplusb = 0 +/- 0\n\nSearch for lower limit to the limit\nNow doing proper bracketing &amp; bisection\n  r = 10 +/- 10\n    CLs = 0 +/- 0\n    CLs      = 0 +/- 0\n    CLb      = 0.288 +/- 0.0405024\n    CLsplusb = 0 +/- 0\n\n  r = 5 +/- 5\n    CLs = 0 +/- 0\n    CLs      = 0 +/- 0\n    CLb      = 0.152 +/- 0.0321118\n    CLsplusb = 0 +/- 0\n\n  r = 2.5 +/- 2.5\n    CLs = 0.0192308 +/- 0.0139799\n    CLs = 0.02008 +/- 0.0103371\n    CLs = 0.0271712 +/- 0.00999051\n    CLs = 0.0239524 +/- 0.00783634\n    CLs      = 0.0239524 +/- 0.00783634\n    CLb      = 0.208748 +/- 0.0181211\n    CLsplusb = 0.005 +/- 0.00157718\n\n  r = 2.00696 +/- 1.25\n    CLs = 0.0740741 +/- 0.0288829\n    CLs = 0.0730182 +/- 0.0200897\n    CLs = 0.0694474 +/- 0.0166468\n    CLs = 0.0640182 +/- 0.0131693\n    CLs = 0.0595 +/- 0.010864\n    CLs = 0.0650862 +/- 0.0105575\n    CLs = 0.0629286 +/- 0.00966301\n    CLs = 0.0634945 +/- 0.00914091\n    CLs = 0.060914 +/- 0.00852667\n    CLs = 0.06295 +/- 0.00830083\n    CLs = 0.0612758 +/- 0.00778181\n    CLs = 0.0608142 +/- 0.00747001\n    CLs = 0.0587169 +/- 0.00697039\n    CLs = 0.0591432 +/- 0.00678587\n    CLs = 0.0599683 +/- 0.00666966\n    CLs = 0.0574868 +/- 0.00630809\n    CLs = 0.0571451 +/- 0.00608177\n    CLs = 0.0553836 +/- 0.00585531\n    CLs = 0.0531612 +/- 0.0055234\n    CLs = 0.0516837 +/- 0.0052607\n    CLs = 0.0496776 +/- 0.00499783\n    CLs      = 0.0496776 +/- 0.00499783\n    CLb      = 0.216635 +/- 0.00801002\n    CLsplusb = 0.0107619 +/- 0.00100693\n\nTrying to move the interval edges closer\n  r = 1.00348 +/- 0\n    CLs = 0.191176 +/- 0.0459911\n    CLs      = 0.191176 +/- 0.0459911\n    CLb      = 0.272 +/- 0.0398011\n    CLsplusb = 0.052 +/- 0.00992935\n\n  r = 1.50522 +/- 0\n    CLs = 0.125 +/- 0.0444346\n    CLs = 0.09538 +/- 0.0248075\n    CLs = 0.107714 +/- 0.0226712\n    CLs = 0.103711 +/- 0.018789\n    CLs = 0.0845069 +/- 0.0142341\n    CLs = 0.0828468 +/- 0.0126789\n    CLs = 0.0879647 +/- 0.0122332\n    CLs      = 0.0879647 +/- 0.0122332\n    CLb      = 0.211124 +/- 0.0137494\n    CLsplusb = 0.0185714 +/- 0.00228201\n\n  r = 1.75609 +/- 0\n    CLs = 0.0703125 +/- 0.0255807\n    CLs = 0.0595593 +/- 0.0171995\n    CLs = 0.0555271 +/- 0.0137075\n    CLs = 0.0548727 +/- 0.0120557\n    CLs = 0.0527832 +/- 0.0103348\n    CLs = 0.0555828 +/- 0.00998248\n    CLs = 0.0567971 +/- 0.00923449\n    CLs = 0.0581822 +/- 0.00871417\n    CLs = 0.0588835 +/- 0.00836245\n    CLs = 0.0594035 +/- 0.00784761\n    CLs = 0.0590583 +/- 0.00752672\n    CLs = 0.0552067 +/- 0.00695542\n    CLs = 0.0560446 +/- 0.00679746\n    CLs = 0.0548083 +/- 0.0064351\n    CLs = 0.0566998 +/- 0.00627124\n    CLs = 0.0561576 +/- 0.00601888\n    CLs = 0.0551643 +/- 0.00576338\n    CLs = 0.0583584 +/- 0.00582854\n    CLs = 0.0585691 +/- 0.0057078\n    CLs = 0.0599114 +/- 0.00564585\n    CLs = 0.061987 +/- 0.00566905\n    CLs = 0.061836 +/- 0.00549856\n    CLs = 0.0616849 +/- 0.0053773\n    CLs = 0.0605352 +/- 0.00516844\n    CLs = 0.0602028 +/- 0.00502875\n    CLs = 0.058667 +/- 0.00486263\n    CLs      = 0.058667 +/- 0.00486263\n    CLb      = 0.222901 +/- 0.00727258\n    CLsplusb = 0.0130769 +/- 0.000996375\n\n  r = 2.25348 +/- 0\n    CLs = 0.0192308 +/- 0.0139799\n    CLs = 0.0173103 +/- 0.00886481\n    CLs      = 0.0173103 +/- 0.00886481\n    CLb      = 0.231076 +/- 0.0266062\n    CLsplusb = 0.004 +/- 0.001996\n\n  r = 2.13022 +/- 0\n    CLs = 0.0441176 +/- 0.0190309\n    CLs = 0.0557778 +/- 0.01736\n    CLs = 0.0496461 +/- 0.0132776\n    CLs = 0.0479048 +/- 0.0114407\n    CLs = 0.0419333 +/- 0.00925719\n    CLs = 0.0367934 +/- 0.0077345\n    CLs = 0.0339814 +/- 0.00684844\n    CLs = 0.03438 +/- 0.0064704\n    CLs = 0.0337633 +/- 0.00597315\n    CLs = 0.0321262 +/- 0.00551608\n    CLs      = 0.0321262 +/- 0.00551608\n    CLb      = 0.230342 +/- 0.0118665\n    CLsplusb = 0.0074 +/- 0.00121204\n\n  r = 2.06859 +/- 0\n    CLs = 0.0357143 +/- 0.0217521\n    CLs = 0.0381957 +/- 0.0152597\n    CLs = 0.0368622 +/- 0.0117105\n    CLs = 0.0415097 +/- 0.0106676\n    CLs = 0.0442816 +/- 0.0100457\n    CLs = 0.0376644 +/- 0.00847235\n    CLs = 0.0395133 +/- 0.0080427\n    CLs = 0.0377625 +/- 0.00727262\n    CLs = 0.0364415 +/- 0.00667827\n    CLs = 0.0368015 +/- 0.00628517\n    CLs = 0.0357251 +/- 0.00586442\n    CLs = 0.0341604 +/- 0.00546373\n    CLs = 0.0361935 +/- 0.00549648\n    CLs = 0.0403254 +/- 0.00565172\n    CLs = 0.0408613 +/- 0.00554124\n    CLs = 0.0416682 +/- 0.00539651\n    CLs = 0.0432645 +/- 0.00538062\n    CLs = 0.0435229 +/- 0.00516945\n    CLs = 0.0427647 +/- 0.00501322\n    CLs = 0.0414894 +/- 0.00479711\n    CLs      = 0.0414894 +/- 0.00479711\n    CLb      = 0.202461 +/- 0.00800632\n    CLsplusb = 0.0084 +/- 0.000912658\n\n\n -- HybridNew, before fit --\nLimit: r &lt; 2.00696 +/- 1.25 [1.50522, 2.13022]\nWarning in : Could not create the Migrad minimizer. Try using the minimizer Minuit\nFit to 5 points: 1.91034 +/- 0.0388334\n\n -- Hybrid New --\nLimit: r &lt; 1.91034 +/- 0.0388334 @ 95% CL\nDone in 0.01 min (cpu), 4.09 min (real)\nFailed to delete temporary file roostats-Sprxsw.root: No such file or directory\n\n<p></p>\n\n<p>The result stored in the limit branch of the output tree will be the upper limit (and its error, stored in limitErr). The default behaviour will be, as above, to search for the upper limit on r. However, the values of p_{\\mu}, p_{b} and CL<sub>s</sub> can be calculated for a particular value r=X by specifying the option <code>--singlePoint=X</code>. In this case, the value stored in the branch limit will be the value of CL<sub>s</sub> (or p_{\\mu}) (see the FAQ section). </p>"},{"location":"part3/commonstatsmethods/#expected-limits","title":"Expected Limits","text":"<p>For simple models, we can run interactively 5 times to compute the median expected and the 68% and 95% central interval boundaries. For this, we can use the <code>HybridNew</code> method with the same options as for the observed limit, but adding a <code>--expectedFromGrid=&lt;quantile&gt;</code>. Here, the quantile should be set to 0.5 for the median, 0.84 for the +ve side of the 68% band, 0.16 for the -ve side of the 68% band, 0.975 for the +ve side of the 95% band, and 0.025 for the -ve side of the 95% band.</p>\n<p>The output file will contain the value of the quantile in the branch quantileExpected. This branch can therefore be used to separate the points.</p>"},{"location":"part3/commonstatsmethods/#accuracy","title":"Accuracy","text":"<p>The search for the limit is performed using an adaptive algorithm, terminating when the estimate of the limit value is below some limit or when the precision cannot be improved further with the specified options. The options controlling this behaviour are:</p>\n<ul>\n<li><code>rAbsAcc</code>, <code>rRelAcc</code>: define the accuracy on the limit at which the search stops. The default values are 0.1 and 0.05 respectively, meaning that the search is stopped when \u0394r &lt; 0.1 or \u0394r/r &lt; 0.05.</li>\n<li><code>clsAcc</code>: this determines the absolute accuracy up to which the CLs values are computed when searching for the limit. The default is 0.5%. Raising the accuracy above this value will significantly increase the time needed to run the algorithm, as you need N<sup>2</sup> more toys to improve the accuracy by a factor N. You can consider increasing this value if you are computing limits with a larger CL (e.g. 90% or 68%). Note that if you are using the <code>CLsplusb</code> rule, this parameter will control the uncertainty on p_{\\mu} rather than CL<sub>s</sub>.</li>\n<li><code>T</code> or <code>toysH</code>: controls the minimum number of toys that are generated for each point. The default value of 500 should be sufficient when computing the limit at 90-95% CL. You can decrease this number if you are computing limits at 68% CL, or increase it if you are using 99% CL.</li>\n</ul>\n<p>Note, to further improve the accuracy when searching for the upper limit, Combine will also fit an exponential function to several of the points and interpolate to find the crossing.</p>"},{"location":"part3/commonstatsmethods/#complex-models","title":"Complex models","text":"<p>For complicated models, it is best to produce a grid of test statistic distributions at various values of the signal strength, and use it to compute the observed and expected limit and central intervals. This approach is convenient for complex models, since the grid of points can be distributed across any number of jobs. In this approach we will store the distributions of the test statistic at different values of the signal strength using the option <code>--saveHybridResult</code>. The distribution at a single value of r=X can be determined by</p>\n<pre><code>combine datacard.txt -M HybridNew --LHCmode LHC-limits --singlePoint X --saveToys --saveHybridResult -T 500 --clsAcc 0\n</code></pre>\n\n<p>Warning</p>\n<p>We have specified the accuracy here by including <code>--clsAcc=0</code>, which turns off adaptive sampling, and specifying the number of toys to be 500 with the <code>-T N</code> option. For complex models, it may be necessary to internally split the toys over a number of instances of <code>HybridNew</code> using the option <code>--iterations I</code>. The total number of toys will be the product I*N.</p>\n\n<p>The above can be repeated several times, in parallel, to build the distribution of the test statistic (passing the random seed option <code>-s -1</code>). Once all of the distributions have been calculated, the resulting output files can be merged into one using hadd, and read back to calculate the limit, specifying the merged file with <code>--grid=merged.root</code>.</p>\n<p>The observed limit can be obtained with</p>\n<pre><code>combine datacard.txt -M HybridNew --LHCmode LHC-limits --readHybridResults --toysFile=merged.root\n</code></pre>\n<p>and similarly, the median expected and quantiles can be determined using</p>\n<pre><code>combine datacard.txt -M HybridNew --LHCmode LHC-limits --readHybridResults --toysFile=merged.root --expectedFromGrid &lt;quantile&gt;\n</code></pre>\n<p>substituting <code>&lt;quantile&gt;</code> with 0.5 for the median, 0.84 for the +ve side of the 68% band, 0.16 for the -ve side of the 68% band, 0.975 for the +ve side of the 95% band, and 0.025 for the -ve side of the 95% band.</p>\n<p>The splitting of the jobs can be left to the user's preference. However, users may wish to use the combineTool for automating this, as described in the section on combineTool for job submission</p>"},{"location":"part3/commonstatsmethods/#plotting","title":"Plotting","text":"<p>A plot of the CL<sub>s</sub> (or p_{\\mu}) as a function of r, which is used to find the crossing, can be produced using the option <code>--plot=limit_scan.png</code>. This can be useful for judging if the chosen grid was sufficient for determining the upper limit.</p>\n<p>If we use our realistic-counting-experiment.txt datacard and generate a grid of points r\\varepsilon[1.4,2.2] in steps of 0.1, with 5000 toys for each point, the plot of the observed CL<sub>s</sub> vs r should look like the following,</p>\n<p></p>\n<p>You should judge in each case whether the limit is accurate given the spacing of the points and the precision of CL<sub>s</sub> at each point. If it is not sufficient, simply generate more points closer to the limit and/or more toys at each point.</p>\n<p>The distributions of the test statistic can also be plotted, at each value in the grid, using</p>\n<pre><code>python test/plotTestStatCLs.py --input mygrid.root --poi r --val all --mass MASS\n</code></pre>\n<p>The resulting output file will contain a canvas showing the distribution of the test statistics for the background only and signal+background hypotheses at each value of r. Use <code>--help</code> to see more options for this script. </p>\n\n<p>Info</p>\n<p>If you used the TEV or LEP style test statistic (using the commands as described above), then you should include the option <code>--doublesided</code>, which will also take care of defining the correct integrals for p_{\\mu} and p_{b}. Click on the examples below to see what a typical output of this plotting tool will look like when using the LHC test statistic, or the TEV test statistic. </p>\n\n\nqLHC test stat example\n<p></p>\n\n\nqTEV test stat example\n<p></p>"},{"location":"part3/commonstatsmethods/#computing-significances-with-toys","title":"Computing Significances with toys","text":"<p>Computation of the expected significance with toys is a two-step procedure: first you need to run one or more jobs to construct the expected distribution of the test statistic. As for setting limits, there are a number of different possible configurations for generating toys.  However, we will use the most commonly used option,</p>\n<ul>\n<li>LHC-style: <code>--LHCmode LHC-significance</code>\n, which is the shortcut for <code>--testStat LHC --generateNuisances=0 --generateExternalMeasurements=1 --fitNuisances=1 --significance</code><ul>\n<li>The test statistic is defined using the ratio of likelihoods q_{0} = -2\\ln[\\mathcal{L}(\\mu=0,\\hat{\\hat{\\nu}}(0))/\\mathcal{L}(\\hat{\\mu},\\hat{\\nu})], in which the nuisance parameters are profiled separately for \\mu=\\hat{\\mu} and \\mu=0.</li>\n<li>The value of the test statistic is set to 0 when \\hat{\\mu}&lt;0</li>\n<li>For the purposes of toy generation, the nuisance parameters are fixed to their post-fit values from the data assuming no signal, while the constraint terms are randomized for the evaluation of the likelihood.</li>\n</ul>\n</li>\n</ul>"},{"location":"part3/commonstatsmethods/#observed-significance","title":"Observed significance","text":"<p>To construct the distribution of the test statistic, the following command should be run as many times as necessary</p>\n<pre><code>combine -M HybridNew datacard.txt --LHCmode LHC-significance  --saveToys --fullBToys --saveHybridResult -T toys -i iterations -s seed\n</code></pre>\n<p>with different seeds, or using <code>-s -1</code> for random seeds, then merge all those results into a single ROOT file with <code>hadd</code>.</p>\n<p>The observed significance can be calculated as</p>\n<pre><code>combine -M HybridNew datacard.txt --LHCmode LHC-significance --readHybridResult --grid=input.root [--pvalue ]\n</code></pre>\n<p>where the option <code>--pvalue</code> will replace the result stored in the limit branch output tree to be the p-value instead of the signficance.</p>"},{"location":"part3/commonstatsmethods/#expected-significance-assuming-some-signal","title":"Expected significance, assuming some signal","text":"<p>The expected significance, assuming a signal with r=X can be calculated, by including the option <code>--expectSignal X</code> when generating the distribution of the test statistic and using the option <code>--expectedFromGrid=0.5</code> when calculating the significance for the median. To get the \u00b11\u03c3 bands, use 0.16 and 0.84 instead of 0.5, and so on.</p>\n<p>The total number of background toys needs to be large enough to compute the value of the significance, but you need fewer signal toys (especially when you are only computing the median expected significance). For large significances, you can run most of the toys without the <code>--fullBToys</code> option, which will be about a factor 2 faster. Only a small part of the toys needs to be run with that option turned on.</p>\n<p>As with calculating limits with toys, these jobs can be submitted to the grid or batch systems with the help of the <code>combineTool</code>, as described in the section on combineTool for job submission</p>"},{"location":"part3/commonstatsmethods/#goodness-of-fit-tests","title":"Goodness of fit tests","text":"<p>The <code>GoodnessOfFit</code> method can be used to evaluate how compatible the observed data are with the model PDF.</p>\n<p>This method implements several algorithms, and will compute a goodness of fit indicator for the chosen algorithm and the data. The procedure is therefore to first run on the real data</p>\n<pre><code>combine -M GoodnessOfFit datacard.txt --algo=&lt;some-algo&gt;\n</code></pre>\n<p>and then to run on many toy MC data sets to determine the distribution of the goodness-of-fit indicator</p>\n<pre><code>combine -M GoodnessOfFit datacard.txt --algo=&lt;some-algo&gt; -t &lt;number-of-toys&gt; -s &lt;seed&gt;\n</code></pre>\n<p>When computing the goodness-of-fit, by default the signal strength is left floating in the fit, so that the measure is independent from the presence or absence of a signal. It is possible to fixe the signal strength to some value by passing the option <code>--fixedSignalStrength=&lt;value&gt;</code>.</p>\n<p>The following algorithms are implemented:</p>\n<ul>\n<li>\n<p><code>saturated</code>: Compute a goodness-of-fit measure for binned fits based on the saturated model, as prescribed by the Statistics Committee (note). This quantity is similar to a chi-square, but can be computed for an arbitrary combination of binned channels with arbitrary constraints.</p>\n</li>\n<li>\n<p><code>KS</code>: Compute a goodness-of-fit measure for binned fits using the Kolmogorov-Smirnov test. It is based on the largest difference between the cumulative distribution function and the empirical distribution function of any bin.</p>\n</li>\n<li>\n<p><code>AD</code>: Compute a goodness-of-fit measure for binned fits using the Anderson-Darling test. It is based on the integral of the difference between the cumulative distribution function and the empirical distribution function over all bins. It also gives the tail ends of the distribution a higher weighting.</p>\n</li>\n</ul>\n<p>The output tree will contain a branch called <code>limit</code>, which contains the value of the test statistic in each toy. You can make a histogram of this test statistic t. From the distribution that is obtained in this way (f(t)) and the single value obtained by running on the observed data (t_{0}) you can calculate the p-value $$p = \\int_{t=t_{0}}^{\\mathrm{+inf}} f(t) dt $$. Note: in rare cases the test statistic value for the toys can be undefined (for AS and KD). In this case we set the test statistic value to -1. When plotting the test statistic distribution, those toys should be excluded. This is automatically taken care of if you use the GoF collection script in CombineHarvester, which is described below.</p>\n<p>When generating toys, the default behavior will be used. See the section on toy generation for options that control how nuisance parameters are generated and fitted in these tests. It is recommended to use frequentist toys (<code>--toysFreq</code>) when running the <code>saturated</code> model, and the default toys for the other two tests.</p>\n<p>Further goodness-of-fit methods could be added on request, especially if volunteers are available to code them.\nThe output limit tree will contain the value of the test statistic in each toy (or the data)</p>\n\n<p>Warning</p>\n<p>The above algorithms are all concerned with one-sample tests. For two-sample tests, you can follow an example CMS HIN analysis described in this Twiki</p>"},{"location":"part3/commonstatsmethods/#masking-analysis-regions-in-the-saturated-model","title":"Masking analysis regions in the saturated model","text":"<p>For analyses that employ a simultaneous fit across signal and control regions, it may be useful to mask one or more analysis regions, either when the likelihood is maximized (fit) or when the test statistic is computed. This can be done by using the options <code>--setParametersForFit</code> and <code>--setParametersForEval</code>, respectively. The former will set parameters before each fit, while the latter is used to set parameters after each fit, but before the NLL is evaluated. Note, of course, that if the parameter in the list is floating, it will still be floating in each fit. Therefore, it will not affect the results when using <code>--setParametersForFit</code>.  </p>\n<p>A realistic example for a binned shape analysis performed in one signal region and two control samples can be found in this directory of the Combine package Datacards-shape-analysis-multiple-regions.</p>\n<p>First of all, one needs to Combine the individual datacards to build a single model, and to introduce the channel masking variables as follow:</p>\n<pre><code>combineCards.py signal_region.txt dimuon_control_region.txt singlemuon_control_region.txt &gt; combined_card.txt\ntext2workspace.py combined_card.txt --channel-masks\n</code></pre>\n<p>More information about the channel masking can be found in this\nsection Channel Masking. The saturated test static value for a simultaneous fit across all the analysis regions can be calculated as:</p>\n<pre><code>combine -M GoodnessOfFit -d combined_card.root --algo=saturated -n _result_sb\n</code></pre>\n<p>In this case, signal and control regions are included in both the fit and in the evaluation of the test statistic, and the signal strength is freely floating. This measures the compatibility between the signal+background fit and the observed data. Moreover, it can be interesting to assess the level of compatibility between the observed data in all the regions and the background prediction obtained by only fitting the control regions (CR-only fit). This can be evaluated as follow:</p>\n<pre><code>combine -M GoodnessOfFit -d combined_card.root --algo=saturated -n _result_bonly_CRonly --setParametersForFit mask_ch1=1 --setParametersForEval mask_ch1=0 --freezeParameters r --setParameters r=0\n</code></pre>\n<p>where the signal strength is frozen and the signal region is not considered in the fit (<code>--setParametersForFit mask_ch1=1</code>), but it is included in the test statistic computation (<code>--setParametersForEval mask_ch1=0</code>). To show the differences between the two models being tested, one can perform a fit to the data using the FitDiagnostics method as:</p>\n<pre><code>combine -M FitDiagnostics -d combined_card.root -n _fit_result --saveShapes --saveWithUncertainties\ncombine -M FitDiagnostics -d combined_card.root -n _fit_CRonly_result --saveShapes --saveWithUncertainties --setParameters mask_ch1=1\n</code></pre>\n<p>By taking the total background, the total signal, and the data shapes from the FitDiagnostics output, we can compare the post-fit predictions from the S+B fit (first case) and the CR-only fit (second case) with the observation as reported below:</p>\n\nFitDiagnostics S+B fit\n<p></p>\n\n\nFitDiagnostics CR-only fit\n<p></p>\n\n<p>To compute a p-value for the two results, one needs to compare the observed goodness-of-fit value previously computed with the expected distribution of the test statistic obtained in toys:</p>\n<pre><code>    combine -M GoodnessOfFit combined_card.root --algo=saturated -n result_toy_sb --toysFrequentist -t 500\n    combine -M GoodnessOfFit -d combined_card.root --algo=saturated -n _result_bonly_CRonly_toy --setParametersForFit mask_ch1=1 --setParametersForEval mask_ch1=0 --freezeParameters r --setParameters r=0,mask_ch1=1 -t 500 --toysFrequentist\n</code></pre>\n<p>where the former gives the result for the S+B model, while the latter gives the test-statistic for CR-only fit. The command <code>--setParameters r=0,mask_ch1=1</code> is needed to ensure that toys are thrown using the nuisance parameters estimated from the CR-only fit to the data. The comparison between the observation and the expected distribition should look like the following two plots:</p>\n\nGoodness-of-fit for S+B model\n<p></p>\n\n\nGoodness-of-fit for CR-only model\n<p></p>"},{"location":"part3/commonstatsmethods/#making-a-plot-of-the-gof-test-statistic-distribution","title":"Making a plot of the GoF test statistic distribution","text":"<p>If you have also checked out the combineTool, you can use this to run batch jobs or on the grid (see here) and produce a plot of the results. Once the jobs have completed, you can hadd them together and run (e.g for the saturated model),</p>\n<pre><code>combineTool.py -M CollectGoodnessOfFit --input data_run.root toys_run.root -m 125.0 -o gof.json\nplotGof.py gof.json --statistic saturated --mass 125.0 -o gof_plot --title-right=\"my label\"\n</code></pre>"},{"location":"part3/commonstatsmethods/#channel-compatibility","title":"Channel Compatibility","text":"<p>The <code>ChannelCompatibilityCheck</code> method can be used to evaluate how compatible the measurements of the signal strength from the separate channels of a combination are with each other.</p>\n<p>The method performs two fits of the data, first with the nominal model in which all channels are assumed to have the same signal strength modifier r, and then another allowing separate signal strengths r_{i} in each channel. A chisquare-like quantity is computed as -2 \\ln \\mathcal{L}(\\mathrm{data}| r)/L(\\mathrm{data}|\\{r_{i}\\}_{i=1}^{N_{\\mathrm{chan}}}). Just like for the goodness-of-fit indicators, the expected distribution of this quantity under the nominal model can be computed from toy MC data sets.</p>\n<p>By default, the signal strength is kept floating in the fit with the nominal model. It can however be fixed to a given value by passing the option <code>--fixedSignalStrength=&lt;value&gt;</code>.</p>\n<p>In the default model built from the datacards, the signal strengths in all channels are constrained to be non-negative. One can allow negative signal strengths in the fits by changing the bound on the variable (option <code>--rMin=&lt;value&gt;</code>), which should make the quantity more chisquare-like under the hypothesis of zero signal; this however can create issues in channels with small backgrounds, since total expected yields and PDFs in each channel must be positive.</p>\n<p>Optionally, channels can be grouped together by using the option <code>-g &lt;name_fragment&gt;</code>, where <code>&lt;name_fragment&gt;</code> is a string which is common to all channels to be grouped together. The <code>-g</code> option can also be used to set the range for the each POI separately via <code>-g &lt;name&gt;=&lt;min&gt;,&lt;max&gt;</code>.</p>\n<p>When run with a verbosity of 1, as is the default, the program also prints out the best fit signal strengths in all channels. As the fit to all channels is done simultaneously, the correlation between the other systematic uncertainties is taken into account. Therefore, these results can differ from the ones obtained when fitting each channel separately.</p>\n<p>Below is an example output from Combine,</p>\n<pre><code>$ combine -M ChannelCompatibilityCheck comb_hww.txt -m 160 -n HWW\n &lt;&lt;&lt; Combine &gt;&gt;&gt;\n&gt;&gt;&gt; including systematics\n&gt;&gt;&gt; method used to compute upper limit is ChannelCompatibilityCheck\n&gt;&gt;&gt; random number generator seed is 123456\n\nSanity checks on the model: OK\nComputing limit starting from observation\n\n--- ChannelCompatibilityCheck ---\nNominal fit : r = 0.3431 -0.1408/+0.1636\nAlternate fit: r = 0.4010 -0.2173/+0.2724 in channel hww_0jsf_shape\nAlternate fit: r = 0.2359 -0.1854/+0.2297 in channel hww_0jof_shape\nAlternate fit: r = 0.7669 -0.4105/+0.5380 in channel hww_1jsf_shape\nAlternate fit: r = 0.3170 -0.3121/+0.3837 in channel hww_1jof_shape\nAlternate fit: r = 0.0000 -0.0000/+0.5129 in channel hww_2j_cut\nChi2-like compatibility variable: 2.16098\nDone in 0.08 min (cpu), 0.08 min (real)\n</code></pre>\n<p>The output tree will contain the value of the compatibility (chi-square variable) in the limit branch. If the option <code>--saveFitResult</code> is specified, the output ROOT file also contains two RooFitResult objects fit_nominal and fit_alternate with the results of the two fits.</p>\n<p>This can be read and used to extract the best fit value for each channel, and the overall best fit value, using</p>\n<pre><code>$ root -l\nTFile* _file0 = TFile::Open(\"higgsCombineTest.ChannelCompatibilityCheck.mH120.root\");\nfit_alternate-&gt;floatParsFinal().selectByName(\"*ChannelCompatibilityCheck*\")-&gt;Print(\"v\");\nfit_nominal-&gt;floatParsFinal().selectByName(\"r\")-&gt;Print(\"v\");\n</code></pre>\n<p>The macro cccPlot.cxx can be used to produce a comparison plot of the best fit signal strengths from all channels.</p>"},{"location":"part3/commonstatsmethods/#likelihood-fits-and-scans","title":"Likelihood Fits and Scans","text":"<p>The <code>MultiDimFit</code> method can be used to perform multi-dimensional fits and likelihood-based scans/contours using models with several parameters of interest.</p>\n<p>Taking a toy datacard data/tutorials/multiDim/toy-hgg-125.txt (counting experiment which vaguely resembles an early H\u2192\u03b3\u03b3 analysis at 125 GeV), we need to convert the datacard into a workspace with 2 parameters, the ggH and qqH cross sections:</p>\n<pre><code>text2workspace.py toy-hgg-125.txt -m 125 -P HiggsAnalysis.CombinedLimit.PhysicsModel:floatingXSHiggs --PO modes=ggH,qqH\n</code></pre>\n<p>A number of different algorithms can be used with the option <code>--algo &lt;algo&gt;</code>,</p>\n<ul>\n<li>\n<p><code>none</code> (default):  Perform a maximum likelihood fit <code>combine -M MultiDimFit toy-hgg-125.root</code>; The output ROOT tree will contain two columns, one for each parameter, with the fitted values.</p>\n</li>\n<li>\n<p><code>singles</code>: Perform a fit of each parameter separately, treating the other parameters of interest as unconstrained nuisance parameters: <code>combine -M MultiDimFit toy-hgg-125.root --algo singles --cl=0.68</code> . The output ROOT tree will contain two columns, one for each parameter, with the fitted values; there will be one row with the best fit point (and <code>quantileExpected</code> set to -1) and two rows for each fitted parameter, where the corresponding column will contain the maximum and minimum of that parameter in the 68% CL interval, according to a one-dimensional chi-square (i.e. uncertainties on each fitted parameter do not increase when adding other parameters if they are uncorrelated). Note that if you run, for example, with <code>--cminDefaultMinimizerStrategy=0</code>, these uncertainties will be derived from the Hessian, while <code>--cminDefaultMinimizerStrategy=1</code> will invoke Minos to derive them.</p>\n</li>\n<li>\n<p><code>cross</code>:  Perform a joint fit of all parameters: <code>combine -M MultiDimFit toy-hgg-125.root --algo=cross --cl=0.68</code>. The output ROOT tree will have one row with the best fit point, and two rows for each parameter, corresponding to the minimum and maximum of that parameter on the likelihood contour corresponding to the specified CL, according to an N-dimensional chi-square (i.e. the uncertainties on each fitted parameter do increase when adding other parameters, even if they are uncorrelated). Note that this method does not produce 1D uncertainties on each parameter, and should not be taken as such.</p>\n</li>\n<li>\n<p><code>contour2d</code>: Make a 68% CL contour \u00e0 la minos <code>combine -M MultiDimFit toy-hgg-125.root --algo contour2d --points=20 --cl=0.68</code>. The output will contain values corresponding to the best fit point (with <code>quantileExpected</code> set to -1) and for a set of points on the contour (with <code>quantileExpected</code> set to 1-CL, or something larger than that if the contour hits the boundary of the parameters). Probabilities are computed from the the n-dimensional \\chi^{2} distribution. For slow models, this method can be split by running several times with a different number of points, and merging the outputs. The contourPlot.cxx macro can be used to make plots out of this algorithm.</p>\n</li>\n<li>\n<p><code>random</code>: Scan N random points and compute the probability out of the profile likelihood ratio <code>combine -M MultiDimFit toy-hgg-125.root --algo random --points=20 --cl=0.68</code>. Again, the best fit will have <code>quantileExpected</code> set to -1, while each random point will have <code>quantileExpected</code> set to the probability given by the profile likelihood ratio at that point.</p>\n</li>\n<li>\n<p><code>fixed</code>: Compare the log-likelihood at a fixed point compared to the best fit. <code>combine -M MultiDimFit toy-hgg-125.root --algo fixed --fixedPointPOIs r=r_fixed,MH=MH_fixed</code>. The output tree will contain the difference in the negative log-likelihood between the points (\\hat{r},\\hat{m}_{H}) and (\\hat{r}_{fixed},\\hat{m}_{H,fixed}) in the branch <code>deltaNLL</code>.</p>\n</li>\n<li>\n<p><code>grid</code>:  Scan a fixed grid of points with approximately N points in total. <code>combine -M MultiDimFit toy-hgg-125.root --algo grid --points=10000</code>.</p>\n<ul>\n<li>You can partition the job in multiple tasks by using the options <code>--firstPoint</code> and <code>--lastPoint</code>. For complicated scans, the points can be split as described in the combineTool for job submission section. The output file will contain a column <code>deltaNLL</code> with the difference in negative log-likelihood with respect to the best fit point. Ranges/contours can be evaluated by filling TGraphs or TH2 histograms with these points.</li>\n<li>By default the \"min\" and \"max\" of the POI ranges are not included and the points that are in the scan are centred , eg <code>combine -M MultiDimFit --algo grid --rMin 0 --rMax 5 --points 5</code> will scan at the points r=0.5, 1.5, 2.5, 3.5, 4.5. You can include the option <code>--alignEdges 1</code>, which causes the points to be aligned with the end-points of the parameter ranges - e.g. <code>combine -M MultiDimFit --algo grid --rMin 0 --rMax 5 --points 6 --alignEdges 1</code> will scan at the points r=0, 1, 2, 3, 4, 5. Note - the number of points must be increased by 1 to ensure both end points are included.</li>\n</ul>\n</li>\n</ul>\n<p>With the algorithms <code>none</code> and <code>singles</code> you can save the RooFitResult from the initial fit using the option <code>--saveFitResult</code>. The fit result is saved into a new file called <code>multidimfit.root</code>.</p>\n<p>As usual, any floating nuisance parameters will be profiled. This behaviour can be modified by using the <code>--freezeParameters</code> option.</p>\n<p>For most of the methods, for lower-precision results you can turn off the profiling of the nuisance parameters by using the option <code>--fastScan</code>, which for complex models speeds up the process by several orders of magnitude. All nuisance parameters will be kept fixed at the value corresponding to the best fit point.</p>\n<p>As an example, let's produce the -2\\Delta\\ln{\\mathcal{L}} scan as a function of <code>r_ggH</code> and <code>r_qqH</code> from the toy H\u2192\u03b3\u03b3 datacard, with the nuisance parameters fixed to their global best fit values.</p>\n<pre><code>combine toy-hgg-125.root -M MultiDimFit --algo grid --points 2000 --setParameterRanges r_qqH=0,10:r_ggH=0,4 -m 125 --fastScan\n</code></pre>\n\nShow output\n<pre><code>\n &lt;&lt;&lt; Combine &gt;&gt;&gt;\n&gt;&gt;&gt; including systematics\n&gt;&gt;&gt; method used is MultiDimFit\n&gt;&gt;&gt; random number generator seed is 123456\nModelConfig 'ModelConfig' defines more than one parameter of interest. This is not supported in some statistical methods.\nSet Range of Parameter r_qqH To : (0,10)\nSet Range of Parameter r_ggH To : (0,4)\nComputing results starting from observation (a-posteriori)\n POI: r_ggH= 0.88152 -&gt; [0,4]\n POI: r_qqH= 4.68297 -&gt; [0,10]\nPoint 0/2025, (i,j) = (0,0), r_ggH = 0.044444, r_qqH = 0.111111\nPoint 11/2025, (i,j) = (0,11), r_ggH = 0.044444, r_qqH = 2.555556\nPoint 22/2025, (i,j) = (0,22), r_ggH = 0.044444, r_qqH = 5.000000\nPoint 33/2025, (i,j) = (0,33), r_ggH = 0.044444, r_qqH = 7.444444\nPoint 55/2025, (i,j) = (1,10), r_ggH = 0.133333, r_qqH = 2.333333\nPoint 66/2025, (i,j) = (1,21), r_ggH = 0.133333, r_qqH = 4.777778\nPoint 77/2025, (i,j) = (1,32), r_ggH = 0.133333, r_qqH = 7.222222\nPoint 88/2025, (i,j) = (1,43), r_ggH = 0.133333, r_qqH = 9.666667\nPoint 99/2025, (i,j) = (2,9), r_ggH = 0.222222, r_qqH = 2.111111\nPoint 110/2025, (i,j) = (2,20), r_ggH = 0.222222, r_qqH = 4.555556\nPoint 121/2025, (i,j) = (2,31), r_ggH = 0.222222, r_qqH = 7.000000\nPoint 132/2025, (i,j) = (2,42), r_ggH = 0.222222, r_qqH = 9.444444\nPoint 143/2025, (i,j) = (3,8), r_ggH = 0.311111, r_qqH = 1.888889\nPoint 154/2025, (i,j) = (3,19), r_ggH = 0.311111, r_qqH = 4.333333\nPoint 165/2025, (i,j) = (3,30), r_ggH = 0.311111, r_qqH = 6.777778\nPoint 176/2025, (i,j) = (3,41), r_ggH = 0.311111, r_qqH = 9.222222\nPoint 187/2025, (i,j) = (4,7), r_ggH = 0.400000, r_qqH = 1.666667\nPoint 198/2025, (i,j) = (4,18), r_ggH = 0.400000, r_qqH = 4.111111\nPoint 209/2025, (i,j) = (4,29), r_ggH = 0.400000, r_qqH = 6.555556\nPoint 220/2025, (i,j) = (4,40), r_ggH = 0.400000, r_qqH = 9.000000\n[...]\n\nDone in 0.00 min (cpu), 0.02 min (real)\n</code></pre>\n\n<p>The scan, along with the best fit point can be drawn using root,</p>\n<pre><code>$ root -l higgsCombineTest.MultiDimFit.mH125.root\n\nlimit-&gt;Draw(\"2*deltaNLL:r_ggH:r_qqH&gt;&gt;h(44,0,10,44,0,4)\",\"2*deltaNLL&lt;10\",\"prof colz\")\n\nlimit-&gt;Draw(\"r_ggH:r_qqH\",\"quantileExpected == -1\",\"P same\")\nTGraph *best_fit = (TGraph*)gROOT-&gt;FindObject(\"Graph\")\n\nbest_fit-&gt;SetMarkerSize(3); best_fit-&gt;SetMarkerStyle(34); best_fit-&gt;Draw(\"p same\")\n</code></pre>\n<p></p>\n<p>To make the full profiled scan, just remove the <code>--fastScan</code> option from the Combine command.</p>\n<p>Similarly, 1D scans can be drawn directly from the tree, however for 1D likelihood scans, there is a python script from the <code>CombineHarvester/CombineTools</code> package plot1DScan.py that can be used to make plots and extract the crossings of the <code>2*deltaNLL</code> - e.g the 1\u03c3/2\u03c3 boundaries.</p>"},{"location":"part3/commonstatsmethods/#useful-options-for-likelihood-scans","title":"Useful options for likelihood scans","text":"<p>A number of common, useful options (especially for computing likelihood scans with the grid algo) are,</p>\n<ul>\n<li><code>--autoBoundsPOIs arg</code>: Adjust bounds for the POIs if they end up close to the boundary. This can be a comma-separated list of POIs, or \"*\" to get all of them.</li>\n<li><code>--autoMaxPOIs arg</code>: Adjust maxima for the POIs if they end up close to the boundary. Can be a list of POIs, or \"*\" to get all.</li>\n<li><code>--autoRange X</code>: Set to any X &gt;= 0 to do the scan in the \\hat{p} \\pm X\u03c3 range, where \\hat{p} and \u03c3 are the best fit parameter value and uncertainty from the initial fit (so it may be fairly approximate). In case you do not trust the estimate of the error from the initial fit, you can just centre the range on the best fit value by using the option <code>--centeredRange X</code> to do the scan in the \\hat{p} \\pm X range centered on the best fit value.</li>\n<li><code>--squareDistPoiStep</code>:  POI step size based on distance from the midpoint ( either (max-min)/2 or the best fit if used with <code>--autoRange</code> or <code>--centeredRange</code> ) rather than linear separation.</li>\n<li><code>--skipInitialFit</code>: Skip the initial fit (saves time if, for example, a snapshot is loaded from a previous fit)</li>\n</ul>\n<p>Below is a comparison in a likelihood scan, with 20 points, as a function of <code>r_qqH</code> with our <code>toy-hgg-125.root</code> workspace with and without some of these options. The options added tell Combine to scan more points closer to the minimum (best-fit) than with the default.</p>\n<p></p>\n<p>You may find it useful to use the <code>--robustFit=1</code> option to turn on robust (brute-force) for likelihood scans (and other algorithms). You can set the strategy and tolerance when using the <code>--robustFit</code> option using the options <code>--setRobustFitAlgo</code> (default is <code>Minuit2,migrad</code>), <code>setRobustFitStrategy</code> (default is 0) and <code>--setRobustFitTolerance</code> (default is 0.1). If these options are not set, the defaults (set using <code>cminDefaultMinimizerX</code> options) will be used.</p>\n<p>If running <code>--robustFit=1</code> with the algo singles, you can tune the accuracy of the routine used to find the crossing points of the likelihood using the option <code>--setCrossingTolerance</code> (the default is set to 0.0001)</p>\n<p>If you suspect your fits/uncertainties are not stable, you may also try to run custom HESSE-style calculation of the covariance matrix. This is enabled by running <code>MultiDimFit</code> with the <code>--robustHesse=1</code> option. A simple example of how the default behaviour in a simple datacard is given here.</p>\n<p>For a full list of options use <code>combine -M MultiDimFit --help</code></p>"},{"location":"part3/commonstatsmethods/#fitting-only-some-parameters","title":"Fitting only some parameters","text":"<p>If your model contains more than one parameter of interest, you can still decide to fit a smaller number of them, using the option <code>--parameters</code> (or <code>-P</code>), with a syntax like this:</p>\n<pre><code>combine -M MultiDimFit [...] -P poi1 -P poi2 ... --floatOtherPOIs=(0|1)\n</code></pre>\n<p>If <code>--floatOtherPOIs</code> is set to 0, the other parameters of interest (POIs), which are not included as a <code>-P</code> option, are kept fixed to their nominal values. If it's set to 1, they are kept floating, which has different consequences depending on <code>algo</code>:</p>\n<ul>\n<li>When running with <code>--algo=singles</code>, the other floating POIs are treated as unconstrained nuisance parameters.</li>\n<li>When running with <code>--algo=cross</code> or <code>--algo=contour2d</code>, the other floating POIs are treated as other POIs, and so they increase the number of dimensions of the chi-square.</li>\n</ul>\n<p>As a result, when running with <code>--floatOtherPOIs</code> set to 1, the uncertainties on each fitted parameters do not depend on the selection of POIs passed to MultiDimFit, but only on the number of parameters of the model.</p>\n\n<p>Info</p>\n<p>Note that <code>poi</code> given to the the option <code>-P</code> can also be any nuisance parameter. However, by default, the other nuisance parameters are left floating, so in general this does not need to be specified.</p>\n\n<p>You can save the values of the other parameters of interest in the output tree by passing the option <code>--saveInactivePOI=1</code>. You can additionally save the post-fit values any nuisance parameter, function, or discrete index (RooCategory) defined in the workspace using the following options;</p>\n<ul>\n<li><code>--saveSpecifiedNuis=arg1,arg2,...</code> will store the fitted value of any specified constrained nuisance parameter. Use <code>all</code> to save every constrained nuisance parameter. Note that if you want to store the values of <code>flatParams</code> (or floating parameters that are not defined in the datacard) or <code>rateParams</code>,  which are unconstrained, you should instead use the generic option <code>--trackParameters</code> as described here.</li>\n<li><code>--saveSpecifiedFunc=arg1,arg2,...</code> will store the value of any function (eg <code>RooFormulaVar</code>) in the model.</li>\n<li><code>--saveSpecifiedIndex=arg1,arg2,...</code> will store the index of any <code>RooCategory</code> object - eg a <code>discrete</code> nuisance.</li>\n</ul>"},{"location":"part3/commonstatsmethods/#using-best-fit-snapshots","title":"Using best fit snapshots","text":"<p>This can be used to save time when performing scans so that the best fit does not need to be repeated. It can also be used to perform scans with some nuisance parameters frozen to their best-fit values. This can be done as follows,</p>\n<ul>\n<li>Create a workspace for a floating r,m_{H} fit</li>\n</ul>\n<pre><code>text2workspace.py hgg_datacard_mva_8TeV_bernsteins.txt -m 125 -P HiggsAnalysis.CombinedLimit.PhysicsModel:floatingHiggsMass --PO higgsMassRange=120,130 -o testmass.root`\n</code></pre>\n<ul>\n<li>Perfom the fit, saving the workspace</li>\n</ul>\n<pre><code>combine -m 123 -M MultiDimFit --saveWorkspace -n teststep1 testmass.root  --verbose 9\n</code></pre>\n<p>Now we can load the best fit \\hat{r},\\hat{m}_{H} and fit for r freezing m_{H} and lumi_8TeV to their best-fit values,</p>\n<pre><code>combine -m 123 -M MultiDimFit -d higgsCombineteststep1.MultiDimFit.mH123.root -w w --snapshotName \"MultiDimFit\" -n teststep2  --verbose 9 --freezeParameters MH,lumi_8TeV\n</code></pre>"},{"location":"part3/commonstatsmethods/#feldman-cousins","title":"Feldman-Cousins","text":"<p>The Feldman-Cousins (FC) procedure for computing confidence intervals for a generic model is,</p>\n<ul>\n<li>use the profile likelihood ratio as the test statistic, q(x) = - 2 \\ln \\mathcal{L}(x,\\hat{\\hat{\\nu}}(x))/\\mathcal{L}(\\hat{x},\\hat{\\nu}) where x is a point in the (N-dimensional) parameter space, and \\hat{x} is the point corresponding to the best fit. In this test statistic, the nuisance parameters are profiled, both in the numerator and denominator.</li>\n<li>for each point x:<ul>\n<li>compute the observed test statistic q_{\\mathrm{obs}}(x)</li>\n<li>compute the expected distribution of q(x) under the hypothesis of x as the true value.</li>\n<li>accept the point in the region if p_{x}=P\\left[q(x) &gt; q_{\\mathrm{obs}}(x)| x\\right] &gt; \\alpha</li>\n</ul>\n</li>\n</ul>\n<p>With a critical value \\alpha.</p>\n<p>In Combine, you can perform this test on each individual point (param1, param2,...) = (value1,value2,...) by doing,</p>\n<pre><code>combine workspace.root -M HybridNew --LHCmode LHC-feldman-cousins --clsAcc 0 --singlePoint  param1=value1,param2=value2,param3=value3,... --saveHybridResult [Other options for toys, iterations etc as with limits]\n</code></pre>\n<p>The point belongs to your confidence region if p_{x} is larger than \\alpha (e.g. 0.3173 for a 1\u03c3 region, 1-\\alpha=0.6827).</p>\n\n<p>Warning</p>\n<p>You should not use this method without the option <code>--singlePoint</code>. Although Combine will not complain, the algorithm to find the crossing will only find a single crossing and therefore not find the correct interval. Instead you should calculate the Feldman-Cousins intervals as described above.</p>"},{"location":"part3/commonstatsmethods/#physical-boundaries","title":"Physical boundaries","text":"<p>Imposing physical boundaries (such as requiring \\mu&gt;0 for a signal strength) is achieved by setting the ranges of the physics model parameters using</p>\n<pre><code>--setParameterRanges param1=param1_min,param1_max:param2=param2_min,param2_max ....\n</code></pre>\n<p>The boundary is imposed by restricting the parameter range(s) to those set by the user, in the fits. Note that this is a trick! The actual fitted value, as one of an ensemble of outcomes, can fall outside of the allowed region, while the boundary should be imposed on the physical parameter. The effect of restricting the parameter value in the fit is such that the test statistic is modified as follows ; </p>\n<p>q(x) = - 2 \\ln \\mathcal{L}(x,\\hat{\\hat{\\theta}}(x))/\\mathcal{L}(\\hat{x},\\hat{\\nu}), if \\hat{x} in contained in the bounded range </p>\n<p>and, </p>\n<p>q(x) = - 2 \\ln \\mathcal{L}(x,\\hat{\\hat{\\nu}}(x))/\\mathcal{L}(x_{B},\\hat{\\hat{\\nu}}(x_{B})), if \\hat{x} is outside of the bounded range. Here x_{B} and \\hat{\\hat{\\nu}}(x_{B}) are the values of x and \\nu which maximise the likelihood excluding values outside of the bounded region for x - typically, x_{B} will be found at one of the boundaries which is imposed. For example, if the boundary x&gt;0 is imposed, you will typically expect x_{B}=0, when \\hat{x}\\leq 0, and x_{B}=\\hat{x} otherewise. </p>\n<p>This can sometimes be an issue as Minuit may not know if has successfully converged when the minimum lies outside of that range. If there is no upper/lower boundary, just set that value to something far from the region of interest.</p>\n\n<p>Info</p>\n<p>One can also imagine imposing the boundaries by first allowing Minuit to find the minimum in the unrestricted  region and then setting the test statistic to that in the case that minimum lies outside the physical boundary. This would avoid potential issues of convergence. If you are interested in implementing this version in Combine, please contact the development team.</p>"},{"location":"part3/commonstatsmethods/#extracting-contours-from-results-files","title":"Extracting contours from results files","text":"<p>As in general for <code>HybridNew</code>, you can split the task into multiple tasks (grid and/or batch) and then merge the outputs with <code>hadd</code>. You can also refer to the combineTool for job submission section for submitting the jobs to the grid/batch or if you have more than one parameter of interest, see the instructions for running <code>HybridNew</code> on a grid of parameter points on the CombineHarvest - HybridNewGrid documentation. </p>"},{"location":"part3/commonstatsmethods/#extracting-1d-intervals","title":"Extracting 1D intervals","text":"<p>For one-dimensional models only, and if the parameter behaves like a cross section, the code is able to interpolate and determine the values of your parameter on the contour (just like it does for the limits). As with limits, read in the grid of points and extract 1D intervals using,</p>\n<pre><code>combine workspace.root -M HybridNew --LHCmode LHC-feldman-cousins --readHybridResults --toysFile=mergedfile.root --cl &lt;1-alpha&gt;\n</code></pre>\n<p>The output tree will contain the values of the POI that crosses the critical value (\\alpha) - i.e, the boundaries of the confidence intervals.</p>\n<p>You can produce a plot of the value of p_{x} vs the parameter of interest x by adding the option <code>--plot &lt;plotname&gt;</code>.</p>"},{"location":"part3/commonstatsmethods/#extracting-2d-contours","title":"Extracting 2D contours","text":"<p>There is a tool for extracting 2D contours from the output of <code>HybridNew</code> located in <code>test/makeFCcontour.py</code>. This can be used provided the option <code>--saveHybridResult</code> was included when running <code>HybridNew</code>. It can be run with the usual Combine output files (or several of them) as input,</p>\n<pre><code>./test/makeFCcontour.py  toysfile1.root toysfile2.root .... [options] -out outputfile.root\n</code></pre>\n<p>To extract 2D contours, the names of each parameter must be given <code>--xvar poi_x --yvar poi_y</code>. The output will be a ROOT file containing a 2D histogram of value of p_{x,y} for each point (x,y) which can be used to draw 2D contours. There will also be a histogram containing the number of toys found for each point.</p>\n<p>There are several options for reducing the running time, such as setting limits on the region of interest or the minimum number of toys required for a point to be included. Finally, adding the option <code>--storeToys</code> in this script will add histograms for each point to the output file of the test statistic distribution. This will increase the memory usage, as all of the toys will be kept in memory.</p>"},{"location":"part3/debugging/","title":"Debugging fits","text":"<p>When a fit fails there are several things you can do to investigate. CMS users can have a look at these slides from a previous Combine tutorial. This section contains a few pointers for some of the methods mentioned in the slides.</p>"},{"location":"part3/debugging/#analyzing-the-nll-shape-in-each-parameter","title":"Analyzing the NLL shape in each parameter","text":"<p>The <code>FastScan</code> mode of <code>combineTool.py</code> can be used to analyze the shape of the NLL as a function of each parameter in the fit model. The NLL is evaluated varying a single parameter at a time, the other parameters stay at the default values they have in the workspace. This produces a file with the NLL, plus its first and second derivatives, as a function of each parameter. Discontinuities in the derivatives, particularly if they are close to the minimum of the parameter, can be the source of issues with the fit. </p> <p>The usage is as follows:</p> <p><code>combineTool.py -M FastScan -w workspace.root:w</code></p> <p>Note that this will make use of the data in the workspace for evaluating the NLL. To run this on an asimov data set, with r=1 injected, you can do the following:</p> <pre><code>combine -M GenerateOnly workspace.root -t -1 --saveToys --setParameters r=1\n\ncombineTool.py -M FastScan -w workspace.root:w -d higgsCombineTest.GenerateOnly.mH120.123456.root:toys/toy_asimov\n</code></pre> <p><code>higgsCombineTest.GenerateOnly.mH120.123456.root</code> is generated by the first command; if you pass a value for <code>-m</code> or change the default output file name with <code>-n</code> the file name will be different and you should change the <code>combineTool</code> call accordingly.</p>"},{"location":"part3/nonstandard/","title":"Advanced Use Cases","text":"<p>This section will cover some of the more specific use cases for Combine that are not necessarily related to the main results of the analysis. </p>"},{"location":"part3/nonstandard/#fit-diagnostics","title":"Fit Diagnostics","text":"<p>If you want to diagnose your limits/fit results, you may first want to look at the HIG PAG standard checks, which are applied to all datacards and can be found here.</p> <p>If you have already found the Higgs boson but it's an exotic one, instead of computing a limit or significance you might want to extract its cross section by performing a maximum-likelihood fit. Alternatively, you might want to know how compatible your data and your model are, e.g. how strongly your nuisance parameters are constrained, to what extent they are correlated, etc. These general diagnostic tools are contained in the method <code>FitDiagnostics</code>. </p> <pre><code>    combine -M FitDiagnostics datacard.txt\n</code></pre> <p>The program will print out the result of two fits. The first one is performed with the signal strength r (or the first POI in the list, in models with multiple POIs) set to zero and a second with floating r. The output ROOT tree will contain the best fit value for r and its uncertainty. You will also get a <code>fitDiagnostics.root</code> file containing the following objects:</p> Object Description <code>nuisances_prefit</code> <code>RooArgSet</code> containing the pre-fit values of the nuisance parameters, and their uncertainties from the external constraint terms only <code>fit_b</code> <code>RooFitResult</code> object containing the outcome of the fit of the data with signal strength set to zero <code>fit_s</code> <code>RooFitResult</code> object containing the outcome of the fit of the data with floating signal strength <code>tree_prefit</code> <code>TTree</code> of pre-fit nuisance parameter values and constraint terms (_In) <code>tree_fit_sb</code> <code>TTree</code> of fitted nuisance parameter values and constraint terms (_In) with floating signal strength <code>tree_fit_b</code> <code>TTree</code> of fitted nuisance parameter values and constraint terms (_In) with signal strength set to 0 <p>by including the option <code>--plots</code>, you will additionally find the following contained in the ROOT file:</p> Object Description <code>covariance_fit_s</code> <code>TH2D</code> Covariance matrix of the parameters in the fit with floating signal strength <code>covariance_fit_b</code> <code>TH2D</code> Covariance matrix of the parameters in the fit with signal strength set to zero <code>category_variable_prefit</code> <code>RooPlot</code> plot of the pre-fit PDFs/templates with the data (or toy if running with <code>-t</code>) overlaid <code>category_variable_fit_b</code> <code>RooPlot</code> plot of the PDFs/templates from the background only fit with the data (or toy if running with <code>-t</code>) overlaid <code>category_variable_fit_s</code> <code>RooPlot</code> plot of the PDFs/templates from the signal+background fit with the data (or toy if running with <code>-t</code>)  overlaid <p>There will be one <code>RooPlot</code> object per category in the likelihood, and one per variable if using a multi-dimensional dataset. For each of these additional objects a png file will also be produced. </p> <p>Info</p> <p>If you use the option <code>--name</code>, this additional name will be inserted into the file name for this output file. </p> <p>As well as the values of the constrained nuisance parameters (and their constraints), you will also find branches for the number of \"bad\" nll calls (which you should check is not too large) and the status of the fit <code>fit_status</code>. The fit status is computed as follows</p> <pre><code>fit_status = 100 * hesse_status + 10 * minos_status +  minuit_summary_status\n</code></pre> <p>The <code>minuit_summary_status</code> is the usual status from Minuit, details of which can be found here. For the other status values, check these documentation links for the <code>hesse_status</code> and the <code>minos_status</code>.</p> <p>A fit status of -1 indicates that the fit failed (Minuit summary was not 0 or 1) and hence the fit result is not valid.</p>"},{"location":"part3/nonstandard/#fit-options","title":"Fit options","text":"<ul> <li>If you only want to run the signal+background fit, and do not need the output file, you can run with <code>--justFit</code>. In case you would like to run only the signal+background fit but would like to produce the output file, you should use the option <code>--skipBOnlyFit</code> instead.</li> <li>You can use <code>--rMin</code> and <code>--rMax</code> to set the range of the first POI; a range that is not too large compared with the uncertainties you expect from the fit usually gives more stable and accurate results.</li> <li>By default, the uncertainties are computed using MINOS for the first POI and HESSE for all other parameters. For the nuisance parameters the uncertainties will therefore be symmetric. You can run MINOS for all parameters using the option <code>--minos all</code>, or for none of the parameters using <code>--minos none</code>. Note that running MINOS is slower so you should only consider using it if you think the HESSE uncertainties are not accurate.</li> <li>If MINOS or HESSE fails to converge, you can try running with <code>--robustFit=1</code>. This will do a slower, but more robust, likelihood scan, which can be further controlled with the parameter <code>--stepSize</code> (the default value is 0.1, and is relative to the range of the parameter).</li> <li>The strategy and tolerance when using the <code>--robustFit</code> option can be set using the options <code>setRobustFitAlgo</code> (default is <code>Minuit2,migrad</code>), <code>setRobustFitStrategy</code> (default is 0) and <code>--setRobustFitTolerance</code> (default is 0.1). If these options are not set, the defaults (set using <code>cminDefaultMinimizerX</code> options) will be used. You can also tune the accuracy of the routine used to find the crossing points of the likelihood using the option <code>--setCrossingTolerance</code> (the default is set to 0.0001)</li> <li>If you find the covariance matrix provided by HESSE is not accurate (i.e. <code>fit_s-&gt;Print()</code> reports this was forced positive-definite) then a custom HESSE-style calculation of the covariance matrix can be used instead. This is enabled by running <code>FitDiagnostics</code> with the <code>--robustHesse 1</code> option. Please note that the status reported by <code>RooFitResult::Print()</code> will contain <code>covariance matrix quality: Unknown, matrix was externally provided</code> when robustHesse is used, this is normal and does not indicate a problem. NB: one feature of the robustHesse algorithm is that if it still cannot calculate a positive-definite covariance matrix it will try to do so by dropping parameters from the hessian matrix before inverting. If this happens it will be reported in the output to the screen. </li> <li>For other fitting options see the generic minimizer options section.</li> </ul>"},{"location":"part3/nonstandard/#fit-parameter-uncertainties","title":"Fit parameter uncertainties","text":"<p>If you get a warning message when running <code>FitDiagnostics</code> that says <code>Unable to determine uncertainties on all fit parameters</code>. This means the covariance matrix calculated in <code>FitDiagnostics</code> was not correct. </p> <p>The most common problem is that the covariance matrix is forced positive-definite. In this case the constraints on fit parameters as taken from the covariance matrix are incorrect and should not be used. In particular, if you want to make post-fit plots of the distribution used in the signal extraction fit and are extracting the uncertainties on the signal and background expectations from the covariance matrix, the resulting values will not reflect the truth if the covariance matrix was incorrect. By default if this happens and you passed the <code>--saveWithUncertainties</code> flag when calling <code>FitDiagnostics</code>, this option will be ignored as calculating the uncertainties would lead to incorrect results. This behaviour can be overridden by passing <code>--ignoreCovWarning</code>.</p> <p>Such problems with the covariance matrix can be caused by a number of things, for example:</p> <ul> <li> <p>Parameters being close to their boundaries after the fit.</p> </li> <li> <p>Strong (anti-) correlations between some parameters. A discontinuity in the NLL function or its derivatives at or near the minimum.</p> </li> </ul> <p>If you are aware that your analysis has any of these features you could try resolving these. Setting <code>--cminDefaultMinimizerStrategy 0</code> can also help with this problem.</p>"},{"location":"part3/nonstandard/#pre-and-post-fit-nuisance-parameters","title":"Pre- and post-fit nuisance parameters","text":"<p>It is possible to compare pre-fit and post-fit nuisance parameter values with the script diffNuisances.py. Taking as input a <code>fitDiagnostics.root</code> file, the script will by default print out the parameters that have changed significantly with respect to their initial estimate. For each of those parameters, it will print out the shift in value and the post-fit uncertainty, both normalized to the initial (pre-fit) value. The linear correlation between the parameter and the signal strength will also be printed.</p> <pre><code>python diffNuisances.py fitDiagnostics.root\n</code></pre> <p>The script has several options to toggle the thresholds used to decide whether a parameter has changed significantly, to get the printout of the absolute value of the nuisance parameters, and to get the output in another format for use on a webpage or in a note (the supported formats are <code>html</code>, <code>latex</code>, <code>twiki</code>). To print all of the parameters, use the option <code>--all</code>. </p> <p>By default, the changes in the nuisance parameter values and uncertainties are given relative to their initial (pre-fit) values (usually relative to initial values of 0 and 1 for most nuisance types). </p> <p>The values in the output will be (\\nu-\\nu_{I})/\\sigma_{I} if the nuisance has a pre-fit uncertainty, otherwise they will be \\nu-\\nu_{I} (for example, a <code>flatParam</code> has no pre-fit uncertainty). </p> <p>The reported uncertainty will be the ratio \\sigma/\\sigma_{I} - i.e the ratio of the post-fit to the pre-fit uncertainty. If there is no pre-fit uncertainty (as for <code>flatParam</code> nuisances), the post-fit uncertainty is shown. </p> <p>To print the pre-fit and post-fit values and (asymmetric) uncertainties, rather than the ratios, the option <code>--abs</code> can be used.</p> <p>Info</p> <p>We recommend that you include the options <code>--abs</code> and <code>--all</code> to get the full information on all of the parameters (including unconstrained nuisance parameters) at least once when checking your datacards.</p> <p>If instead of the nuisance parameter values, you wish to report the pulls, you can do so using the option <code>--pullDef X</code>, with <code>X</code> being one of the  options listed below. You should note that since the pulls below are only defined when the pre-fit uncertainty exists, nothing will be reported for parameters that have no prior constraint (except in the case of the <code>unconstPullAsym</code> choice as described below). You may want to run without this option and <code>--all</code> to get information about those parameters. </p> <ul> <li> <p><code>relDiffAsymErrs</code>: This is the same as the default output of the tool, except that only constrained parameters (i.e. where the pre-fit uncertainty is defined) are reported. The uncertainty is also reported and calculated as \\sigma/\\sigma_{I}. </p> </li> <li> <p><code>unconstPullAsym</code>: Report the pull as \\frac{\\nu-\\nu_{I}}{\\sigma}, where \\nu_{I} and \\sigma are the initial value and post-fit uncertainty of that nuisance parameter. The pull defined in this way will have no error bar, but all nuisance parameters will have a result in this case. </p> </li> <li> <p><code>compatAsym</code>: The pull is defined as \\frac{\\nu-\\nu_{D}}{\\sqrt{\\sigma^{2}+\\sigma_{D}^{2}}}, where \\nu_{D} and \\sigma_{D} are calculated as \\sigma_{D} = (\\frac{1}{\\sigma^{2}} - \\frac{1}{\\sigma_{I}^{2}})^{-1} and \\nu_{D} = \\sigma_{D}(\\nu - \\frac{\\nu_{I}}{\\sigma_{I}^{2}}). In this expression \\nu_{I} and \\sigma_{I} are the initial value and uncertainty of that nuisance parameter. This can be thought of as a compatibility between the initial measurement (prior) and an imagined measurement where only the data (with no constraint on the nuisance parameter) is used to measure the nuisance parameter. There is no error bar associated with this value. </p> </li> <li> <p><code>diffPullAsym</code>: The pull is defined as \\frac{\\nu-\\nu_{I}}{\\sqrt{\\sigma_{I}^{2}-\\sigma^{2}}}, where \\nu_{I} and \\sigma_{I} are the pre-fit value and uncertainty (from L. Demortier and L. Lyons). If the denominator is close to 0 or the post-fit uncertainty is larger than the pre-fit (usually due to some failure in the calculation), the pull is not defined and the result will be reported as <code>0 +/- 999</code>. </p> </li> </ul> <p>If using <code>--pullDef</code>, the results for all parameters for which the pull can be calculated will be shown (i.e <code>--all</code> will be set to <code>true</code>), not just those that have moved by some metric.</p> <p>This script has the option (<code>-g outputfile.root</code>) to produce plots of the fitted values of the nuisance parameters and their post-fit, asymmetric uncertainties. Instead, the pulls defined using one of the options above, can be plotted using the option <code>--pullDef X</code>. In addition this will produce a plot showing a comparison between the post-fit and pre-fit (symmetrized) uncertainties on the nuisance parameters. </p> <p>Info</p> <p>In the above options, if an asymmetric uncertainty is associated with the nuisance parameter, then the choice of which uncertainty is used in the definition of the pull will depend on the sign of \\nu-\\nu_{I}. </p>"},{"location":"part3/nonstandard/#normalizations","title":"Normalizations","text":"<p>For a certain class of models, like those made from datacards for shape-based analysis, the tool can also compute and save the best fit yields of all processes to the output ROOT file. If this feature is turned on with the option <code>--saveNormalizations</code>, the file will also contain three <code>RooArgSet</code> objects <code>norm_prefit</code>, <code>norm_fit_s</code>, and <code>norm_fit_b</code>. These each contain one <code>RooConstVar</code> for each channel <code>xxx</code> and process <code>yyy</code> with name <code>xxx/yyy</code> and value equal to the best fit yield. You can use <code>RooRealVar::getVal</code> and <code>RooRealVar::getError</code> to estimate both the post-fit (or pre-fit) values and uncertainties of these normalizations. </p> <p>The sample <code>pyROOT</code> macro mlfitNormsToText.py can be used to convert the ROOT file into a text table with four columns: channel, process, yield from the signal+background fit, and yield from the background-only fit. To include the uncertainties in the table, add the option <code>--uncertainties</code>. </p> <p>Warning</p> <p>Note that when running with multiple toys, the <code>norm_fit_s</code>, <code>norm_fit_b</code>, and <code>norm_prefit</code> objects will be stored for the last toy dataset generated and so may not be useful to you. </p> <p>Note that this procedure works only for \"extended likelihoods\" like the ones used in shape-based analysis, not for counting experiment datacards. You can however convert a counting experiment datacard to an equivalent shape-based one by adding a line <code>shapes * * FAKE</code> in the datacard after the <code>imax</code>, <code>jmax</code>, <code>kmax</code> lines. Alternatively, you can use <code>combineCards.py countingcard.txt -S &gt; shapecard.txt</code> to do this conversion. </p>"},{"location":"part3/nonstandard/#per-bin-norms-for-shape-analyses","title":"Per-bin norms for shape analyses","text":"<p>If you have a shape-based analysis, you can include the option <code>--savePredictionsPerToy</code>. With this option, additional branches will be filled in the three output trees contained in <code>fitDiagnostics.root</code>.  </p> <p>The normalization values for each toy will be stored in the branches inside the <code>TTrees</code> named n_exp[_final]_binxxx_proc_yyy. The _final will only be there if there are systematic uncertainties affecting this process. </p> <p>Additionally, there will be branches that provide the value of the expected bin content for each process, in each channel. These are named n_exp[_final]_binxxx_proc_yyy_i (where _final will only be in the name if there are systematic uncertainties affecting this process) for channel <code>xxx</code>, process <code>yyy</code>, bin number <code>i</code>. In the case of the post-fit trees (<code>tree_fit_s/b</code>), these will be the expectations from the fitted models, while for the pre-fit tree, they will be the expectation from the generated model (i.e if running toys with <code>-t N</code> and using <code>--genNuisances</code>, they will be randomized for each toy). These can be useful, for example, for calculating correlations/covariances between different bins, in different channels or processes, within the model from toys. </p> <p>Info</p> <p>Be aware that for unbinned models, a binning scheme is adopted based on the <code>RooRealVar::getBinning</code> for the observable defining the shape, if it exists, or Combine will adopt some appropriate binning for each observable. </p>"},{"location":"part3/nonstandard/#plotting","title":"Plotting","text":"<p><code>FitDiagnostics</code> can also produce pre- and post-fit plots of the model along with the data. They will be stored in the same directory as <code>fitDiagnostics.root</code>. To obtain these, you have to specify the option <code>--plots</code>, and then optionally specify the names of the signal and background PDFs/templates, e.g. <code>--signalPdfNames='ggH*,vbfH*'</code> and <code>--backgroundPdfNames='*DY*,*WW*,*Top*'</code> (by default, the definitions of signal and background are taken from the datacard). For models with more than 1 observable, a separate projection onto each observable will be produced. </p> <p>An alternative is to use the option <code>--saveShapes</code>. This will add additional folders in <code>fitDiagnostics.root</code> for each category, with pre- and post-fit distributions of the signals and backgrounds as TH1s, and the data as <code>TGraphAsymmErrors</code> (with Poisson intervals as error bars).</p> <p>Info</p> <p>If you want to save post-fit shapes at a specific r value, add the options <code>--customStartingPoint</code> and <code>--skipSBFit</code>, and set the r value. The result will appear in shapes_fit_b, as described below.</p> <p>Three additional folders (shapes_prefit, shapes_fit_sb and shapes_fit_b ) will contain the following distributions:</p> Object Description <code>data</code> <code>TGraphAsymmErrors</code> containing the observed data (or toy data if using <code>-t</code>). The vertical error bars correspond to the 68% interval for a Poisson distribution centered on the observed count (Garwood intervals), following the recipe provided by the CMS Statistics Committee. <code>$PROCESS</code> (id &lt;= 0) <code>TH1F</code> for each signal process in each channel, named as in the datacard <code>$PROCESS</code> (id &gt; 0) <code>TH1F</code> for each background process in each channel, named as in the datacard <code>total_signal</code> <code>TH1F</code> Sum over the signal components <code>total_background</code> <code>TH1F</code> Sum over the background components <code>total</code> <code>TH1F</code> Sum over all of the signal and background components <p>The above distributions are provided for each channel included in the datacard, in separate subfolders, named as in the datacard: There will be one subfolder per channel.</p> <p>Warning</p> <p>The pre-fit signal is evaluated for <code>r=1</code> by default, but this can be modified using the option <code>--preFitValue</code>.</p> <p>The distributions and normalizations are guaranteed to give the correct interpretation: </p> <ul> <li> <p>For shape datacards whose inputs are <code>TH1</code>, the histograms/data points will have the bin number as the x-axis and the content of each bin will be a number of events.</p> </li> <li> <p>For datacards whose inputs are <code>RooAbsPdf</code>/<code>RooDataHist</code>s, the x-axis will correspond to the observable and the bin content will be the PDF density / events divided by the bin width. This means the absolute number of events in a given bin, i, can be obtained from <code>h.GetBinContent(i)*h.GetBinWidth(i)</code> or similar for the data graphs. Note that for unbinned analyses Combine will make a reasonable guess as to an appropriate binning. </p> </li> </ul> <p>Uncertainties on the shapes will be added with the option <code>--saveWithUncertainties</code>. These uncertainties are generated by re-sampling of the fit covariance matrix, thereby accounting for the full correlation between the parameters of the fit. </p> <p>Warning</p> <p>It may be tempting to sum up the uncertainties in each bin (in quadrature) to get the total uncertainty on a process. However, this is (usually) incorrect, as doing so would not account for correlations between the bins. Instead you can refer to the uncertainties which will be added to the post-fit normalizations described above.</p> <p>Additionally, the covariance matrix between bin yields (or yields/bin-widths) in each channel will also be saved as a <code>TH2F</code> named total_covar. If the covariance between all bins across all channels is desired, this can be added using the option <code>--saveOverallShapes</code>. Each folder will now contain additional distributions (and covariance matrices) corresponding to the concatenation of the bins in each channel (and therefore the covaraince between every bin in the analysis). The bin labels should make it clear as to which bin corresponds to which channel. </p>"},{"location":"part3/nonstandard/#toy-by-toy-diagnostics","title":"Toy-by-toy diagnostics","text":"<p><code>FitDiagnostics</code> can also be used to diagnose the fitting procedure in toy experiments to identify potentially problematic nuisance parameters when running the full limits/p-values. This can be done by adding the option <code>-t &lt;num toys&gt;</code>. The output file, <code>fitDiagnostics.root</code> the three <code>TTrees</code> will contain the value of the constraint fitted result in each toy, as a separate entry. It is recommended to use the following options when investigating toys to reduce the running time: <code>--toysFrequentist</code> <code>--noErrors</code> <code>--minos none</code></p> <p>The results can be plotted using the macro test/plotParametersFromToys.C</p> <pre><code>$ root -l\n.L plotParametersFromToys.C+\nplotParametersFromToys(\"fitDiagnosticsToys.root\",\"fitDiagnosticsData.root\",\"workspace.root\",\"r&lt;0\")\n</code></pre> <p>The first argument is the name of the output file from running with toys, and the second and third (optional) arguments are the name of the file containing the result from a fit to the data and the workspace (created from <code>text2workspace.py</code>). The fourth argument can be used to specify a cut string applied to one of the branches in the tree, which can be used to correlate strange behaviour with specific conditions. The output will be 2 pdf files (<code>tree_fit_(s)b.pdf</code>) and 2 ROOT files  (<code>tree_fit_(s)b.root</code>) containing canvases of the fit results of the tool. For details on the output plots, consult AN-2012/317.</p>"},{"location":"part3/nonstandard/#scaling-constraints","title":"Scaling constraints","text":"<p>It possible to scale the constraints on the nuisance parameters when converting the datacard to a workspace (see the section on physics models) with <code>text2workspace.py</code>. This can be useful for projection studies of the analysis to higher luminosities or with different assumptions about the sizes of certain systematics without changing the datacard by hand. </p> <p>We consider two kinds of scaling;  </p> <ul> <li>A constant scaling factor to scale the constraints </li> <li>A functional scale factor that depends on some other parameters in the workspace, eg a luminosity scaling parameter (as a <code>rateParam</code> affecting all processes). </li> </ul> <p>In both cases these scalings can be introduced by adding some extra options at the <code>text2workspace.py</code> step. </p> <p>To add a constant scaling factor we use the option <code>--X-rescale-nuisance</code>, eg</p> <pre><code>text2workspace.py datacard.txt --X-rescale-nuisance '[some regular expression]' 0.5\n</code></pre> <p>will create the workspace in which every nuisance parameter whose name matches the specified regular expression will have the width of the gaussian constraint scaled by a factor 0.5. </p> <p>Multiple <code>--X-rescale-nuisance</code> options can be specified to set different scalings for different nuisances (note that you actually have to write <code>--X-rescale-nuisance</code> each time as in <code>--X-rescale-nuisance 'theory.*' 0.5  --X-rescale-nuisance 'exp.*' 0.1</code>).</p> <p>To add a functional scaling factor we use the option <code>--X-nuisance-function</code>, which works in a similar way. Instead of a constant value you should specify a <code>RooFit</code> factory expression. </p> <p>A typical case would be scaling by 1/\\sqrt{L}, where L is a luminosity scale factor. For example, assuming there is some parameter in the datacard/workspace called <code>lumiscale</code>, </p> <pre><code>text2workspace.py datacard.txt --X-nuisance-function '[some regular expression]' 'expr::lumisyst(\"1/sqrt(@0)\",lumiscale[1])'\n</code></pre> <p>This factory syntax is flexible, but for our use case the typical format will be: <code>expr::[function name](\"[formula]\", [arg0], [arg1], ...)</code>. The <code>arg0</code>, <code>arg1</code> ... are represented in the formula by <code>@0</code>, <code>@1</code>,... placeholders. </p> <p>Warning</p> <p>We are playing a slight trick here with the <code>lumiscale</code> parameter. At the point at which <code>text2workspace.py</code> is building these scaling terms the <code>lumiscale</code> for the <code>rateParam</code> has not yet been created. By writing <code>lumiscale[1]</code> we are telling RooFit to create this variable with an initial value of 1, and then later this will be re-used by the <code>rateParam</code> creation. </p> <p>A similar option, <code>--X-nuisance-group-function</code>, can be used to scale whole groups of nuisances (see groups of nuisances). Instead of a regular expression just give the group name instead, </p> <pre><code>text2workspace.py datacard.txt --X-nuisance-group-function [group name] 'expr::lumisyst(\"1/sqrt(@0)\",lumiscale[1])'\n</code></pre>"},{"location":"part3/nonstandard/#nuisance-parameter-impacts","title":"Nuisance parameter impacts","text":"<p>The impact of a nuisance parameter (NP) \u03b8 on a parameter of interest (POI) \u03bc is defined as the shift \u0394\u03bc that is induced as \u03b8 is fixed and brought to its +1\u03c3 or \u22121\u03c3 post-fit values, with all other parameters profiled as normal (see JHEP 01 (2015) 069 for a description of this method). </p> <p>This is effectively a measure of the correlation between the NP and the POI, and is useful for determining which NPs have the largest effect on the POI uncertainty.</p> <p>It is possible to use the <code>FitDiagnostics</code> method of Combine with the option <code>--algo impact -P parameter</code> to calculate the impact of a particular nuisance parameter on the parameter(s) of interest. We will use the <code>combineTool.py</code> script to automate the fits (see the <code>combineTool</code> section to check out the tool.</p> <p>We will use an example workspace from the H\\rightarrow\\tau\\tau datacard,</p> <pre><code>$ cp HiggsAnalysis/CombinedLimit/data/tutorials/htt/125/htt_tt.txt .\n$ text2workspace.py htt_tt.txt -m 125\n</code></pre> <p>Calculating the impacts is done in a few stages. First we just fit for each POI, using the <code>--doInitialFit</code> option with <code>combineTool.py</code>, and adding the <code>--robustFit 1</code> option that will be passed through to Combine,</p> <pre><code>combineTool.py -M Impacts -d htt_tt.root -m 125 --doInitialFit --robustFit 1\n</code></pre> <p>Have a look at the options as for likelihood scans when using <code>robustFit 1</code>.</p> <p>Next we perform a similar scan for each nuisance parameter with the <code>--doFits</code> options,</p> <pre><code>combineTool.py -M Impacts -d htt_tt.root -m 125 --robustFit 1 --doFits\n</code></pre> <p>Note that this will run approximately 60 scans, and to speed things up the option <code>--parallel X</code> can be given to run X Combine jobs simultaneously. The batch and grid submission methods described in the combineTool for job submission section can also be used.</p> <p>Once all jobs are completed, the output can be collected and written into a json file:</p> <pre><code>combineTool.py -M Impacts -d htt_tt.root -m 125 -o impacts.json\n</code></pre> <p>A plot summarizing the nuisance parameter values and impacts can be made with <code>plotImpacts.py</code>, </p> <pre><code>plotImpacts.py -i impacts.json -o impacts\n</code></pre> <p>The first page of the output is shown below. Note that in these figures, the nuisance parameters are labelled as \\theta instead of \\nu. </p> <p></p> <p>The direction of the +1\u03c3 and -1\u03c3 impacts (i.e. when the NP is moved to its +1\u03c3 or -1\u03c3 values) on the POI indicates whether the parameter is correlated or anti-correlated with it.</p> <p>For models with multiple POIs, the Combine option <code>--redefineSignalPOIs X,Y,Z...</code> should be specified in all three of the <code>combineTool.py -M Impacts [...]</code> steps above. The final step will produce the <code>impacts.json</code> file which will contain the impacts for all the specified POIs. In the <code>plotImpacts.py</code> script, a particular POI can be specified with <code>--POI X</code>. </p> <p>Warning</p> <p>The plot also shows the best fit value of the POI at the top and its uncertainty. You may wish to allow the range to go negative (i.e using <code>--setParameterRanges</code> or <code>--rMin</code>) to avoid getting one-sided impacts!</p> <p>This script also accepts an optional json-file argument with <code>-t</code>, which can be used to provide a dictionary for renaming parameters. A simple example would be to create a file <code>rename.json</code>,</p> <pre><code>{\n  \"r\" : \"#mu\"\n}\n</code></pre> <p>that will rename the POI label on the plot.</p> <p>Info</p> <p>Since <code>combineTool</code> accepts the usual options for combine you can also generate the impacts on an Asimov or toy dataset. </p> <p>The left panel in the summary plot shows the value of (\\nu-\\nu_{0})/\\Delta_{\\nua} where \\nu and \\nu_{0} are the post and pre-fit values of the nuisance parameter and \\Delta_{\\nu} is the pre-fit uncertainty. The asymmetric error bars show the post-fit uncertainty divided by the pre-fit uncertainty meaning that parameters with error bars smaller than \\pm 1 are constrained in the fit. The pull will additionally be shown. As with the <code>diffNuisances.py</code> script, the option <code>--pullDef</code> can be used (to modify the definition of the pull that is shown). </p>"},{"location":"part3/nonstandard/#breakdown-of-uncertainties","title":"Breakdown of uncertainties","text":"<p>Often you will want to report the breakdown of your total (systematic) uncertainty on a measured parameter due to one or more groups of nuisance parameters. For example, these groups could be theory uncertainties, trigger uncertainties, ... The prodecude to do this in Combine is to sequentially freeze groups of nuisance parameters and subtract (in quadrature) from the total uncertainty. Below are the steps to do so. We will use the <code>data/tutorials/htt/125/htt_tt.txt</code> datacard for this. </p> <ol> <li>Add groups to the datacard to group nuisance parameters. Nuisance parameters not in groups will be considered as \"rest\" in the later steps. The lines should look like the following and you should add them to the end of the datacard</li> </ol> <pre><code>theory      group = QCDscale_VH QCDscale_ggH1in QCDscale_ggH2in QCDscale_qqH UEPS pdf_gg pdf_qqbar\ncalibration group = CMS_scale_j_8TeV CMS_scale_t_tautau_8TeV CMS_htt_scale_met_8TeV\nefficiency  group = CMS_eff_b_8TeV   CMS_eff_t_tt_8TeV CMS_fake_b_8TeV\n</code></pre> <ol> <li> <p>Create the workspace with <code>text2workspace.py data/tutorials/htt/125/htt_tt.txt -m 125</code>. </p> </li> <li> <p>Run a fit with all nuisance parameters floating and store the workspace in an output file - <code>combine data/tutorials/htt/125/htt_tt.root -M MultiDimFit --saveWorkspace -n htt.postfit</code></p> </li> <li> <p>Run a scan from the postfit workspace </p> </li> </ol> <pre><code>combine higgsCombinehtt.postfit.MultiDimFit.mH120.root -M MultiDimFit -n htt.total --algo grid --snapshotName MultiDimFit --setParameterRanges r=0,4\n</code></pre> <ol> <li>Run additional scans using the post-fit workspace, sequentially adding another group to the list of groups to freeze</li> </ol> <pre><code>combine higgsCombinehtt.postfit.MultiDimFit.mH120.root -M MultiDimFit --algo grid --snapshotName MultiDimFit --setParameterRanges r=0,4  --freezeNuisanceGroups theory -n htt.freeze_theory\n\ncombine higgsCombinehtt.postfit.MultiDimFit.mH120.root -M MultiDimFit --algo grid --snapshotName MultiDimFit --setParameterRanges r=0,4  --freezeNuisanceGroups theory,calibration -n htt.freeze_theory_calibration\n\ncombine higgsCombinehtt.postfit.MultiDimFit.mH120.root -M MultiDimFit --algo grid --snapshotName MultiDimFit --setParameterRanges r=0,4  --freezeNuisanceGroups theory,calibration,efficiency -n htt.freeze_theory_calibration_efficiency\n</code></pre> <ol> <li>Run one last scan freezing all of the constrained nuisance parameters (this represents the statistical uncertainty only). </li> </ol> <pre><code>combine higgsCombinehtt.postfit.MultiDimFit.mH120.root -M MultiDimFit --algo grid --snapshotName MultiDimFit --setParameterRanges r=0,4  --freezeParameters allConstrainedNuisances -n htt.freeze_all\n</code></pre> <ol> <li>Use the <code>combineTool</code> script <code>plot1DScan.py</code> to report the breakdown of uncertainties. </li> </ol> <pre><code>plot1DScan.py higgsCombinehtt.total.MultiDimFit.mH120.root --main-label \"Total Uncert.\"  --others higgsCombinehtt.freeze_theory.MultiDimFit.mH120.root:\"freeze theory\":4 higgsCombinehtt.freeze_theory_calibration.MultiDimFit.mH120.root:\"freeze theory+calibration\":7 higgsCombinehtt.freeze_theory_calibration_efficiency.MultiDimFit.mH120.root:\"freeze theory+calibration+efficiency\":2 higgsCombinehtt.freeze_all.MultiDimFit.mH120.root:\"stat only\":6  --output breakdown --y-max 10 --y-cut 40 --breakdown \"theory,calibration,efficiency,rest,stat\"\n</code></pre> <p>The final step calculates the contribution of each group of nuisance parameters as the subtraction in quadrature of each scan from the previous one. This procedure guarantees that the sum in quadrature of the individual components is the same as the total uncertainty. </p> <p>The plot below is produced, </p> <p></p> <p>Warning</p> <p>While the above procedure is guaranteed the have the effect that the sum in quadrature of the breakdown will equal the total uncertainty, the order in which you freeze the groups can make a difference due to correlations induced by the fit. You should check if the answers change significantly if changing the order and we recommend you start with the largest group (in terms of overall contribution to the uncertainty) first, working down the list in order of the size of the contribution.  </p>"},{"location":"part3/nonstandard/#channel-masking","title":"Channel Masking","text":"<p>The Combine tool has a number of features for diagnostics and plotting results of fits. It can often be useful to turn off particular channels in a combined analysis to see how constraints/shifts in parameter values can vary. It can also be helpful to plot the post-fit shapes and uncertainties of a particular channel (for example a signal region) without including the constraints from the data in that region. </p> <p>This can in some cases be achieved by removing a specific datacard when running <code>combineCards.py</code>. However, when doing so, the information of particular nuisance parameters and PDFs in that region will be lost. Instead, it is possible to mask that channel from the likelihood. This is achieved at the <code>text2Workspace</code> step using the option <code>--channel-masks</code>.</p>"},{"location":"part3/nonstandard/#example-removing-constraints-from-the-signal-region","title":"Example: removing constraints from the signal region","text":"<p>We will take the control region example from the rate parameters tutorial from data/tutorials/rate_params/.</p> <p>The first step is to combine the cards      combineCards.py signal=signal_region.txt dimuon=dimuon_control_region.txt singlemuon=singlemuon_control_region.txt &gt; datacard.txt</p> <p>Note that we use the directive <code>CHANNELNAME=CHANNEL_DATACARD.txt</code> so that the names of the channels are under our control and easier to interpret. Next, we make a workspace and tell Combine to create the parameters used to mask channels</p> <pre><code>text2workspace.py datacard.txt --channel-masks\n</code></pre> <p>Now we will try to do a fit ignoring the signal region. We can turn off the signal region by setting the corresponding channel mask parameter to 1: <code>--setParameters mask_signal=1</code>. Note that <code>text2workspace</code> has created a masking parameter for every channel with the naming scheme mask_CHANNELNAME. By default, every parameter is set to 0 so that the channel is unmasked by default.</p> <pre><code>combine datacard.root -M FitDiagnostics --saveShapes --saveWithUncertainties --setParameters mask_signal=1\n</code></pre> <p>Warning</p> <p>There will be a lot of warnings from Combine. These are safe to ignore as they are due to the s+b fit not converging. This is expected as the free signal parameter cannot be constrained because the data in the signal region is being ignored. </p> <p>We can compare the post-fit background and uncertainties with and without the signal region included by re-running with <code>--setParameters mask_signal=0</code> (or just removing that option completely). Below is a comparison of the background in the signal region with and without masking the data in the signal region. We take these from the shapes folder  shapes_fit_b/signal/total_background in the <code>fitDiagnostics.root</code> output.</p> <p></p> <p>Clearly the background shape is different and much less constrained without including the signal region, as expected. Channel masking can be used with any method in Combine.</p>"},{"location":"part3/nonstandard/#roomultipdf-conventional-bias-studies","title":"RooMultiPdf conventional bias studies","text":"<p>Several analyses in CMS use a functional form to describe the background. This functional form is fit to the data. Often however, there is some uncertainty associated with the choice of which background function to use, and this choice will impact the fit results. It is therefore often the case that in these analyses, a bias study is performed.  This study will give an indication of the size of the potential bias in the result, given a certain choice of functional form. These studies can be conducted using Combine.</p> <p>Below is an example script that will produce a workspace based on a simplified Higgs to diphoton (Hgg) analysis with a single category. It will produce the data and PDFs necessary for this example, and you can use it as a basis to construct your own studies.</p> <pre><code>void makeRooMultiPdfWorkspace(){\n\n   // Load the combine Library\n   gSystem-&gt;Load(\"libHiggsAnalysisCombinedLimit.so\");\n\n   // mass variable\n   RooRealVar mass(\"CMS_hgg_mass\",\"m_{#gamma#gamma}\",120,100,180);\n\n\n   // create 3 background pdfs\n   // 1. exponential\n   RooRealVar expo_1(\"expo_1\",\"slope of exponential\",-0.02,-0.1,-0.0001);\n   RooExponential exponential(\"exponential\",\"exponential pdf\",mass,expo_1);\n\n   // 2. polynomial with 2 parameters\n   RooRealVar poly_1(\"poly_1\",\"T1 of chebychev polynomial\",0,-3,3);\n   RooRealVar poly_2(\"poly_2\",\"T2 of chebychev polynomial\",0,-3,3);\n   RooChebychev polynomial(\"polynomial\",\"polynomial pdf\",mass,RooArgList(poly_1,poly_2));\n\n   // 3. A power law function\n   RooRealVar pow_1(\"pow_1\",\"exponent of power law\",-3,-6,-0.0001);\n   RooGenericPdf powerlaw(\"powerlaw\",\"TMath::Power(@0,@1)\",RooArgList(mass,pow_1));\n\n   // Generate some data (lets use the power lay function for it)\n   // Here we are using unbinned data, but binning the data is also fine\n   RooDataSet *data = powerlaw.generate(mass,RooFit::NumEvents(1000));\n\n   // First we fit the pdfs to the data (gives us a sensible starting value of parameters for, e.g - blind limits)\n   exponential.fitTo(*data);   // index 0\n   polynomial.fitTo(*data);   // index 1\n   powerlaw.fitTo(*data);     // index 2\n\n   // Make a plot (data is a toy dataset)\n   RooPlot *plot = mass.frame();   data-&gt;plotOn(plot);\n   exponential.plotOn(plot,RooFit::LineColor(kGreen));\n   polynomial.plotOn(plot,RooFit::LineColor(kBlue));\n   powerlaw.plotOn(plot,RooFit::LineColor(kRed));\n   plot-&gt;SetTitle(\"PDF fits to toy data\");\n   plot-&gt;Draw();\n\n   // Make a RooCategory object. This will control which of the pdfs is \"active\"\n   RooCategory cat(\"pdf_index\",\"Index of Pdf which is active\");\n\n   // Make a RooMultiPdf object. The order of the pdfs will be the order of their index, ie for below\n   // 0 == exponential\n   // 1 == polynomial\n   // 2 == powerlaw\n   RooArgList mypdfs;\n   mypdfs.add(exponential);\n   mypdfs.add(polynomial);\n   mypdfs.add(powerlaw);\n\n   RooMultiPdf multipdf(\"roomultipdf\",\"All Pdfs\",cat,mypdfs);\n   // By default the multipdf will tell combine to add 0.5 to the nll for each parameter (this is the penalty for the discrete profiling method)\n   // It can be changed with\n   //   multipdf.setCorrectionFactor(penalty)\n   // For bias-studies, this isn;t relevant however, so lets just leave the default\n\n   // As usual make an extended term for the background with _norm for freely floating yield\n   RooRealVar norm(\"roomultipdf_norm\",\"Number of background events\",1000,0,10000);\n\n   // We will also produce a signal model for the bias studies\n   RooRealVar sigma(\"sigma\",\"sigma\",1.2); sigma.setConstant(true);\n   RooRealVar MH(\"MH\",\"MH\",125); MH.setConstant(true);\n   RooGaussian signal(\"signal\",\"signal\",mass,MH,sigma);\n\n\n   // Save to a new workspace\n   TFile *fout = new TFile(\"workspace.root\",\"RECREATE\");\n   RooWorkspace wout(\"workspace\",\"workspace\");\n\n   data-&gt;SetName(\"data\");\n   wout.import(*data);\n   wout.import(cat);\n   wout.import(norm);\n   wout.import(multipdf);\n   wout.import(signal);\n   wout.Print();\n   wout.Write();\n}\n</code></pre> <p>The signal is modelled as a simple Gaussian with a width approximately that of the diphoton resolution. For the background there is a choice of 3 functions: an exponential, a power-law, and a 2nd order polynomial. This choice is accessible within Combine through the use of the RooMultiPdf object, which can switch between the functions by setting their associated indices (herein called pdf_index). This (as with all parameters in Combine) can be set via the <code>--setParameters</code> option.</p> <p>To assess the bias, one can throw toys using one function and fit with another. To do this, only a single datacard is needed: hgg_toy_datacard.txt.</p> <p>The bias studies are performed in two stages. The first is to generate toys using one of the functions, under some value of the signal strength r (or \\mu). This can be repeated for several values of r and also at different masses, but in this example the Higgs boson mass is fixed to 125 GeV. </p> <pre><code>    combine hgg_toy_datacard.txt -M GenerateOnly --setParameters pdf_index=0 --toysFrequentist -t 100 --expectSignal 1 --saveToys -m 125 --freezeParameters pdf_index\n</code></pre> <p>Warning</p> <p>It is important to freeze <code>pdf_index</code>, otherwise Combine will try to iterate over the index in the frequentist fit.</p> <p>Now we have 100 toys which, by setting <code>pdf_index=0</code>, sets the background PDF to the exponential function. This means we assume that the exponential is the true function. Note that the option <code>--toysFrequentist</code> is added; this first performs a fit of the PDF, assuming a signal strength of 1, to the data before generating the toys. This is the most obvious choice as to where to throw the toys from.</p> <p>The next step is to fit the toys under a different background PDF hypothesis. This time we set the <code>pdf_index</code> to  1, which selects the powerlaw, and run fits with the <code>FitDiagnostics</code> method, again freezing <code>pdf_index</code>. </p> <pre><code>    combine hgg_toy_datacard.txt -M FitDiagnostics  --setParameters pdf_index=1 --toysFile higgsCombineTest.GenerateOnly.mH125.123456.root  -t 100 --rMin -10 --rMax 10 --freezeParameters pdf_index --cminDefaultMinimizerStrategy=0\n</code></pre> <p>Note how we add the option <code>--cminDefaultMinimizerStrategy=0</code>. This is because we do not need the Hessian, as <code>FitDiagnostics</code> will run MINOS to get the uncertainty on <code>r</code>. If we do not do this, Minuit will think the fit failed as we have parameters (those not attached to the current PDF) for which the likelihood is flat. </p> <p>Warning</p> <p>You may get warnings about non-accurate errors such as <code>[WARNING]: Unable to determine uncertainties on all fit parameters in b-only fit</code> - These can be ignored since they are related to the free parameters of the background PDFs which are not active.</p> <p>In the output file <code>fitDiagnostics.root</code> there is a tree that contains the best fit results under the signal+background hypothesis. One measure of the bias is the pull defined as the difference between the measured value of \\mu and the generated value (here we used 1) relative to the uncertainty on \\mu. The pull distribution can be drawn and the mean provides an estimate of the pull. In this example, we are averaging the positive and negative uncertainties, but we could do something smarter if the uncertainties are very asymmetric. </p> <pre><code>root -l fitDiagnostics.root\ntree_fit_sb-&gt;Draw(\"(r-1)/(0.5*(rHiErr+rLoErr))&gt;&gt;h(20,-5,5)\")\nh-&gt;Fit(\"gaus\")\n</code></pre> <p> </p> <p>From the fitted Gaussian, we see the mean is at -1.29, which would indicate a bias of 129% of the uncertainty on mu from choosing the polynomial when the true function is an exponential.</p>"},{"location":"part3/nonstandard/#discrete-profiling","title":"Discrete profiling","text":"<p>If the <code>discrete</code> nuisance is left floating, it will be profiled by looping through the possible index values and finding the PDF that gives the best fit. This allows for the discrete profiling method to be applied for any method which involves a profiled likelihood (frequentist methods). </p> <p>Warning</p> <p>You should be careful since MINOS knows nothing about the discrete nuisances and hence estimations of uncertainties will be incorrect via MINOS. Instead, uncertainties from scans and limits will correctly account for these nuisance parameters. Currently the Bayesian methods will not properly treat the nuisance parameters, so some care should be taken when interpreting Bayesian results. </p> <p>As an example, we can peform a likelihood scan as a function of the Higgs boson signal strength in the toy Hgg datacard. By leaving the object <code>pdf_index</code> non-constant, at each point in the likelihood scan, the PDFs will be iterated over and the one that gives the lowest -2 times log-likelihood, including the correction factor c (as defined in the paper linked above) will be stored in the output tree. We can also check the scan when we fix at each PDF individually to check that the envelope is achieved. For this, you will need to include the option <code>--X-rtd REMOVE_CONSTANT_ZERO_POINT=1</code>. In this way, we can take a look at the absolute value to compare the curves, if we also include <code>--saveNLL</code>.</p> <p>For example for a full scan, you can run </p> <pre><code>    combine -M MultiDimFit -d hgg_toy_datacard.txt --algo grid --setParameterRanges r=-1,3 --cminDefaultMinimizerStrategy 0 --saveNLL -n Envelope -m 125 --setParameters myIndex=-1 --X-rtd REMOVE_CONSTANT_ZERO_POINT=1 \n</code></pre> <p>and for the individual <code>pdf_index</code> set to <code>X</code>, </p> <pre><code>    combine -M MultiDimFit -d hgg_toy_datacard.txt --algo grid --setParameterRanges r=-1,3 --cminDefaultMinimizerStrategy 0 --saveNLL --freezeParameters pdf_index --setParameters pdf_index=X -n fixed_pdf_X -m 125 --X-rtd REMOVE_CONSTANT_ZERO_POINT=1\n</code></pre> <p>for <code>X=0,1,2</code></p> <p>You can then plot the value of <code>2*(deltaNLL+nll+nll0)</code> to plot the absolute value of (twice) the negative log-likelihood, including the correction term for extra parameters in the different PDFs. </p> <p>The above output will produce the following scans. </p> <p>As expected, the curve obtained by allowing the <code>pdf_index</code> to float (labelled \"Envelope\") picks out the best function (maximum corrected likelihood) for each value of the signal strength. </p> <p>In general, the performance of Combine can be improved when using the discrete profiling method by including the option <code>--X-rtd MINIMIZER_freezeDisassociatedParams</code>. This will stop parameters not associated to the current PDF from floating in the fits. Additionally, you can  include the following options:</p> <ul> <li><code>--X-rtd MINIMIZER_multiMin_hideConstants</code>: hide the constant terms in the likelihood when recreating the minimizer</li> <li><code>--X-rtd MINIMIZER_multiMin_maskConstraints</code>: hide the constraint terms during the discrete minimization process</li> <li><code>--X-rtd MINIMIZER_multiMin_maskChannels=&lt;choice&gt;</code> mask the channels that are not needed from the NLL:<ul> <li><code>&lt;choice&gt; 1</code>: keeps unmasked all channels that are participating in the discrete minimization.</li> <li><code>&lt;choice&gt; 2</code>: keeps unmasked only the channel whose index is being scanned at the moment.</li> </ul> </li> </ul> <p>You may want to check with the Combine development team if you are using these options, as they are somewhat for expert use. </p>"},{"location":"part3/nonstandard/#roosplinend-multidimensional-splines","title":"RooSplineND multidimensional splines","text":"<p>RooSplineND can be used to interpolate from a tree of points to produce a continuous function in N-dimensions. This function can then be used as input to workspaces allowing for parametric rates/cross-sections/efficiencies. It can also be used to up-scale the resolution of likelihood scans (i.e like those produced from Combine) to produce smooth contours. </p> <p>The spline makes use of a radial basis decomposition to produce a continous N \\to 1 map (function) from M provided sample points. The function of the N variables \\vec{x}  is assumed to be of the form, </p>  f(\\vec{x}) = \\sum_{i=1}^{M}w_{i}\\phi(||\\vec{x}-\\vec{x}_{i}||),  <p>where \\phi(||\\vec{z}||) = e^{-\\frac{||\\vec{z}||}{\\epsilon^{2}}}. The distance ||.|| between two points is given by, </p>  ||\\vec{x}-\\vec{y}||  = \\sum_{j=1}^{N}(x_{j}-y_{j})^{2},  <p>if the option <code>rescale=false</code> and, </p>  ||\\vec{x}-\\vec{y}||  = \\sum_{j=1}^{N} M^{1/N} \\cdot \\left( \\frac{ x_{j}-y_{j} }{ \\mathrm{max_{i=1,M}}(x_{i,j})-\\mathrm{min_{i=1,M}}(x_{i,j}) }\\right)^{2},  <p>if the option <code>rescale=true</code>. Given the sample points, it is possible to determine the weights w_{i} as the solution of the set of equations, </p>  \\sum_{i=1}^{M}w_{i}\\phi(||\\vec{x}_{j}-\\vec{x}_{i}||) = f(\\vec{x}_{j}).  <p>The solution is obtained using the <code>eigen</code> c++ package.  </p> <p>The typical constructor of the object is as follows;</p> <pre><code>RooSplineND(const char *name, const char *title, RooArgList &amp;vars, TTree *tree, const char* fName=\"f\", double eps=3., bool rescale=false, std::string cutstring=\"\" ) ;\n</code></pre> <p>where the arguments are:</p> <ul> <li><code>vars</code>: A <code>RooArgList</code> of <code>RooRealVars</code> representing the N dimensions of the spline. The length of this list determines the dimension N of the spline. </li> <li><code>tree</code>: a TTree pointer where each entry represents a sample point used to construct the spline. The branch names must correspond to the names of the variables in <code>vars</code>. </li> <li><code>fName</code>: is a string representing the name of the branch to interpret as the target function f. </li> <li><code>eps</code> : is the value of \\epsilon and represents the width of the basis functions \\phi. </li> <li><code>rescale</code> : is an option to rescale the input sample points so that each variable has roughly the same range (see above in the definition of ||.||). </li> <li><code>cutstring</code> : a string to remove sample points from the tree. Can be any typical cut string (eg \"var1&gt;10 &amp;&amp; var2&lt;3\"). </li> </ul> <p>The object can be treated as a <code>RooAbsArg</code>; its value for the current values of the parameters is obtained as usual by using the <code>getVal()</code> method. </p> <p>Warning</p> <p>You should not include more variable branches than contained in <code>vars</code> in the tree, as the spline will interpret them as additional sample points. You will get a warning if there are two nearby points in the input samples and this will cause a failure in determining the weights. If you cannot create a reduced tree, you can remove entries by using the <code>cutstring</code>. </p> <p>The following script is an example that produces a 2D spline (<code>N=2</code>) from a set of 400 points (<code>M=400</code>)  generated from a function. </p> <pre><code>void splinend(){\n   // library containing the RooSplineND \n   gSystem-&gt;Load(\"libHiggsAnalysisCombinedLimit.so\");\n\n   TTree *tree = new TTree(\"tree_vals\",\"tree_vals\");\n   float xb,yb,fb;\n\n   tree-&gt;Branch(\"f\",&amp;fb,\"f/F\");\n   tree-&gt;Branch(\"x\",&amp;xb,\"x/F\");\n   tree-&gt;Branch(\"y\",&amp;yb,\"y/F\");\n\n   TRandom3 *r = new TRandom3();\n   int nentries = 20; // just use a regular grid of 20x20=400 points\n\n   double xmin = -3.2;\n   double xmax = 3.2;\n   double ymin = -3.2;\n   double ymax = 3.2;\n\n   for (int n=0;n&lt;nentries;n++){\n    for (int k=0;k&lt;nentries;k++){\n\n      xb=xmin+n*((xmax-xmin)/nentries);\n      yb=ymin+k*((ymax-ymin)/nentries);\n      // Gaussian * cosine function radial in \"F(x^2+y^2)\"\n      double R = (xb*xb)+(yb*yb);\n      fb = 0.1*TMath::Exp(-1*(R)/9)*TMath::Cos(2.5*TMath::Sqrt(R));\n      tree-&gt;Fill();\n     }\n   }\n\n   // 2D graph of points in tree\n   TGraph2D *p0 = new TGraph2D();\n   p0-&gt;SetMarkerSize(0.8);\n   p0-&gt;SetMarkerStyle(20);\n\n   int c0=0;\n   for (int p=0;p&lt;tree-&gt;GetEntries();p++){\n        tree-&gt;GetEntry(p);\n        p0-&gt;SetPoint(c0,xb,yb,fb);\n        c0++;\n        }\n\n\n   // ------------------------------ THIS IS WHERE WE BUILD THE SPLINE ------------------------ //\n   // Create 2 Real-vars, one for each of the parameters of the spline \n   // The variables MUST be named the same as the corresponding branches in the tree\n   RooRealVar x(\"x\",\"x\",0.1,xmin,xmax); \n   RooRealVar y(\"y\",\"y\",0.1,ymin,ymax);\n\n\n   // And the spline - arguments are \n   // Required -&gt;   name, title, arglist of dependants, input tree, \n   // Optional -&gt;  function branch name, interpolation width (tunable parameter), rescale Axis bool, cutstring \n   // The tunable parameter gives the radial basis a \"width\", over which the interpolation will be effectively taken \n\n   // the reascale Axis bool (if true) will first try to rescale the points so that they are of order 1 in range\n   // This can be helpful if for example one dimension is in much larger units than another.\n\n   // The cutstring is just a ROOT string which can be used to apply cuts to the tree in case only a sub-set of the points should be used \n\n   RooArgList args(x,y);\n   RooSplineND *spline = new RooSplineND(\"spline\",\"spline\",args,tree,\"f\",1,true);\n      // ----------------------------------------------------------------------------------------- //\n\n\n   //TGraph *gr = spline-&gt;getGraph(\"x\",0.1); // Return 1D graph. Will be a slice of the spline for fixed y generated at steps of 0.1\n\n   // Plot the 2D spline \n   TGraph2D *gr = new TGraph2D();\n   int pt = 0;\n   for (double xx=xmin;xx&lt;xmax;xx+=0.1){\n     for (double yy=xmin;yy&lt;ymax;yy+=0.1){\n        x.setVal(xx);\n        y.setVal(yy);\n        gr-&gt;SetPoint(pt,xx,yy,spline-&gt;getVal());\n        pt++;\n     }\n   }\n\n   gr-&gt;SetTitle(\"\");\n\n   gr-&gt;SetLineColor(1);\n   //p0-&gt;SetTitle(\"0.1 exp(-(x{^2}+y{^2})/9) #times Cos(2.5#sqrt{x^{2}+y^{2}})\");\n   gr-&gt;Draw(\"surf\");\n   gr-&gt;GetXaxis()-&gt;SetTitle(\"x\");\n   gr-&gt;GetYaxis()-&gt;SetTitle(\"y\");\n   p0-&gt;Draw(\"Pcolsame\");\n\n   //p0-&gt;Draw(\"surfsame\");\n   TLegend *leg = new TLegend(0.2,0.82,0.82,0.98);\n   leg-&gt;SetFillColor(0);\n   leg-&gt;AddEntry(p0,\"0.1 exp(-(x{^2}+y{^2})/9) #times Cos(2.5#sqrt{x^{2}+y^{2}})\",\"p\");\n   leg-&gt;AddEntry(gr,\"RooSplineND (N=2) interpolation\",\"L\");\n   leg-&gt;Draw();\n}\n</code></pre> <p>Running the script will produce the following plot. The plot shows the sampled points and the spline produced from them.</p> <p> </p>"},{"location":"part3/nonstandard/#rooparametrichist-gamman-for-shapes","title":"RooParametricHist gammaN for shapes","text":"<p>Currently, there is no straightforward implementation of using per-bin gmN-like uncertainties with shape (histogram) analyses. Instead, it is possible to tie control regions (written as datacards) with the signal region using three methods. </p> <p>For analyses that take the normalization of some process from a control region, it is possible to use either lnU or rateParam directives to float the normalization in a correlated way of some process between two regions. Instead if each bin is intended to be determined via a control region, one can use a number of <code>RooFit</code> histogram PDFs/functions to accomplish this. The example below shows a simple implementation of a RooParametricHist to achieve this.</p> <p>Copy the script below into a file called <code>examplews.C</code> and create the input workspace using <code>root -l examplews.C</code>...</p> <pre><code>void examplews(){\n    // As usual, load the combine library to get access to the RooParametricHist\n    gSystem-&gt;Load(\"libHiggsAnalysisCombinedLimit.so\");\n\n    // Output file and workspace\n    TFile *fOut = new TFile(\"param_ws.root\",\"RECREATE\");\n    RooWorkspace wspace(\"wspace\",\"wspace\");\n\n    // better to create the bins rather than use the \"nbins,min,max\" to avoid spurious warning about adding bins with different \n    // ranges in combine - see https://root-forum.cern.ch/t/attempt-to-divide-histograms-with-different-bin-limits/17624/3 for why!\n    const int nbins = 4; \n    double xmin=200.;\n    double xmax=1000.;\n    double xbins[5] = {200.,400.,600.,800.,1000.};\n\n    // A search in a MET tail, define MET as our variable\n\n    double xmin=200.;\n    double xmax=1000.;\n\n    RooRealVar met(\"met\",\"E_{T}^{miss}\",200,xmin,xmax);\n    RooArgList vars(met);\n\n    // better to create the bins rather than use the \"nbins,min,max\" to avoid spurious warning about adding bins with different \n    // ranges in combine - see https://root-forum.cern.ch/t/attempt-to-divide-histograms-with-different-bin-limits/17624/3 for why!\n    double xbins[5] = {200.,400.,600.,800.,1000.};\n    // ---------------------------- SIGNAL REGION -------------------------------------------------------------------//\n    // Make a dataset, this will be just four bins in MET.\n    // its easiest to make this from a histogram. Set the contents to \"somehting\"\n    TH1F data_th1(\"data_obs_SR\",\"Data observed in signal region\",nbins,xbins);\n\n    data_th1.SetBinContent(1,100);\n    data_th1.SetBinContent(2,50);\n    data_th1.SetBinContent(3,25);\n    data_th1.SetBinContent(4,10);\n    RooDataHist data_hist(\"data_obs_SR\",\"Data observed\",vars,&amp;data_th1);\n    wspace.import(data_hist);\n\n    // In the signal region, our background process will be freely floating,\n    // Create one parameter per bin representing the yield. (note of course we can have multiple processes like this)\n    RooRealVar bin1(\"bkg_SR_bin1\",\"Background yield in signal region, bin 1\",100,0,500);\n    RooRealVar bin2(\"bkg_SR_bin2\",\"Background yield in signal region, bin 2\",50,0,500);\n    RooRealVar bin3(\"bkg_SR_bin3\",\"Background yield in signal region, bin 3\",25,0,500);\n    RooRealVar bin4(\"bkg_SR_bin4\",\"Background yield in signal region, bin 4\",10,0,500);\n    RooArgList bkg_SR_bins;\n    bkg_SR_bins.add(bin1);\n    bkg_SR_bins.add(bin2);\n    bkg_SR_bins.add(bin3);\n    bkg_SR_bins.add(bin4);\n\n    // Create a RooParametericHist which contains those yields, last argument is just for the binning,\n    // can use the data TH1 for that\n    RooParametricHist p_bkg(\"bkg_SR\", \"Background PDF in signal region\",met,bkg_SR_bins,data_th1);\n    // Always include a _norm term which should be the sum of the yields (thats how combine likes to play with pdfs)\n    RooAddition p_bkg_norm(\"bkg_SR_norm\",\"Total Number of events from background in signal region\",bkg_SR_bins);\n\n    // Every signal region needs a signal\n    TH1F signal_th1(\"signal_SR\",\"Signal expected in signal region\",nbins,xbins);\n\n    signal_th1.SetBinContent(1,1);\n    signal_th1.SetBinContent(2,2);\n    signal_th1.SetBinContent(3,3);\n    signal_th1.SetBinContent(4,8);\n    RooDataHist signal_hist(\"signal\",\"Data observed\",vars,&amp;signal_th1);\n    wspace.import(signal_hist);\n\n    // -------------------------------------------------------------------------------------------------------------//\n    // ---------------------------- CONTROL REGION -----------------------------------------------------------------//\n    TH1F data_CRth1(\"data_obs_CR\",\"Data observed in control region\",nbins,xbins);\n\n    data_CRth1.SetBinContent(1,200);\n    data_CRth1.SetBinContent(2,100);\n    data_CRth1.SetBinContent(3,50);\n    data_CRth1.SetBinContent(4,20);\n\n    RooDataHist data_CRhist(\"data_obs_CR\",\"Data observed\",vars,&amp;data_CRth1);\n    wspace.import(data_CRhist);\n\n    // This time, the background process will be dependent on the yields of the background in the signal region.\n    // The transfer factor TF must account for acceptance/efficiency etc differences in the signal to control\n    // In this example lets assume the control region is populated by the same process decaying to clean daughters with 2xBR\n    // compared to the signal region\n\n    // NB You could have a different transfer factor for each bin represented by a completely different RooRealVar\n\n    // We can imagine that the transfer factor could be associated with some uncertainty - lets say a 1% uncertainty due to efficiency and 2% due to acceptance.\n    // We need to make these nuisance parameters ourselves and give them a nominal value of 0\n\n\n    RooRealVar efficiency(\"efficiency\", \"efficiency nuisance parameter\",0);\n    RooRealVar acceptance(\"acceptance\", \"acceptance nuisance parameter\",0);\n\n    // We would need to make the transfer factor a function of those too. Here we've assumed Log-normal effects (i.e the same as putting lnN in the CR datacard)\n    // but note that we could use any function which could be used to parameterise the effect - eg if the systematic is due to some alternate template, we could\n    // use polynomials for example.\n\n\n    RooFormulaVar TF(\"TF\",\"Trasnfer factor\",\"2*TMath::Power(1.01,@0)*TMath::Power(1.02,@1)\",RooArgList(efficiency,acceptance) );\n\n    // Finally, we need to make each bin of the background in the control region a function of the background in the signal and the transfer factor\n    // N_CR = N_SR x TF\n\n    RooFormulaVar CRbin1(\"bkg_CR_bin1\",\"Background yield in control region, bin 1\",\"@0*@1\",RooArgList(TF,bin1));\n    RooFormulaVar CRbin2(\"bkg_CR_bin2\",\"Background yield in control region, bin 2\",\"@0*@1\",RooArgList(TF,bin2));\n    RooFormulaVar CRbin3(\"bkg_CR_bin3\",\"Background yield in control region, bin 3\",\"@0*@1\",RooArgList(TF,bin3));\n    RooFormulaVar CRbin4(\"bkg_CR_bin4\",\"Background yield in control region, bin 4\",\"@0*@1\",RooArgList(TF,bin4));\n\n    RooArgList bkg_CR_bins;\n    bkg_CR_bins.add(CRbin1);\n    bkg_CR_bins.add(CRbin2);\n    bkg_CR_bins.add(CRbin3);\n    bkg_CR_bins.add(CRbin4);\n    RooParametricHist p_CRbkg(\"bkg_CR\", \"Background PDF in control region\",met,bkg_CR_bins,data_th1);\n    RooAddition p_CRbkg_norm(\"bkg_CR_norm\",\"Total Number of events from background in control region\",bkg_CR_bins);\n    // -------------------------------------------------------------------------------------------------------------//\n\n\n    // we can also use the standard interpolation from combine by providing alternative shapes (as RooDataHists)\n    // here we're adding two of them (JES and ISR)\n    TH1F background_up(\"tbkg_CR_JESUp\",\"\",nbins,xbins);\n    background_up.SetBinContent(1,CRbin1.getVal()*1.01);\n    background_up.SetBinContent(2,CRbin2.getVal()*1.02);\n    background_up.SetBinContent(3,CRbin3.getVal()*1.03);\n    background_up.SetBinContent(4,CRbin4.getVal()*1.04);\n    RooDataHist bkg_CRhist_sysUp(\"bkg_CR_JESUp\",\"Bkg sys up\",vars,&amp;background_up);\n    wspace.import(bkg_CRhist_sysUp);\n\n    TH1F background_down(\"bkg_CR_JESDown\",\"\",nbins,xbins);\n    background_down.SetBinContent(1,CRbin1.getVal()*0.90);\n    background_down.SetBinContent(2,CRbin2.getVal()*0.98);\n    background_down.SetBinContent(3,CRbin3.getVal()*0.97);\n    background_down.SetBinContent(4,CRbin4.getVal()*0.96);\n    RooDataHist bkg_CRhist_sysDown(\"bkg_CR_JESDown\",\"Bkg sys down\",vars,&amp;background_down);\n    wspace.import(bkg_CRhist_sysDown);\n\n    TH1F background_2up(\"tbkg_CR_ISRUp\",\"\",nbins,xbins);\n    background_2up.SetBinContent(1,CRbin1.getVal()*0.85);\n    background_2up.SetBinContent(2,CRbin2.getVal()*0.9);\n    background_2up.SetBinContent(3,CRbin3.getVal()*0.95);\n    background_2up.SetBinContent(4,CRbin4.getVal()*0.99);\n    RooDataHist bkg_CRhist_sys2Up(\"bkg_CR_ISRUp\",\"Bkg sys 2up\",vars,&amp;background_2up);\n    wspace.import(bkg_CRhist_sys2Up);\n\n    TH1F background_2down(\"bkg_CR_ISRDown\",\"\",nbins,xbins);\n    background_2down.SetBinContent(1,CRbin1.getVal()*1.15);\n    background_2down.SetBinContent(2,CRbin2.getVal()*1.1);\n    background_2down.SetBinContent(3,CRbin3.getVal()*1.05);\n    background_2down.SetBinContent(4,CRbin4.getVal()*1.01);\n    RooDataHist bkg_CRhist_sys2Down(\"bkg_CR_ISRDown\",\"Bkg sys 2down\",vars,&amp;background_2down);\n    wspace.import(bkg_CRhist_sys2Down);\n\n    // import the pdfs\n    wspace.import(p_bkg);\n    wspace.import(p_bkg_norm,RooFit::RecycleConflictNodes());\n    wspace.import(p_CRbkg);\n    wspace.import(p_CRbkg_norm,RooFit::RecycleConflictNodes());\n    fOut-&gt;cd();\n    wspace.Write();\n\n    // Clean up\n    fOut-&gt;Close();\n    fOut-&gt;Delete();\n\n\n}\n</code></pre> <p>We will now discuss what the script is doing. First, the observable for the search is the missing energy, so we create a parameter to represent this observable.</p> <pre><code>   RooRealVar met(\"met\",\"E_{T}^{miss}\",xmin,xmax);\n</code></pre> <p>The following lines create a freely floating parameter for each of our bins (in this example, there are only 4 bins, defined for our observable <code>met</code>).</p> <pre><code>   RooRealVar bin1(\"bkg_SR_bin1\",\"Background yield in signal region, bin 1\",100,0,500);\n   RooRealVar bin2(\"bkg_SR_bin2\",\"Background yield in signal region, bin 2\",50,0,500);\n   RooRealVar bin3(\"bkg_SR_bin3\",\"Background yield in signal region, bin 3\",25,0,500);\n   RooRealVar bin4(\"bkg_SR_bin4\",\"Background yield in signal region, bin 4\",10,0,500);\n\n   RooArgList bkg_SR_bins;\n   bkg_SR_bins.add(bin1);\n   bkg_SR_bins.add(bin2);\n   bkg_SR_bins.add(bin3);\n   bkg_SR_bins.add(bin4);\n</code></pre> <p>They are put into a list so that we can create a <code>RooParametricHist</code> and its normalisation from that list </p> <pre><code>  RooParametricHist p_bkg(\"bkg_SR\", \"Background PDF in signal region\",met,bkg_SR_bins,data_th1);\n\n  RooAddition p_bkg_norm(\"bkg_SR_norm\",\"Total Number of events from background in signal region\",bkg_SR_bins);\n</code></pre> <p>For the control region, the background process will be dependent on the yields of the background in the signal region using a transfer factor. The transfer factor <code>TF</code> must account for acceptance/efficiency/etc differences between the signal region and the control regions. </p> <p>In this example we will assume the control region is populated by the same process decaying to a different final state with twice as large branching fraction as the one in the signal region.</p> <p>We could imagine that the transfer factor could be associated with some uncertainty - for example a 1% uncertainty due to efficiency and a 2% uncertainty due to acceptance differences. We need to make nuisance parameters ourselves to model this, and give them a nominal value of 0.</p> <pre><code>   RooRealVar efficiency(\"efficiency\", \"efficiency nuisance parameter\",0);\n   RooRealVar acceptance(\"acceptance\", \"acceptance nuisance parameter\",0);\n</code></pre> <p>We need to make the transfer factor a function of these parameters, since variations in these uncertainties will lead to variations of the transfer factor. Here we have assumed Log-normal effects (i.e the same as putting lnN in the CR datacard), but we could use any function which could be used to parameterize the effect - for example if the systematic uncertainty is due to some alternate template, we could use polynomials.    </p> <pre><code>   RooFormulaVar TF(\"TF\",\"Trasnfer factor\",\"2*TMath::Power(1.01,@0)*TMath::Power(1.02,@1)\",RooArgList(efficiency,acceptance) );\n</code></pre> <p>Then, we need to make each bin of the background in the control region a function of the background in the signal region and the transfer factor - i.e $N_{CR} = N_{SR} \\times TF $. </p> <pre><code>   RooFormulaVar CRbin1(\"bkg_CR_bin1\",\"Background yield in control region, bin 1\",\"@0*@1\",RooArgList(TF,bin1));\n   RooFormulaVar CRbin2(\"bkg_CR_bin2\",\"Background yield in control region, bin 2\",\"@0*@1\",RooArgList(TF,bin2));\n   RooFormulaVar CRbin3(\"bkg_CR_bin3\",\"Background yield in control region, bin 3\",\"@0*@1\",RooArgList(TF,bin3));\n   RooFormulaVar CRbin4(\"bkg_CR_bin4\",\"Background yield in control region, bin 4\",\"@0*@1\",RooArgList(TF,bin4));\n</code></pre> <p>As before, we also need to create the <code>RooParametricHist</code> for this process in the control region but this time the bin yields will be the <code>RooFormulaVars</code> we just created instead of freely floating parameters. </p> <pre><code>   RooArgList bkg_CR_bins;\n   bkg_CR_bins.add(CRbin1);\n   bkg_CR_bins.add(CRbin2);\n   bkg_CR_bins.add(CRbin3);\n   bkg_CR_bins.add(CRbin4);\n\n   RooParametricHist p_CRbkg(\"bkg_CR\", \"Background PDF in control region\",met,bkg_CR_bins,data_th1);\n   RooAddition p_CRbkg_norm(\"bkg_CR_norm\",\"Total Number of events from background in control region\",bkg_CR_bins);\n</code></pre> <p>Finally, we can also create alternative shape variations (Up/Down) that can be fed to Combine as we do with <code>TH1</code> or <code>RooDataHist</code> type workspaces. These need  to be of type <code>RooDataHist</code>. The example below is for a Jet Energy Scale type shape uncertainty. </p> <pre><code>   TH1F background_up(\"tbkg_CR_JESUp\",\"\",nbins,xbins);\n   background_up.SetBinContent(1,CRbin1.getVal()*1.01);\n   background_up.SetBinContent(2,CRbin2.getVal()*1.02);\n   background_up.SetBinContent(3,CRbin3.getVal()*1.03);\n   background_up.SetBinContent(4,CRbin4.getVal()*1.04);\n   RooDataHist bkg_CRhist_sysUp(\"bkg_CR_JESUp\",\"Bkg sys up\",vars,&amp;background_up);\n   wspace.import(bkg_CRhist_sysUp);\n\n   TH1F background_down(\"bkg_CR_JESDown\",\"\",nbins,xbins);\n   background_down.SetBinContent(1,CRbin1.getVal()*0.90);\n   background_down.SetBinContent(2,CRbin2.getVal()*0.98);\n   background_down.SetBinContent(3,CRbin3.getVal()*0.97);\n   background_down.SetBinContent(4,CRbin4.getVal()*0.96);\n   RooDataHist bkg_CRhist_sysDown(\"bkg_CR_JESDown\",\"Bkg sys down\",vars,&amp;background_down);\n   wspace.import(bkg_CRhist_sysDown);\n</code></pre> <p>Below are datacards (for signal and control regions) which can be used in conjunction with the workspace built above. In order to \"use\" the control region, simply combine the two cards as usual using <code>combineCards.py</code>.</p> <pre><code>Signal Region Datacard -- signal category\n\nimax * number of bins\njmax * number of processes minus 1\nkmax * number of nuisance parameters\n\n-------------------------------------------------------------------------------------------------------------------------------------------\n\nshapes data_obs    signal   param_ws.root wspace:data_obs_SR \nshapes background  signal   param_ws.root wspace:bkg_SR   # the background model pdf which is freely floating, note other backgrounds can be added as usual\nshapes signal      signal   param_ws.root wspace:signal\n\n-------------------------------------------------------------------------------------------------------------------------------------------\nbin         signal\nobservation  -1 \n-------------------------------------------------------------------------------------------------------------------------------------------\n# background rate must be taken from _norm param x 1      \nbin                 signal      signal  \nprocess             background  signal  \nprocess             1            0      \nrate               1            -1      \n-------------------------------------------------------------------------------------------------------------------------------------------\n# Normal uncertainties in the signal region \nlumi_8TeV         lnN    -           1.026 \n-------------------------------------------------------------------------------------------------------------------------------------------\n# free floating parameters, we do not need to declare them, but its a good idea to \nbkg_SR_bin1  flatParam \nbkg_SR_bin2  flatParam \nbkg_SR_bin3  flatParam \nbkg_SR_bin4  flatParam \n</code></pre> <pre><code>Control Region Datacard -- control category\n\nimax * number of bins\njmax * number of processes minus 1\nkmax * number of nuisance parameters\n\n-------------------------------------------------------------------------------------------------------------------------------------------\n\nshapes data_obs    control   param_ws.root wspace:data_obs_CR \nshapes background  control   param_ws.root wspace:bkg_CR  wspace:bkg_CR_$SYSTEMATIC # the background model pdf which is dependant on that in the SR, note other backgrounds can be added as usual\n\n-------------------------------------------------------------------------------------------------------------------------------------------\nbin         control\nobservation  -1 \n-------------------------------------------------------------------------------------------------------------------------------------------\n# background rate must be taken from _norm param x 1 \nbin                 control     \nprocess             background  \nprocess             1           \nrate                1                   \n-------------------------------------------------------------------------------------------------------------------------------------------\n\nJES shape 1 \nISR shape 1 \nefficiency param 0 1\nacceptance param 0 1\n\n</code></pre> <p>Note that for the control region, our nuisance parameters appear as <code>param</code> types, so that Combine will correctly constrain them.  </p> <p>If we combine the two cards and fit the result with <code>-M MultiDimFit -v 3</code> we can see that the parameters that give the rate of background in each bin of the signal region, along with the nuisance parameters and signal strength, are determined by the fit - i.e we have properly included the constraint from the control region, just as with the 1-bin <code>gmN</code>. </p> <pre><code>acceptance    = 0.00374312   +/-  0.964632  (limited)\nbkg_SR_bin1   = 99.9922  +/-  5.92062   (limited)\nbkg_SR_bin2   = 49.9951  +/-  4.13535   (limited)\nbkg_SR_bin3   = 24.9915  +/-  2.9267    (limited)\nbkg_SR_bin4   = 9.96478  +/-  2.1348    (limited)\nefficiency    = 0.00109195   +/-  0.979334  (limited)\nlumi_8TeV     = -0.0025911   +/-  0.994458\nr     = 0.00716347   +/-  12.513    (limited)\n</code></pre> <p>The example given here is extremely basic and it should be noted that additional complexity in the transfer factors, as well as additional uncertainties/backgrounds etc in the cards are, as always, supported.</p> <p>Danger</p> <p>If trying to implement parametric uncertainties in this setup (eg on transfer factors) that are correlated with other channels and implemented separately, you MUST normalize the uncertainty effect so that the datacard line can read <code>param name X 1</code>. That is, the uncertainty on this parameter must be 1. Without this, there will be inconsistency with other nuisances of the same name in other channels implemented as shape or lnN.</p>"},{"location":"part3/nonstandard/#look-elsewhere-effect-for-one-parameter","title":"Look-elsewhere effect for one parameter","text":"<p>In case you see an excess somewhere in your analysis, you can evaluate the look-elsewhere effect (LEE) of that excess. For an explanation of the LEE, take a look at the CMS Statistics Committee Twiki here. </p> <p>To calculate the look-elsewhere effect for a single parameter (in this case the mass of the resonance), you can follow the instructions below. Note that these instructions assume you have a workspace that is parametric in your resonance mass m, otherwise you need to fit each background toy with separate workspaces. We will assume the local significance for your excess is \\sigma. </p> <ul> <li> <p>Generate background-only toys  <code>combine ws.root -M GenerateOnly --toysFrequentist -m 16.5 -t 100 --saveToys --expectSignal=0</code>. The output will be something like <code>higgsCombineTest.GenerateOnly.mH16.5.123456.root</code>.</p> </li> <li> <p>For each toy, calculate the significance for a predefined range (e.g m\\in [10,35] GeV) in steps suitable to the resolution (e.g. 1 GeV). For  <code>toy_1</code> the procedure would be: <code>for i in $(seq 10 35); do combine ws.root -M Significance --redefineSignalPOI r --freezeParameters MH --setParameter MH=$i -n $i -D higgsCombineTest.GenerateOnly.mH16.5.123456.root:toys/toy_1</code>. Calculate the maximum significance over all of these mass points - call this \\sigma_{max}.</p> </li> <li> <p>Count how many toys have a maximum significance larger than the local one for your observed excess. This fraction of toys with \\sigma_{max}&gt;\\sigma is the global p-value. </p> </li> </ul> <p>You can find more tutorials on the LEE here</p>"},{"location":"part3/regularisation/","title":"Unfolding &amp; regularization","text":"<p>This section details how to perform an unfolded cross-section measurement, including regularization, within Combine. </p> <p>There are many resources available that describe unfolding, including when to use it (or not), and what the common issues surrounding it are. For CMS users, useful summary is available in the CMS Statistics Committee pages on unfolding. You can also  find an overview of unfolding and its usage in Combine in these slides.</p> <p>The basic idea behind the unfolding technique is to describe smearing introduced through the reconstruction (e.g. of the particle energy) in a given truth level bin x_{i} through a linear relationship with the effects in the nearby truth-bins. We can make statements about the probability p_{j} that the event falling in the truth bin x_{i} is reconstructed in the bin y_{i} via the linear relationship,</p>  y_{obs} = \\tilde{\\boldsymbol{R}}\\cdot x_{true} + b  <p>or, if the truth bins are expressed relative to some particular model, we use the usual signal strength terminology, </p>  y_{obs} = \\boldsymbol{R}\\cdot \\mu + b  <p>Unfolding aims to find the distribution at truth level x, given the observations y at reco-level.</p>"},{"location":"part3/regularisation/#likelihood-based-unfolding","title":"Likelihood-based unfolding","text":"<p>Since Combine has access to the full likelihood for any analysis written in the usual datacard format, we will use likelihood-based unfolding  throughout - for other approaches, there are many other tools available (eg <code>RooUnfold</code> or <code>TUnfold</code>), which can be used instead. </p> <p>The benefits of the likelihood-based approach are that, </p> <ul> <li>Background subtraction is accounted for directly in the likelihood</li> <li>Systematic uncertainties are accounted for directly during the unfolding as nuisance parameters</li> <li>We can profile the nuisance parameters during the unfolding to make the most of the data available </li> </ul> <p>In practice, one must construct the response matrix and unroll it in the reconstructed bins:</p> <ul> <li>First, one derives the truth distribution, e.g. after the generator-level selection only, x_{i}.</li> <li>Each reconstructed bin (e.g. each datacard) should describe the contribution from each truth bin - this is how Combine knows about the response matrix \\boldsymbol{R}  and folds in the acceptance/efficiency effects as usual.</li> <li>The out-of-acceptance contributions can also be included in the above.</li> </ul> <p>The model we use for this is then just the usual <code>PhysicsModel:multiSignalModel</code>, where each signal refers to a particular truth level bin. The results can be extracted through a  simple maximum-likelihood fit with, </p> <pre><code>    text2workspace.py -m 125 --X-allow-no-background -o datacard.root datacard.txt\n       -P HiggsAnalysis.CombinedLimit.PhysicsModel:multiSignalModel --PO map='.*GenBin0.*:r_Bin0[1,-1,20]' --PO map='.*GenBin1.*:r_Bin1[1,-1,20]' --PO map='.*GenBin2.*:r_Bin2[1,-1,20]' --PO map='.*GenBin3.*:r_Bin3[1,-1,20]' --PO map='.*GenBin4.*:r_Bin4[1,-1,20]'\n\n    combine -M MultiDimFit --setParameters=r_Bin0=1,r_Bin1=1,r_Bin2=1,r_Bin3=1,r_Bin4=1 -t -1 -m 125 datacard.root\n    combine -M MultiDimFit --setParameters=r_Bin0=1,r_Bin1=1,r_Bin2=1,r_Bin3=1,r_Bin4=1 -t -1 -m 125 --algo=grid --points=100 -P r_Bin1 --setParameterRanges r_Bin1=0.5,1.5 --floatOtherPOIs=1 datacard.root\n</code></pre> <p>Notice that one can also perform the so called bin-by-bin unfolding (though it is strongly discouraged, except for testing) with, </p> <pre><code>    text2workspace.py -m 125 --X-allow-no-background -o datacard.root datacard.txt\n      -P HiggsAnalysis.CombinedLimit.PhysicsModel:multiSignalModel --PO map='.*RecoBin0.*:r_Bin0[1,-1,20]' --PO map='.*RecoBin1.*:r_Bin1[1,-1,20]' --PO map='.*RecoBin2.*:r_Bin2[1,-1,20]' --PO map='.*RecoBin3.*:r_Bin3[1,-1,20]' --PO map='.*RecoBin4.*:r_Bin4[1,-1,20]'\n</code></pre> <p>Nuisance parameters can be added to the likelihood function and profiled in the usual way via the datacards. Theory uncertainties on the inclusive cross section are typically not included in unfolded measurements.</p> <p>The figure below shows a comparison of likelihood-based unfolding and a least-squares based unfolding as implemented in <code>RooUnfold</code>. </p> Show comparison <p></p>"},{"location":"part3/regularisation/#regularization","title":"Regularization","text":"<p>The main difference with respect to other models with multiple signal contributions is the introduction of Regularization, which is used to stabilize the unfolding process. </p> <p>An example of unfolding in Combine with and without regularization, can be found under  data/tutorials/regularization. </p> <p>Running <code>python createWs.py [-r]</code> will create a simple datacard and perform a fit both with and without including regularization.</p> <p>The simplest way to introduce regularization in the likelihood based approach, is to apply a penalty term, which  depends on the values of the truth bins, in the likelihood function (so-called Tikhonov regularization):</p>  -2\\ln L = -2\\ln L + P(\\vec{x})   <p>Here, P is a linear operator. There are two different approaches that are supported to construct P. If you run <code>python makeModel.py</code>, you will create a more complex datacard with the two regularization schemes implemented. You will need  to uncomment the relevant sections of code to activate <code>SVD</code> or <code>TUnfold</code>-type regularization.</p> <p>Warning</p> <p>When using any unfolding method with regularization, you must perform studies of the potential bias/coverage properties introduced through the </p> <p>inclusion of regularization, and how strong the associated regularization is. Advice on this can be found in the CMS Statistics Committee pages. </p>"},{"location":"part3/regularisation/#singular-value-decomposition-svd","title":"Singular Value Decomposition (SVD)","text":"<p>In the SVD approach - as described in the SVD paper - the penalty term is constructed directly based on the strengths (\\vec{\\mu}=\\{\\mu_{i}\\}_{i=1}^{N}), </p>  P = \\tau\\left| A\\cdot \\vec{\\mu} \\right|^{2},  <p>where A is typically the discrete curvature matrix, with </p>  A =  \\begin{bmatrix}  1 &amp; -1 &amp; ... \\\\ 1 &amp; -2 &amp; 1 &amp;  ... \\\\ ...  \\end{bmatrix}  <p>Penalty terms on the derivatives can also be included. Such a penalty term is included by modifying the likelihood to include one constraint for each  row of the product A\\cdot\\vec{\\mu}, by including them as lines in the datacard of the form, </p> <pre><code>    name constr formula dependents delta\n</code></pre> <p>where the regularization strength is \\delta=\\frac{1}{\\sqrt{\\tau}} and can either be a fixed value (e.g. by directly putting <code>0.01</code>) or as  a modifiable parameter with e.g. <code>delta[0.01]</code>. </p> <p>For example, for 3 bins and a regularization strength of 0.03, the first line would be </p> <pre><code>    name constr @0-2*@2+@1 r_Bin0,r_Bin1,r_Bin2 0.03\n</code></pre> <p>Alternative valid syntaxes are  </p> <pre><code>    constr1 constr r_bin0-r_bin1 0.01\n    constr1 constr r_bin0-r_bin1 delta[0.01]\n    constr1 constr r_bin0+r_bin1 r_bin0,r_bin1 0.01\n    constr1 constr r_bin0+r_bin1 {r_bin0,r_bin1} delta[0.01]\n</code></pre> <p>The figure below shows an example unfolding using the \"SVD regularization\" approach with the least squares method (as implemented by <code>RooUnfold</code>) and implemented as a penalty term added to the likelihood using the maximum likelihood approach in Combine.</p> Show comparison <p></p>"},{"location":"part3/regularisation/#tunfold-method","title":"TUnfold method","text":"<p>The Tikhonov regularization as implemented in <code>TUnfold</code> uses the MC information, or rather the density prediction, as a bias vector.  In order to give this information to Combine, a single datacard for each reconstruction-level bin needs to be produced, so that we have access to the proper normalization terms during the minimization. In this case the bias vector is \\vec{x}_{obs}-\\vec{x}_{true} </p> <p>Then one can write a constraint term in the datacard via, for example,</p> <pre><code>    constr1 constr (r_Bin0-1.)*(shapeSig_GenBin0_RecoBin0__norm+shapeSig_GenBin0_RecoBin1__norm+shapeSig_GenBin0_RecoBin2__norm+shapeSig_GenBin0_RecoBin3__norm+shapeSig_GenBin0_RecoBin4__norm)+(r_Bin2-1.)*(shapeSig_GenBin2_RecoBin0__norm+shapeSig_GenBin2_RecoBin1__norm+shapeSig_GenBin2_RecoBin2__norm+shapeSig_GenBin2_RecoBin3__norm+shapeSig_GenBin2_RecoBin4__norm)-2*(r_Bin1-1.)*(shapeSig_GenBin1_RecoBin0__norm+shapeSig_GenBin1_RecoBin1__norm+shapeSig_GenBin1_RecoBin2__norm+shapeSig_GenBin1_RecoBin3__norm+shapeSig_GenBin1_RecoBin4__norm) {r_Bin0,r_Bin1,r_Bin2,shapeSig_GenBin1_RecoBin0__norm,shapeSig_GenBin0_RecoBin0__norm,shapeSig_GenBin2_RecoBin0__norm,shapeSig_GenBin1_RecoBin1__norm,shapeSig_GenBin0_RecoBin1__norm,shapeSig_GenBin2_RecoBin1__norm,shapeSig_GenBin1_RecoBin2__norm,shapeSig_GenBin0_RecoBin2__norm,shapeSig_GenBin2_RecoBin2__norm,shapeSig_GenBin1_RecoBin3__norm,shapeSig_GenBin0_RecoBin3__norm,shapeSig_GenBin2_RecoBin3__norm,shapeSig_GenBin1_RecoBin4__norm,shapeSig_GenBin0_RecoBin4__norm,shapeSig_GenBin2_RecoBin4__norm} delta[0.03]\n</code></pre>"},{"location":"part3/runningthetool/","title":"How to run the tool","text":"<p>The executable Combine provided by the package is used to invoke the tools via the command line. The statistical analysis method, as well as user settings, are also specified on the command line. To see the full list of available options, you can run:</p> <pre><code>combine --help\n</code></pre> <p>The option <code>-M</code> is used to choose the statistical evaluation method. There are several groups of statistical methods:</p> <ul> <li>Asymptotic likelihood methods:<ul> <li><code>AsymptoticLimits</code>: limits calculated according to the asymptotic formulae in arxiv:1007.1727.</li> <li><code>Significance</code>: simple profile likelihood approximation, for calculating significances.</li> </ul> </li> <li>Bayesian methods:<ul> <li><code>BayesianSimple</code>: performing a classical numerical integration (for simple models only).</li> <li><code>MarkovChainMC</code>: performing Markov Chain integration, for arbitrarily complex models.</li> </ul> </li> <li>Frequentist or hybrid bayesian-frequentist methods:<ul> <li><code>HybridNew</code>: compute modified frequentist limits, significance/p-values and confidence intervals according to several possible prescriptions with toys. </li> </ul> </li> <li>Fitting<ul> <li><code>FitDiagnostics</code>: performs maximum likelihood fits to extract the signal rate, and provides diagnostic tools such as pre- and post-fit figures and correlations</li> <li><code>MultiDimFit</code>: performs maximum likelihood fits and likelihood scans with an arbitrary number of parameters of interest.</li> </ul> </li> <li>Miscellaneous other modules that do not compute limits or confidence intervals, but use the same framework:<ul> <li><code>GoodnessOfFit</code>: perform a goodness of fit test for models including shape information. Several GoF tests are implemented.</li> <li><code>ChannelConsistencyCheck</code>: study the consistency between individual channels in a combination.</li> <li><code>GenerateOnly</code>: generate random or asimov toy datasets for use as input to other methods</li> </ul> </li> </ul> <p>The command help is organized into five parts:</p> <ul> <li>The Main options section indicates how to pass the datacard as input to the tool (<code>-d datacardName</code>), how to choose the statistical method (<code>-M MethodName</code>), and how to set the verbosity level <code>-v</code></li> <li>Under Common statistics options, options common to different statistical methods are given. Examples are <code>--cl</code>, to specify the confidence level (default is 0.95), or <code>-t</code>, to give the number of toy MC extractions required.</li> <li>The Common input-output options section includes, for example, the options to specify the mass hypothesis under study (<code>-m</code>) or to include a specific string in the output filename (<code>--name</code>). </li> <li>Common miscellaneous options.</li> <li>Further method-specific options are available for each method. By passing the method name via the <code>-M</code> option, along with <code>--help</code>, the options for that specific method are shown in addition to the common options. </li> </ul> <p>Not all the available options are discussed in this online documentation; use <code>--help</code> to get the documentation of all options.</p>"},{"location":"part3/runningthetool/#common-command-line-options","title":"Common command-line options","text":"<p>There are a number of useful command-line options that can be used to alter the model (or parameters of the model) at run time. The most commonly used, generic options, are:</p> <ul> <li> <p><code>-H</code>: first run a different, faster, algorithm (e.g. the <code>ProfileLikelihood</code> described below) to obtain an approximate indication of the limit, which will allow the precise chosen algorithm to converge more quickly. We strongly recommend to use this option when using the <code>MarkovChainMC</code>, <code>HybridNew</code> or <code>FeldmanCousins</code> calculators, unless you know in which range your limit lies and you set this range manually (the default is <code>[0, 20]</code>)</p> </li> <li> <p><code>--rMax</code>, <code>--rMin</code>: manually restrict the range of signal strengths to consider. For Bayesian limits with MCMC, a rule of thumb is that <code>rMax</code> should be 3-5 times the limit (a too small value of <code>rMax</code> will bias your limit towards low values, since you are restricting the integration range, while a too large value will bias you to higher limits)</p> </li> <li> <p><code>--setParameters name=value[,name2=value2,...]</code> sets the starting values of the parameters, useful e.g. when generating toy MC or when setting the parameters as fixed. This option supports the use of regular expressions by replacing <code>name</code> with <code>rgx{some regular expression}</code>.</p> </li> <li> <p><code>--setParameterRanges name=min,max[:name2=min2,max2:...]</code> sets the ranges of the parameters (useful e.g. for scans in <code>MultiDimFit</code>, or for Bayesian integration). This option supports the use of regular expressions by replacing <code>name</code> with <code>rgx{some regular expression}</code>.</p> </li> <li> <p><code>--redefineSignalPOIs name[,name2,...]</code> redefines the set of parameters of interest.</p> <ul> <li>If the parameters were constant in the input workspace, they are set to be floating.</li> <li>Nuisance parameters promoted to parameters of interest are removed from the list of nuisances, and thus they are not randomized in methods that randomize nuisances (e.g. <code>HybridNew</code> in non-frequentist mode, or <code>BayesianToyMC</code>, or in toy generation with <code>-t</code> but without <code>--toysFreq</code>). This does not have any impact on algorithms that do not randomize nuisance parameters (e.g. fits, <code>AsymptoticLimits</code>, or <code>HybridNew</code> in fequentist mode) or on algorithms that treat all parameters in the same way (e.g. <code>MarkovChainMC</code>).</li> <li>Note that constraint terms for the nuisances are dropped after promotion to a POI using <code>--redefineSignalPOI</code>. To produce a likelihood scan for a nuisance parameter, using <code>MultiDimFit</code> with <code>--algo grid</code>, you should instead use the <code>--parameters (-P)</code> option, which will not cause the loss of the constraint term when scanning.</li> <li>Parameters of interest of the input workspace that are not selected by this command become unconstrained nuisance parameters, but they are not added to the list of nuisances so they will not be randomized (see above).</li> </ul> </li> <li> <p><code>--freezeParameters name1[,name2,...]</code> Will freeze the parameters with the given names to their set values. This option supports the use of regular expression by replacing <code>name</code> with <code>rgx{some regular expression}</code> for matching to constrained nuisance parameters or <code>var{some regular expression}</code> for matching to any parameter. For example <code>--freezeParameters rgx{CMS_scale_j.*}</code> will freeze all constrained nuisance parameters with the prefix <code>CMS_scale_j</code>, while <code>--freezeParameters var{.*rate_scale}</code> will freeze any parameter (constrained nuisance parameter or otherwise) with the suffix <code>rate_scale</code>.</p> <ul> <li>Use the option <code>--freezeParameters allConstrainedNuisances</code> to freeze all nuisance parameters that have a constraint term (i.e not <code>flatParams</code> or <code>rateParams</code> or other freely floating parameters).</li> <li>Similarly, the option <code>--floatParameters name1[,name2,...]</code> sets the parameter(s) floating and also accepts regular expressions.</li> <li>Groups of nuisance parameters (constrained or otherwise), as defined in the datacard, can be frozen using <code>--freezeNuisanceGroups</code>. You can also freeze all nuisances that are not contained in a particular group using a ^ before the group name (<code>--freezeNuisanceGroups=^group_name</code> will freeze everything except nuisance parameters in the group \"group_name\".)</li> <li>All constrained nuisance parameters (not <code>flatParam</code> or <code>rateParam</code>) can be set floating using <code>--floatAllNuisances</code>.</li> </ul> </li> </ul> <p>Warning</p> <p>Note that the floating/freezing options have a priority ordering from lowest to highest as <code>floatParameters &lt; freezeParameters &lt; freezeNuisanceGroups &lt; floatAllNuisances</code>. Options with higher priority will take precedence over those with lower priority.</p> <ul> <li> <p><code>--trackParameters name1[,name2,...]</code> will add a branch to the output tree for each of the named parameters. This option supports the use of regular expressions by replacing <code>name</code> with <code>rgx{some regular expression}</code></p> <ul> <li>The name of the branch will be trackedParam_name.</li> <li>The exact behaviour depends on the method used. For example, when using <code>MultiDimFit</code> with <code>--algo scan</code>, the value of the parameter at each point in the scan will be saved, while for <code>FitDiagnostics</code>, only the value at the end of the fit will be saved.</li> </ul> </li> <li> <p><code>--trackErrors name1[,name2,...]</code> will add a branch to the output tree for the error of each of the named parameters. This option supports the use of regular expressions by replacing <code>name</code> with <code>rgx{some regular expression}</code></p> <ul> <li>The name of the branch will be trackedError_name.</li> <li>The behaviour, in terms of which values are saved, is the same as <code>--trackParameters</code> above.</li> </ul> </li> </ul> <p>By default, the data set used by Combine will be the one listed in the datacard. You can tell Combine to use a different data set (for example a toy data set that you generated) by using the option <code>--dataset</code>. The argument should be <code>rootfile.root:workspace:location</code> or <code>rootfile.root:location</code>. In order to use this option, you must first convert your datacard to a binary workspace and use this binary workspace as the input to Combine. </p>"},{"location":"part3/runningthetool/#generic-minimizer-options","title":"Generic Minimizer Options","text":"<p>Combine uses its own minimizer class, which is used to steer Minuit (via RooMinimizer), named the <code>CascadeMinimizer</code>. This allows for sequential minimization, which can help in case a particular setting or algorithm fails. The <code>CascadeMinimizer</code> also knows about extra features of Combine such as discrete nuisance parameters.</p> <p>All of the fits that are performed in Combine's methods use this minimizer. This means that the fits can be tuned using these common options,</p> <ul> <li><code>--cminPoiOnlyFit</code>: First, perform a fit floating only the parameters of interest. This can be useful to find, roughly, where the global minimum is.</li> <li><code>--cminPreScan</code>: Do a scan before the first minimization.</li> <li><code>--cminPreFit arg</code> If set to a value N &gt; 0, the minimizer will perform a pre-fit with strategy (N-1), with the nuisance parameters frozen.<ul> <li><code>--cminApproxPreFitTolerance arg</code>: If non-zero, first do a pre-fit with this tolerance (or 10 times the final tolerance, whichever is largest)</li> <li><code>--cminApproxPreFitStrategy arg</code>:   Strategy to use in the pre-fit. The default is strategy 0.</li> </ul> </li> <li><code>--cminDefaultMinimizerType arg</code>: Set the default minimizer type. By default this is set to Minuit2.</li> <li><code>--cminDefaultMinimizerAlgo arg</code>: Set the default minimizer algorithm. The default algorithm is Migrad.</li> <li><code>--cminDefaultMinimizerTolerance arg</code>: Set the default minimizer tolerance, the default is 0.1.</li> <li><code>--cminDefaultMinimizerStrategy arg</code>: Set the default minimizer strategy between 0 (speed), 1 (balance - default), 2 (robustness). The Minuit documentation for this is pretty sparse but in general, 0 means evaluate the function less often, while 2 will waste function calls to get precise answers. An important note is that the <code>Hesse</code> algorithm (for error and correlation estimation) will be run only if the strategy is 1 or 2.</li> <li><code>--cminFallbackAlgo arg</code>: Provides a list of fallback algorithms, to be used in case the default minimizer fails. You can provide multiple options using the syntax <code>Type[,algo],strategy[:tolerance]</code>: eg <code>--cminFallbackAlgo Minuit2,Simplex,0:0.1</code> will fall back to the simplex algorithm of Minuit2 with strategy 0 and a tolerance 0.1, while <code>--cminFallbackAlgo Minuit2,1</code> will use the default algorithm (Migrad) of Minuit2 with strategy 1.</li> <li><code>--cminSetZeroPoint (0/1)</code>: Set the reference of the NLL to 0 when minimizing, this can help faster convergence to the minimum if the NLL itself is large. The default is true (1), set to 0 to turn off.</li> </ul> <p>The allowed combinations of minimizer types and minimizer algorithms are as follows:</p> Minimizer type Minimizer algorithm <code>Minuit</code> <code>Migrad</code>, <code>Simplex</code>, <code>Combined</code>, <code>Scan</code> <code>Minuit2</code> <code>Migrad</code>, <code>Simplex</code>, <code>Combined</code>, <code>Scan</code> <code>GSLMultiMin</code> <code>ConjugateFR</code>, <code>ConjugatePR</code>, <code>BFGS</code>, <code>BFGS2</code>, <code>SteepestDescent</code> <p>You can find details about these in the Minuit2 documentation here.</p> <p>More of these options can be found in the Cascade Minimizer options section when running <code>--help</code>.</p>"},{"location":"part3/runningthetool/#output-from-combine","title":"Output from combine","text":"<p>Most methods will print the results of the computation to the screen. However, in addition, Combine will also produce a root file containing a tree called limit with these results. The name of this file will be of the format,</p> <pre><code>higgsCombineTest.MethodName.mH$MASS.[word$WORD].root\n</code></pre> <p>where $WORD is any user defined keyword from the datacard which has been set to a particular value.</p> <p>A few command-line options can be used to control this output:</p> <ul> <li>The option <code>-n</code> allows you to specify part of the name of the root file. e.g. if you pass <code>-n HWW</code> the root file will be called <code>higgsCombineHWW....</code> instead of <code>higgsCombineTest</code></li> <li>The option <code>-m</code> allows you to specify the (Higgs boson) mass hypothesis, which gets written in the filename and in the output tree. This simplifies the bookeeping, as it becomes possible to merge multiple trees corresponding to different (Higgs boson) masses using <code>hadd</code>. Quantities can then be plotted as a function of the mass. The default value is m=120.</li> <li>The option <code>-s</code> can be used to specify the seed (eg <code>-s 12345</code>) used in toy generation. If this option is given, the name of the file will be extended by this seed, eg <code>higgsCombineTest.AsymptoticLimits.mH120.12345.root</code></li> <li>The option <code>--keyword-value</code> allows you to specify the value of a keyword in the datacard such that $WORD (in the datacard) will be given the value of VALUE in the command <code>--keyword-value WORD=VALUE</code>, eg  <code>higgsCombineTest.AsymptoticLimits.mH120.WORDVALUE.12345.root</code></li> </ul> <p>The output file will contain a <code>TDirectory</code> named toys, which will be empty if no toys are generated (see below for details) and a <code>TTree</code> called limit with the following branches;</p> Branch name Type Description <code>limit</code> <code>Double_t</code> Main result of combine run, with method-dependent meaning <code>limitErr</code> <code>Double_t</code> Estimated uncertainty on the result <code>mh</code> <code>Double_t</code> Value of MH, specified with <code>-m</code> option <code>iToy</code> <code>Int_t</code> Toy number identifier if running with <code>-t</code> <code>iSeed</code> <code>Int_t</code> Seed specified with <code>-s</code> <code>t_cpu</code> <code>Float_t</code> Estimated CPU time for algorithm <code>t_real</code> <code>Float_t</code> Estimated real time for algorithm <code>quantileExpected</code> <code>Float_t</code> Quantile identifier for methods that calculated expected (quantiles) and observed results (eg conversions from \\Delta\\ln L values), with method-dependent meaning. Negative values are reserved for entries that do not relate to quantiles of a calculation, with the default being set to -1 (usually meaning the observed result). <p>The value of any user-defined keyword $WORD that is set using <code>keyword-value</code> described above will also be included as a branch with type <code>string</code> named WORD. The option can be repeated multiple times for multiple keywords.</p> <p>In some cases, the precise meanings of the branches will depend on the method being used. In this case, it will be specified in this documentation.</p>"},{"location":"part3/runningthetool/#toy-data-generation","title":"Toy data generation","text":"<p>By default, each of the methods described so far will be run using the observed data as the input. In several cases (as detailed below), it is useful to run the tool using toy datasets, including Asimov data sets.</p> <p>The option <code>-t</code> is used to tell Combine to first generate one or more toy data sets, which will be used instead of the observed data. There are two versions,</p> <ul> <li> <p><code>-t N</code> with N &gt; 0. Combine will generate N toy datasets from the model and re-run the method once per toy. The seed for the toy generation can be modified with the option <code>-s</code> (use <code>-s -1</code> for a random seed). The output file will contain one entry in the tree for each of these toys.</p> </li> <li> <p><code>-t -1</code> will produce an Asimov data set, in which statistical fluctuations are suppressed. The procedure for generating this Asimov data set depends on the type of analysis you are using. More details are given below. </p> </li> </ul> <p>Warning</p> <p>The default values of the nuisance parameters (or any parameter) are used to generate the toy. This means that if, for example, you are using parametric shapes and the parameters inside the workspace are set to arbitrary values, those arbitrary values will be used to generate the toy. This behaviour can be modified through the use of the option <code>--setParameters x=value_x,y=value_y...</code>, which will set the values of the parameters (<code>x</code> and <code>y</code>) before toy generation. You can also load a snapshot from a previous fit to set the nuisance parameters to their post-fit values (see below).</p> <p>The output file will contain the toys (as <code>RooDataSets</code> for the observables, including global observables) in the toys directory if the option <code>--saveToys</code> is provided. If you include this option, the <code>limit</code> TTree in the output will have an entry corresponding to the state of the POI used for the generation of the toy, with the value of <code>quantileExpected</code> set to -2. </p> <p>The branches that are created by methods like <code>MultiDimFit</code> will not show the values used to generate the toy. If you also want the TTree to show the values of the POIs used to generate the toy, you should add additional branches using the <code>--trackParameters</code> option as described in the common command-line options section above. These branches will behave as expected when adding the option <code>--saveToys</code>. </p> <p>Warning</p> <p>For statistical methods that make use of toys (including <code>HybridNew</code>, <code>MarkovChainMC</code> and running with <code>-t N</code>), the results of repeated Combine commands will not be identical when using the datacard as the input. This is due to a feature in the tool that allows one to run concurrent commands that do not interfere with one another. In order to produce reproducible results with toy-based methods, you should first convert the datacard to a binary workspace using <code>text2workspace.py</code> and then use the resulting file as input to the Combine commands</p>"},{"location":"part3/runningthetool/#asimov-datasets","title":"Asimov datasets","text":"<p>If you are using either <code>-t -1</code> or  <code>AsymptoticLimits</code>, Combine will calculate results based on an Asimov data set.</p> <ul> <li> <p>For counting experiments, the Asimov data set will just be the total number of expected events (given the values of the nuisance parameters and POIs of the model)</p> </li> <li> <p>For shape analyses with templates, the Asimov data set will be constructed as a histogram using the same binning that is defined for your analysis.</p> </li> <li> <p>If your model uses parametric shapes, there are some options as to what Asimov data set to produce. By default, Combine will produce the Asimov data set as a histogram using the binning that is associated with each observable (ie as set using <code>RooRealVar::setBins</code>). If this binning does not exist, Combine will guess a suitable binning - it is therefore best to use <code>RooRealVar::setBins</code> to associate a binning with each observable, even if your data is unbinned, if you intend to use Asimov data sets.</p> </li> </ul> <p>You can also ask Combine to use a Pseudo-Asimov dataset, which is created from many weighted unbinned events.</p> <p>Setting <code>--X-rtd TMCSO_AdaptivePseudoAsimov=</code>\\beta with \\beta&gt;0 will trigger the internal logic of whether to produce a Pseudo-Asimov dataset. This logic is as follows;</p> <ol> <li> <p>For each observable in your dataset, the number of bins, n_{b} is determined either from the value of <code>RooRealVar::getBins</code>, if it exists, or assumed to be 100.</p> </li> <li> <p>If N_{b}=\\prod_{b}n_{b}&gt;5000, the number of expected events N_{ev} is determined. Note if you are combining multiple channels, N_{ev} refers to the number of expected events in a single channel. The logic is separate for each channel. If  N_{ev}/N_{b}&lt;0.01 then a Pseudo-Asimov data set is created with the number of events equal to \\beta \\cdot \\mathrm{max}\\{100*N_{ev},1000\\}. If N_{ev}/N_{b}\\geq 0.01 , then a normal Asimov data set is produced.</p> </li> <li> <p>If N_{b}\\leq 5000 then a normal Asimov data set will be produced</p> </li> </ol> <p>The production of a Pseudo-Asimov data set can be forced by using the option <code>--X-rtd TMCSO_PseudoAsimov=X</code> where <code>X&gt;0</code> will determine the number of weighted events for the Pseudo-Asimov data set. You should try different values of <code>X</code>, since larger values lead to more events in the Pseudo-Asimov data set, resulting in higher precision. However, in general, the fit will be slower. </p> <p>You can turn off the internal logic by setting <code>--X-rtd TMCSO_AdaptivePseudoAsimov=0 --X-rtd TMCSO_PseudoAsimov=0</code>, thereby forcing histograms to be generated.</p> <p>Info</p> <p>If you set <code>--X-rtd TMCSO_PseudoAsimov=X</code> with <code>X&gt;0</code> and also turn on <code>--X-rtd TMCSO_AdaptivePseudoAsimov=</code>\\beta, with \\beta&gt;0, the internal logic will be used, but this time the default will be to generate Pseudo-Asimov data sets, rather than the standard Asimov ones.</p>"},{"location":"part3/runningthetool/#nuisance-parameter-generation","title":"Nuisance parameter generation","text":"<p>The default method of handling systematics is to generate random values (around their nominal values, see above) for the nuisance parameters, according to their prior PDFs centred around their default values, before generating the data. The unconstrained nuisance parameters (eg <code>flatParam</code> or <code>rateParam</code>), or those with flat priors are not randomized before the data generation. If you wish to also randomize these parameters, you must declare them as <code>flatParam</code> in your datacard and, when running text2workspace, you must add the option <code>--X-assign-flatParam-prior</code> to the command line.</p> <p>The following options define how the toys will be generated,</p> <ul> <li> <p><code>--toysNoSystematics</code> the nuisance parameters in each toy are not randomized when generating the toy data sets - i.e their nominal values are used to generate the data. Note that for methods which profile (fit) the nuisances, the parameters are still floating when evaluating the likelihood.</p> </li> <li> <p><code>--toysFrequentist</code> the nuisance parameters in each toy are set to their nominal values which are obtained after first fitting to the observed data, with the POIs fixed, before generating the toy data sets. For evaluating likelihoods, the constraint terms are instead randomized within their PDFs around the post-fit nuisance parameter values.</p> </li> </ul> <p>If you are using <code>toysFrequentist</code>, be aware that the values set by <code>--setParameters</code> will be ignored for the toy generation as the post-fit values will instead be used (except for any parameter that is also a parameter of interest). You can override this behaviour and choose the nominal values for toy generation for any parameter by adding the option <code>--bypassFrequentistFit</code>, which will skip the initial fit to data, or by loading a snapshot (see below).</p> <p>Warning</p> <p>For methods such as <code>AsymptoticLimits</code> and <code>HybridNew --LHCmode LHC-limits</code>, the  \"nominal\" nuisance parameter values are taken from fits to the data and are, therefore, not \"blind\" to the observed data by default (following the fully frequentist paradigm). See the detailed documentation on these methods for how to run in fully \"blinded\" mode.</p>"},{"location":"part3/runningthetool/#generate-only","title":"Generate only","text":"<p>It is also possible to generate the toys first, and then feed them to the methods in Combine. This can be done using <code>-M GenerateOnly --saveToys</code>. The toys can then be read and used with the other methods by specifying <code>--toysFile=higgsCombineTest.GenerateOnly...</code> and using the same options for the toy generation.</p> <p>Warning</p> <p>Some methods also use toys within the method itself (eg <code>AsymptoticLimits</code> and <code>HybridNew</code>). For these, you should not specify the toy generation with <code>-t</code> or the options above. Instead, you should follow the method-specific instructions.</p>"},{"location":"part3/runningthetool/#loading-snapshots","title":"Loading snapshots","text":"<p>Snapshots from workspaces can be loaded and used in order to generate toys using the option <code>--snapshotName &lt;name of snapshot&gt;</code>. This will first set the parameters to the values in the snapshot, before any other parameter options are set and toys are generated.</p> <p>See the section on saving post-fit workspaces for creating workspaces with post-fit snapshots from <code>MultiDimFit</code>.</p> <p>Here are a few examples of calculations with toys from post-fit workspaces using a workspace with r, m_{H} as parameters of interest</p> <ul> <li> <p>Throw post-fit toy with b from s+b(floating r,m_{H}) fit, s with r=1.0, m=best fit MH, using nuisance parameter values and constraints re-centered on s+b(floating r,m_{H}) fit values (aka frequentist post-fit expected) and compute post-fit expected r uncertainty profiling MH <code>combine higgsCombinemumhfit.MultiDimFit.mH125.root --snapshotName MultiDimFit -M MultiDimFit --verbose 9 -n randomtest --toysFrequentist --bypassFrequentistFit -t -1 --expectSignal=1 -P r --floatOtherPOIs=1 --algo singles</code></p> </li> <li> <p>Throw post-fit toy with b from s+b(floating r,m_{H}) fit, s with r=1.0, m=128.0, using nuisance parameter values and constraints re-centered on s+b(floating r,m_{H}) fit values (aka frequentist post-fit expected) and compute post-fit expected significance (with MH fixed at 128 implicitly)     <code>combine higgsCombinemumhfit.MultiDimFit.mH125.root -m 128 --snapshotName MultiDimFit -M ProfileLikelihood --significance --verbose 9 -n randomtest --toysFrequentist --bypassFrequentistFit --overrideSnapshotMass -t -1 --expectSignal=1 --redefineSignalPOIs r --freezeParameters MH</code></p> </li> <li> <p>Throw post-fit toy with b from s+b(floating r,m_{H}) fit, s with r=0.0, using nuisance parameter values and constraints re-centered on s+b(floating r,m_{H}) fit values (aka frequentist post-fit expected) and compute post-fit expected and observed asymptotic limit (with MH fixed at 128 implicitly)     <code>combine higgsCombinemumhfit.MultiDimFit.mH125.root -m 128 --snapshotName MultiDimFit -M AsymptoticLimits --verbose 9 -n randomtest --bypassFrequentistFit --overrideSnapshotMass--redefineSignalPOIs r --freezeParameters MH</code></p> </li> </ul>"},{"location":"part3/runningthetool/#combinetool-for-job-submission","title":"combineTool for job submission","text":"<p>For longer tasks that cannot be run locally, several methods in Combine can be split to run on a batch system or on the Grid. The splitting and submission is handled using the <code>combineTool</code> (see this getting started section to check out the tool)</p>"},{"location":"part3/runningthetool/#submission-to-condor","title":"Submission to Condor","text":"<p>The syntax for running on condor with the tool is</p> <pre><code>combineTool.py -M ALGO [options] --job-mode condor --sub-opts='CLASSADS' --task-name NAME [--dry-run]\n</code></pre> <p>with <code>options</code> being the usual list of Combine options. The help option <code>-h</code> will give a list of both Combine and <code>combineTool</code> options. It is possible to use this tool with several different methods from Combine.</p> <p>The <code>--sub-opts</code> option takes a string with the different ClassAds that you want to set, separated by <code>\\n</code> as argument (e.g. <code>'+JobFlavour=\"espresso\"\\nRequestCpus=1'</code>).</p> <p>The <code>--dry-run</code> option will show what will be run without actually doing so / submitting the jobs.</p> <p>For example, to generate toys (eg for use with limit setting) users running on lxplus at CERN can use the condor mode:</p> <pre><code>combineTool.py -d workspace.root -M HybridNew --LHCmode LHC-limits --clsAcc 0  -T 2000 -s -1 --singlePoint 0.2:2.0:0.05 --saveHybridResult -m 125 --job-mode condor --task-name condor-test --sub-opts='+JobFlavour=\"tomorrow\"'\n</code></pre> <p>The <code>--singlePoint</code> option is over-ridden, so that this will produce a script for each value of the POI in the range 0.2 to 2.0 in steps of 0.05. You can merge multiple points into a script using <code>--merge</code> - e.g adding <code>--merge 10</code> to the above command will mean that each job contains at most 10 of the values. The scripts are labelled by the <code>--task-name</code> option. They will be submitted directly to condor, adding any options in <code>--sub-opts</code> to the condor submit script. Make sure multiple options are separated by <code>\\n</code>. The jobs will run and produce output in the current directory.</p> <p>Below is an example for splitting points in a multi-dimensional likelihood scan.</p>"},{"location":"part3/runningthetool/#splitting-jobs-for-a-multi-dimensional-likelihood-scan","title":"Splitting jobs for a multi-dimensional likelihood scan","text":"<p>The option <code>--split-points</code> issues the command to split the jobs for <code>MultiDimFit</code> when using <code>--algo grid</code>. The following example will split the jobs such that there are 10 points in each of the jobs, which will be submitted to the workday queue.</p> <pre><code>combineTool.py datacard.txt -M MultiDimFit --algo grid --points 50 --rMin 0 --rMax 1 --job-mode condor --split-points 10 --sub-opts='+JobFlavour=\"workday\"' --task-name mytask -n mytask\n</code></pre> <p>Remember, any usual options (such as redefining POIs or freezing parameters) are passed to Combine and can be added to the command line for <code>combineTool</code>.</p> <p>Info</p> <p>The option <code>-n NAME</code> should be included to avoid overwriting output files, as the jobs will be run inside the directory from which the command is issued.</p>"},{"location":"part3/runningthetool/#grid-submission-with-combinetool","title":"Grid submission with combineTool","text":"<p>For more CPU-intensive tasks, for example determining limits for complex models using toys, it is generally not feasible to compute all the results interactively. Instead, these jobs can be submitted to the Grid.</p> <p>In this example we will use the <code>HybridNew</code> method of Combine to determine an upper limit for a sub-channel of the Run 1 SM H\\rightarrow\\tau\\tau analysis. For full documentation, see the section on computing limits with toys.</p> <p>With this model it would take too long to find the limit in one go, so instead we create a set of jobs in which each one throws toys and builds up the test statistic distributions for a fixed value of the signal strength. These jobs can then be submitted to a batch system or to the Grid using <code>crab3</code>. From the set of output distributions it is possible to extract the expected and observed limits.</p> <p>For this we will use <code>combineTool.py</code></p> <p>First we need to build a workspace from the H\\rightarrow\\tau\\tau datacard,</p> <pre><code>$ text2workspace.py data/tutorials/htt/125/htt_mt.txt -m 125\n$ mv data/tutorials/htt/125/htt_mt.root ./\n</code></pre> <p>To get an idea of the range of signal strength values we will need to build test-statistic distributions for, we will first use the <code>AsymptoticLimits</code> method of Combine,</p> <pre><code>$ combine -M Asymptotic htt_mt.root -m 125\n &lt;&lt; Combine &gt;&gt;\n[...]\n -- AsymptoticLimits (CLs) --\nObserved Limit: r &lt; 1.7384\nExpected  2.5%: r &lt; 0.4394\nExpected 16.0%: r &lt; 0.5971\nExpected 50.0%: r &lt; 0.8555\nExpected 84.0%: r &lt; 1.2340\nExpected 97.5%: r &lt; 1.7200\n</code></pre> <p>Based on this, a range of 0.2 to 2.0 should be suitable.</p> <p>We can use the same command for generating the distribution of test statistics with <code>combineTool</code>. The <code>--singlePoint</code> option is now enhanced to support expressions that generate a set of calls to Combine with different values. The accepted syntax is of the form MIN:MAX:STEPSIZE, and multiple comma-separated expressions can be specified.</p> <p>The script also adds an option <code>--dry-run</code>, which will not actually call comCombinebine but just prints out the commands that would be run, e.g,</p> <pre><code>combineTool.py -M HybridNew -d htt_mt.root --LHCmode LHC-limits --singlePoint 0.2:2.0:0.2 -T 2000 -s -1 --saveToys --saveHybridResult -m 125 --dry-run\n...\n[DRY-RUN]: combine -d htt_mt.root --LHCmode LHC-limits -T 2000 -s -1 --saveToys --saveHybridResult -M HybridNew -m 125 --singlePoint 0.2 -n .Test.POINT.0.2\n[DRY-RUN]: combine -d htt_mt.root --LHCmode LHC-limits -T 2000 -s -1 --saveToys --saveHybridResult -M HybridNew -m 125 --singlePoint 0.4 -n .Test.POINT.0.4\n[...]\n[DRY-RUN]: combine -d htt_mt.root --LHCmode LHC-limits -T 2000 -s -1 --saveToys --saveHybridResult -M HybridNew -m 125 --singlePoint 2.0 -n .Test.POINT.2.0\n</code></pre> <p>When the <code>--dry-run</code> option is removed each command will be run in sequence.</p>"},{"location":"part3/runningthetool/#grid-submission-with-crab3","title":"Grid submission with crab3","text":"<p>Submission to the grid with <code>crab3</code> works in a similar way. Before doing so, ensure that the <code>crab3</code> environment has been sourced in addition to the CMSSW environment. We will use the example of generating a grid of test-statistic distributions for limits.</p> <pre><code>$ cmsenv; source /cvmfs/cms.cern.ch/crab3/crab.sh\n$ combineTool.py -d htt_mt.root -M HybridNew --LHCmode LHC-limits --clsAcc 0 -T 2000 -s -1 --singlePoint 0.2:2.0:0.05 --saveToys --saveHybridResult -m 125 --job-mode crab3 --task-name grid-test --custom-crab custom_crab.py\n</code></pre> <p>The option <code>--custom-crab</code> should point to a python file python containing a function of the form <code>custom_crab(config)</code> that will be used to modify the default crab configuration. You can use this to set the output site to your local grid site, or modify other options such as the voRole, or the site blacklist/whitelist.</p> <p>For example</p> <pre><code>def custom_crab(config):\n  print '&gt;&gt; Customising the crab config'\n  config.Site.storageSite = 'T2_CH_CERN'\n  config.Site.blacklist = ['SOME_SITE', 'SOME_OTHER_SITE']\n</code></pre> <p>Again it is possible to use the option <code>--dry-run</code> to see what the complete crab config will look like before actually submitting it.</p> <p>Once submitted, the progress can be monitored using the standard <code>crab</code> commands. When all jobs are completed, copy the output from your site's storage element to the local output folder.</p> <pre><code>$ crab getoutput -d crab_grid-test\n# Now we have to un-tar the output files\n$ cd crab_grid-test/results/\n$ for f in *.tar; do tar xf $f; done\n$ mv higgsCombine*.root ../../\n$ cd ../../\n</code></pre> <p>These output files should be combined with <code>hadd</code>, after which we invoke Combine as usual to calculate observed and expected limits from the merged grid, as usual.</p>"},{"location":"part3/simplifiedlikelihood/","title":"Procedure for creating and validating simplified likelihood inputs","text":"<p>This page is to give a brief outline for the creation of (potentially aggregated) predictions and their covariance to facilitate external reinterpretation using the simplified likelihood (SL) approach. Instructions for validating the simplified likelihood method (detailed in the CMS note here and \"The Simplified Likelihood Framework\" paper) are also given.</p>"},{"location":"part3/simplifiedlikelihood/#requirements","title":"Requirements","text":"<p>You need an up to date version of Combine. Note You should use the latest release of Combine for the exact commands on this page. You should be using Combine tag <code>v9.0.0</code> or higher or the latest version of the <code>112x</code> branch to follow these instructions.  </p> <p>You will find the python scripts needed to convert Combine outputs into simplified likelihood inputs under <code>test/simplifiedLikelihood</code></p> <p>If you're using the <code>102x</code> branch (not recommended), then you can obtain these scripts from here by running: </p> <pre><code>curl -s https://raw.githubusercontent.com/nucleosynthesis/work-tools/master/sparse-checkout-SL-ssh.sh &gt; checkoutSL.sh\nbash checkoutSL.sh\nls work-tools/stats-tools\n</code></pre> <p>If you also want to validate your inputs and perform fits/scans using them, you can use the package SLtools from The Simplified Likelihood Framework paper for this.</p> <pre><code>git clone https://gitlab.cern.ch/SimplifiedLikelihood/SLtools.git\n</code></pre>"},{"location":"part3/simplifiedlikelihood/#producing-covariance-for-recasting","title":"Producing covariance for recasting","text":"<p>Producing the necessary predictions and covariance for recasting varies depending on whether or not control regions are explicitly included in the datacard when running fits. Instructions for cases where the control regions are and are not included are detailed below.</p> <p>Warning</p> <p>The instructions below will calculate moments based on the assumption that E[x]=\\hat{x}, i.e it will use the maximum likelihood estimators for the yields as the expectation values. If instead you want to use the full definition of the moments, you can run the <code>FitDiagnostics</code> method with the <code>-t</code> option and include <code>--savePredictionsPerToy</code> and remove the other options, which will produce a tree of the toys in the output from which moments can be calculated. </p>"},{"location":"part3/simplifiedlikelihood/#type-a-control-regions-included-in-datacard","title":"Type A - Control regions included in datacard","text":"<p>For an example datacard 'datacard.txt' including two signal channels 'Signal1' and 'Signal2', make the workspace including the masking flags</p> <pre><code>text2workspace.py --channel-masks --X-allow-no-signal --X-allow-no-background datacard.txt -o datacard.root\n</code></pre> <p>Run the fit making the covariance (output saved as <code>fitDiagnostics.root</code>) masking the signal channels. Note that all signal channels must be masked!</p> <pre><code>combine datacard.root -M FitDiagnostics --saveShapes --saveWithUnc --numToysForShape 2000 --setParameters mask_Signal1=1,mask_Signal2=1 --saveOverall  -N Name\n</code></pre> <p>Where \"Name\" can be specified by you.</p> <p>Outputs, including predictions and covariance, will be saved in <code>fitDiagnosticsName.root</code> folder <code>shapes_fit_b</code></p>"},{"location":"part3/simplifiedlikelihood/#type-b-control-regions-not-included-in-datacard","title":"Type B - Control regions not included in datacard","text":"<p>For an example datacard 'datacard.txt' including two signal channels 'Signal1' and 'Signal2', make the workspace</p> <pre><code>text2workspace.py --X-allow-no-signal --X-allow-no-background datacard.txt -o datacard.root\n</code></pre> <p>Run the fit making the covariance (output saved as <code>fitDiagnosticsName.root</code>) setting no pre-fit signal contribution. Note we must set <code>--preFitValue 0</code> in this case since, we will be using the pre-fit uncertainties for the covariance calculation and we do not want to include the uncertainties on the signal. </p> <pre><code>combine datacard.root -M FitDiagnostics --saveShapes --saveWithUnc --numToysForShape 2000 --saveOverall --preFitValue 0   -n Name\n</code></pre> <p>Where \"Name\" can be specified by you.</p> <p>Outputs, including predictions and covariance, will be saved in <code>fitDiagnosticsName.root</code> folder <code>shapes_prefit</code></p> <p>In order to also extract the signal yields corresponding to <code>r=1</code> (in case you want to run the validation step later), you also need to produce a second file with the pre-fit value set to 1. For this you do not need to run many toys. To save time you can set <code>--numToysForShape</code> to a low value. </p> <pre><code>combine datacard.root -M FitDiagnostics --saveShapes --saveWithUnc --numToysForShape 1 --saveOverall --preFitValue 1   -n Name2\n</code></pre> <p>You should check that the order of the bins in the covariance matrix is as expected.</p>"},{"location":"part3/simplifiedlikelihood/#produce-simplified-likelihood-inputs","title":"Produce simplified likelihood inputs","text":"<p>Head over to the <code>test/simplifiedLikelihoods</code> directory inside your Combine area. The following instructions depend on whether you are aggregating or not aggregating your signal regions. Choose the instructions for your case. </p>"},{"location":"part3/simplifiedlikelihood/#not-aggregating","title":"Not Aggregating","text":"<p>Run the <code>makeLHInputs.py</code> script to prepare the inputs for the simplified likelihood. The filter flag can be used to select only signal regions based on the channel names. To include all channels do not include the filter flag.</p> <p>The SL input must NOT include any control regions that were not masked in the fit.</p> <p>If your analysis is Type B (i.e everything in the datacard is a signal region), then you can just run </p> <pre><code>python makeLHInputs.py -i fitDiagnosticsName.root -o SLinput.root \n</code></pre> <p>If necessary (i.e as in Type B analyses) you may also need to run the same on the output of the run where the pre-fit value was set to 1. </p> <pre><code>python makeLHInputs.py -i fitDiagnosticsName2.root -o SLinput2.root \n</code></pre> <p>If you instead have a Type A analysis (some of the regions are control regions that were used to fit but not masked) then you should add the option <code>--filter SignalName</code> where <code>SignalName</code> is some string that defines the signal regions in your datacards (for example, \"SR\" is a common name for these).</p> <p>Note: If your signal regions cannot be easily identified by a string, follow the instructions below for aggregating, but define only one channel for each aggregate region. This will maintain the full information and will not actually aggregate any regions.</p>"},{"location":"part3/simplifiedlikelihood/#aggregating","title":"Aggregating","text":"<p>If aggregating based on covariance, edit the config file <code>aggregateCFG.py</code> to define aggregate regions based on channel names. Note that wildcards are supported. You can then make likelihood inputs using</p> <pre><code>python makeLHInputs.py -i fitDiagnosticsName.root -o SLinput.root --config aggregateCFG.py\n</code></pre> <p>At this point you have the inputs as ROOT files necessary to publish and run the simplified likelihood. </p>"},{"location":"part3/simplifiedlikelihood/#validating-the-simplified-likelihood-approach","title":"Validating the simplified likelihood approach","text":"<p>The simplified likelihood relies on several assumptions (detailed in the documentation at the top). To test the validity for your analysis, statistical results between Combine and the simplified likelihood can be compared. </p> <p>We will use the package SLtools from the Simplified Likelihood Paper for this. The first step is to convert the ROOT files into python configs to run in the tool. </p>"},{"location":"part3/simplifiedlikelihood/#convert-root-to-python","title":"Convert ROOT to Python","text":"<p>If you followed the steps above, you have all of the histograms already necessary to generate the python configs. The script <code>test/simplifiedLikelihoods/convertSLRootToPython.py</code>  can be used to do the conversion. Just provide the following options when running with python.</p> <ul> <li><code>-O/--outname</code> : The output python file containing the model (default is <code>test.py</code>)</li> <li><code>-s/--signal</code> : The signal histogram, should be of format <code>file.root:location/to/histogram</code></li> <li><code>-b/--background</code> : The background histogram, should be of format <code>file.root:location/to/histogram</code></li> <li><code>-d/--data</code> : The data TGraph, should be of format <code>file.root:location/to/graph</code></li> <li><code>-c/--covariance</code> : The covariance TH2 histogram, should be of format <code>file.root:location/to/histogram</code></li> </ul> <p>For example, to get the correct output from a Type B analysis with no aggregating, you can run </p> <pre><code>python test/simplifiedLikelihoods/convertSLRootToPython.py -O mymodel.py -s SLinput.root:shapes_prefit/total_signal  -b SLinput.root:shapes_prefit/total_M2 d -d SLinput.root:shapes_prefit/total_data -c SLinput.root:shapes_prefit/total_M2\n</code></pre> <p>The output will be a python file with the right format for the SL tool. You can mix different ROOT files for these inputs. Note that the <code>SLtools</code> package also has some tools to covert <code>.yaml</code>-based inputs into the python config for you.</p>"},{"location":"part3/simplifiedlikelihood/#run-a-likelihood-scan-with-the-sl","title":"Run a likelihood scan with the SL","text":"<p>If you have checked out the SLtools, you can create a simple python script as the one below to produce a scan of the simplified likelihood from your inputs.</p> <pre><code>#! /usr/bin/env python\nimport simplike as sl\n\nexec(open(\"mymodel.py\").read())\nslp1 = sl.SLParams(background, covariance, obs=data, sig=signal)\n\nimport numpy as np\nnpoints = 50\nmus = np.arange(-0.5, 2, (2+0.5)/npoints)\ntmus1 = [slp1.tmu(mu) for mu in mus]\nfrom matplotlib import pyplot as plt\nplt.plot(mus,tmus1)\nplt.show()\n</code></pre> <p>Where the <code>mymodel.py</code> config is a simple python file defined as;</p> <ul> <li><code>data</code> : A python array of observed data, one entry per bin.</li> <li><code>background</code> : A python array of expected background, one entry per bin.</li> <li><code>covariance</code> : A python array of the covariance between expected backgrounds. The format is a flat array which is converted into a 2D array inside the tool</li> <li><code>signal</code> : A python array of the expected signal, one entry per bin. This should be replaced with whichever signal model you are testing.</li> </ul> <p>This <code>model.py</code> can also just be the output of the previous section converted from the ROOT files for you.</p> <p>The example below is from the note CMS-NOTE-2017-001</p> Show example <pre><code>\nimport numpy\nimport array\n\nname = \"CMS-NOTE-2017-001 dummy model\"\nnbins = 8\ndata = array.array('d',[1964,877,354,182,82,36,15,11])\nbackground = array.array('d',[2006.4,836.4,350.,147.1,62.0,26.2,11.1,4.7])\nsignal = array.array('d',[47,29.4,21.1,14.3,9.4,7.1,4.7,4.3])\ncovariance = array.array('d', [ 18774.2, -2866.97, -5807.3, -4460.52, -2777.25, -1572.97, -846.653, -442.531, -2866.97, 496.273, 900.195, 667.591, 403.92, 222.614, 116.779, 59.5958, -5807.3, 900.195, 1799.56, 1376.77, 854.448, 482.435, 258.92, 134.975, -4460.52, 667.591, 1376.77, 1063.03, 664.527, 377.714, 203.967, 106.926, -2777.25, 403.92, 854.448, 664.527, 417.837, 238.76, 129.55, 68.2075, -1572.97, 222.614, 482.435, 377.714, 238.76, 137.151, 74.7665, 39.5247, -846.653, 116.779, 258.92, 203.967, 129.55, 74.7665, 40.9423, 21.7285, -442.531, 59.5958, 134.975, 106.926, 68.2075, 39.5247, 21.7285, 11.5732])\n</code>"},{"location":"part3/simplifiedlikelihood/#example-using-tutorial-datacard","title":"Example using tutorial datacard","text":"<p>For this example, we will use the tutorial datacard <code>data/tutorials/longexercise/datacard_part3.txt</code>. This datacard is of Type B since there are no control regions (all regions are signal regions). </p>\n<p>First, we will create the binary file (run <code>text2workspace</code>)</p>\n<pre><code>text2workspace.py --X-allow-no-signal --X-allow-no-background data/tutorials/longexercise/datacard_part3.txt  -m 200\n</code></pre>\n<p>And next, we will generate the covariance between the bins of the background model. </p>\n<pre><code>combine data/tutorials/longexercise/datacard_part3.root -M FitDiagnostics --saveShapes --saveWithUnc --numToysForShape 10000 --saveOverall --preFitValue 0   -n SimpleTH1 -m 200\n\ncombine data/tutorials/longexercise/datacard_part3.root -M FitDiagnostics --saveShapes --saveWithUnc --numToysForShape 1 --saveOverall --preFitValue 1   -n SimpleTH1_Signal1 -m 200\n</code></pre>\n<p>We will also want to compare our scan to that from the full likelihood, which we can get as usual from Combine. </p>\n<pre><code>combine -M MultiDimFit data/tutorials/longexercise/datacard_part3.root --rMin -0.5 --rMax 2 --algo grid -n SimpleTH1 -m 200\n</code></pre>\n<p>Next, since we do not plan to aggregate any of the bins, we will follow the instructions for this and pick out the right covariance matrix.</p>\n<pre><code>python test/simplifiedLikelihoods/makeLHInputs.py -i fitDiagnosticsSimpleTH1.root -o SLinput.root \n\npython test/simplifiedLikelihoods/makeLHInputs.py -i fitDiagnosticsSimpleTH1_Signal1.root -o SLinput_Signal1.root \n</code></pre>\n<p>We now have everything we need to provide the simplified likelihood inputs:</p>\n<pre><code>$ root -l SLinput.root\nroot [0] .ls\n\nAttaching file SLinput.root as _file0...\n(TFile *) 0x3667820\nroot [1] .ls\nTFile**         SLinput.root\n TFile*         SLinput.root\n  KEY: TDirectoryFile   shapes_fit_b;1  shapes_fit_b\n  KEY: TDirectoryFile   shapes_prefit;1 shapes_prefit\n  KEY: TDirectoryFile   shapes_fit_s;1  shapes_fit_s\n</code></pre>\n<p>We can convert this to a python module that we can use to run a scan with the <code>SLtools</code> package. Note, since we have a Type B datacard, we will be using the pre-fit covariance matrix. Also, this means we want to take the signal from the file where the prefit value of <code>r</code> was 1. </p>\n<pre><code>python test/simplifiedLikelihoods/convertSLRootToPython.py -O mymodel.py -s SLinput_Signal1.root:shapes_prefit/total_signal  -b SLinput.root:shapes_prefit/total_M1-d SLinput.root:shapes_prefit/total_data -c SLinput.root:shapes_prefit/total_M2\n</code></pre>\n<p>We can compare the profiled likelihood scans from our simplified likelihood (using the python file we just created) and from the full likelihood (that we created with Combine.). For the former, we need to first checkout the <code>SLtools</code> package </p>\n<pre><code>git clone https://gitlab.cern.ch/SimplifiedLikelihood/SLtools.git\nmv higgsCombineSimpleTH1.MultiDimFit.mH200.root SLtools/ \nmv mymodel.py SLtools/\ncd SLtools\n</code></pre>\n<p>The script below will create a plot of the comparison for us. </p>\n<pre><code>#! /usr/bin/env python\nimport simplike as sl\n\nexec(open(\"mymodel.py\").read())\n\nslp1 = sl.SLParams(background, covariance, obs=data, sig=signal)\n\nimport ROOT \nfi = ROOT.TFile.Open(\"higgsCombineSimpleTH1.MultiDimFit.mH200.root\")\ntr = fi.Get(\"limit\")\n\npoints = []\nfor i in range(tr.GetEntries()):\n  tr.GetEntry(i)\n  points.append([tr.r,2*tr.deltaNLL])\npoints.sort()\n\nmus2=[pt[0] for pt in points]\ntmus2=[pt[1] for pt in points]\n\nimport numpy as np\nnpoints = 50\nmus1 = np.arange(-0.5, 2, (2+0.5)/npoints)\ntmus1 = [slp1.tmu(mu) for mu in mus1]\n\nfrom matplotlib import pyplot as plt\nplt.plot(mus1,tmus1,label='simplified likelihood')\nplt.plot(mus2,tmus2,label='full likelihood')\nplt.legend()\nplt.xlabel(\"$\\mu$\")\nplt.ylabel(\"$-2\\Delta \\ln L$\")\n\nplt.savefig(\"compareLH.pdf\")\n</code></pre>\n<p>This will produce a figure like the one below. </p>\n<p></p>\n<p>It is also possible to include the third moment of each bin to improve the precision of the simplified likelihood [ JHEP 64 2019 ]. The necessary information is stored in the outputs from Combine, therefore you just need to include the option <code>-t SLinput.root:shapes_prefit/total_M3</code> in the options list for <code>convertSLRootToPython.py</code> to  include this in the model file. The third moment information can be included in <code>SLtools</code> by using <code>sl.SLParams(background, covariance, third_moment, obs=data, sig=signal)</code></p>"},{"location":"part3/validation/","title":"Validating datacards","text":"<p>This section covers the main features of the datacard validation tool that helps you spot potential problems with your datacards at an early stage. The tool is implemented in the <code>CombineHarvester/CombineTools</code> subpackage. See the <code>combineTool</code>  section of the documentation for checkout instructions.</p> <p>The datacard validation tool contains a number of checks. It is possible to call subsets of these checks when creating datacards within <code>CombineHarvester</code>. However, for now we will only describe the usage of the validation tool on already existing datacards. If you create your datacards with <code>CombineHarvester</code> and would like to include the checks at the datacard creation stage, please contact us via https://cms-talk.web.cern.ch/c/physics/cat/cat-stats/279.</p>"},{"location":"part3/validation/#how-to-use-the-tool","title":"How to use the tool","text":"<p>The basic syntax is:</p> <pre><code>ValidateDatacards.py datacard.txt\n</code></pre> <p>This will write the results of the checks to a json file (default: <code>validation.json</code>), and will print a summary to the screen, for example:</p> <pre><code>================================\n=======Validation results=======\n================================\n&gt;&gt;&gt;There were  7800 warnings of type  'up/down templates vary the yield in the same direction'\n&gt;&gt;&gt;There were  5323 warnings of type  'up/down templates are identical'\n&gt;&gt;&gt;There were no warnings of type  'At least one of the up/down systematic uncertainty templates is empty'\n&gt;&gt;&gt;There were  4406 warnings of type  'Uncertainty has normalisation effect of more than 10.0%'\n&gt;&gt;&gt;There were  8371 warnings of type  'Uncertainty probably has no genuine shape effect'\n&gt;&gt;&gt;There were no warnings of type 'Empty process'\n&gt;&gt;&gt;There were no warnings of type 'Bins of the template empty in background'\n&gt;&gt;&gt;INFO: there were  169  alerts of type  'Small signal process'\n</code></pre> <p>The meaning of each of these warnings/alerts is discussed below.</p> <p>The following arguments are possible:</p> <pre><code>usage: ValidateDatacards.py [-h] [--printLevel PRINTLEVEL] [--readOnly]\n                            [--checkUncertOver CHECKUNCERTOVER]\n                            [--reportSigUnder REPORTSIGUNDER]\n                            [--jsonFile JSONFILE] [--mass MASS]\n                            cards\n\npositional arguments:\n  cards                 Specifies the full path to the datacards to check\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --printLevel PRINTLEVEL, -p PRINTLEVEL\n                        Specify the level of info printing (0-3, default:1)\n  --readOnly            If this is enabled, skip validation and only read the\n                        output json\n  --checkUncertOver CHECKUNCERTOVER, -c CHECKUNCERTOVER\n                        Report uncertainties which have a normalization effect\n                        larger than this fraction (default:0.1)\n  --reportSigUnder REPORTSIGUNDER, -s REPORTSIGUNDER\n                        Report signals contributing less than this fraction of\n                        the total in a channel (default:0.001)\n  --jsonFile JSONFILE   Path to the json file to read/write results from\n                        (default:validation.json)\n  --mass MASS           Signal mass to use (default:*)\n</code></pre> <p><code>printLevel</code> adjusts how much information is printed to the screen. When set to 0, the results are only written to the json file, but not to the screen. When set to 1 (default), the number of warnings/alerts of a given type is printed to the screen. Setting this option to 2 prints the same information as level 1, and additionally prints which uncertainties are affected (if the check is related to uncertainties) or which processes are affected (if the check is related only to processes). When <code>printLevel</code> is set to 3, the information from level 2 is printed, and additionaly for checks related to uncertainties it prints which processes are affected.</p> <p>To print information to screen, the script parses the json file that contains the results of the validation checks. Therefore, if you have already run the validation tool and produced this json file, you can simply change the <code>printLevel</code> by re-running the tool with <code>printLevel</code> set to a different value, and enabling the <code>--readOnly</code> option.</p> <p>The options <code>--checkUncertOver</code> and <code>--reportSigUnder</code> will be described in more detail in the section that discusses the checks for which they are relevant.</p> <p>Note: the <code>--mass</code> argument should only be set if you normally use it when running Combine, otherwise you can leave it at the default.</p> <p>The datacard validation tool is primarily intended for shape (histogram) based analyses. However, when running on a parametric model or counting experiment the checks for small signal processes, empty processes, and uncertainties with large normalization effects can still be performed. </p>"},{"location":"part3/validation/#details-on-checks","title":"Details on checks","text":""},{"location":"part3/validation/#uncertainties-with-large-normalization-effect","title":"Uncertainties with large normalization effect","text":"<p>This check highlights nuisance parameters that have a normalization effect larger than the fraction set by the option <code>--checkUncertOver</code>. The default value is 0.1, meaning that any uncertainties with a normalization effect larger than 10% are flagged up.</p> <p>The output file contains the following information for this check:</p> <pre><code>largeNormEff: {\n  &lt;Uncertainty name&gt;: {\n    &lt;analysis category&gt;: {\n      &lt;process&gt;: {\n        \"value_d\":&lt;value&gt;\n        \"value_u\":&lt;value&gt;\n      } \n    }\n  }\n}\n</code></pre> <p>Where <code>value_u</code> and <code>value_d</code> are the values of the 'up' and 'down' normalization effects.</p>"},{"location":"part3/validation/#at-least-one-of-the-updown-systematic-templates-is-empty","title":"At least one of the Up/Down systematic templates is empty","text":"<p>For shape uncertainties, this check reports all cases where the up and/or down template(s) are empty, when the nominal template is not.</p> <p>The output file contains the following information for this check:</p> <pre><code>emptySystematicShape: {\n  &lt;Uncertainty name&gt;: {\n    &lt;analysis category&gt;: {\n      &lt;process&gt;: {\n        \"value_d\":&lt;value&gt;\n        \"value_u\":&lt;value&gt;\n      } \n    }\n  }\n}\n</code></pre> <p>Where <code>value_u</code> and <code>value_d</code> are the values of the 'up' and 'down' normalization effects.</p>"},{"location":"part3/validation/#identical-updown-templates","title":"Identical Up/Down templates","text":"<p>This check applies to shape uncertainties only, and will highlight cases where the shape uncertainties have identical Up and Down templates (identical in shape and in normalization).</p> <p>The information given in the output file for this check is:</p> <pre><code>uncertTemplSame: {\n  &lt;Uncertainty name&gt;: {\n    &lt;analysis category&gt;: {\n      &lt;process&gt;: {\n        \"value_d\":&lt;value&gt;\n        \"value_u\":&lt;value&gt;\n      } \n    }\n  }\n}\n</code></pre> <p>Where <code>value_u</code> and <code>value_d</code> are the values of the 'up' and 'down' normalization effects.</p>"},{"location":"part3/validation/#up-and-down-templates-vary-the-yield-in-the-same-direction","title":"Up and Down templates vary the yield in the same direction","text":"<p>Again, this check only applies to shape uncertainties - it highlights cases where the 'Up' template and the 'Down' template both have the effect of increasing or decreasing the normalization of a process.</p> <p>The information given in the output file for this check is:</p> <pre><code>uncertVarySameDirect: {\n  &lt;Uncertainty name&gt;: {\n    &lt;analysis category&gt;: {\n      &lt;process&gt;: {\n        \"value_d\":&lt;value&gt;\n        \"value_u\":&lt;value&gt;\n      } \n    }\n  }\n}\n</code></pre> <p>Where <code>value_u</code> and <code>value_d</code> are the values of the 'up' and 'down' normalization effects.</p>"},{"location":"part3/validation/#uncertainty-probably-has-no-genuine-shape-effect","title":"Uncertainty probably has no genuine shape effect","text":"<p>In this check, applying only to shape uncertainties, the normalized nominal templates are compared with the normalized templates for the 'up' and 'down' systematic variations. The script calculates $$ \\Sigma_i \\frac{2|\\text{up}(i) - \\text{nominal}(i)|}{|\\text{up}(i)| + |\\text{nominal}(i)|}$$ and $$ \\Sigma_i \\frac{2|\\text{down}(i) - \\text{nominal}(i)|}{|\\text{down}(i)| + |\\text{nominal}(i)|} $$</p> <p>where the sums run over all bins in the histograms, and 'nominal', 'up', and 'down' are the central template and up and down varied templates, all normalized.</p> <p>If both sums are smaller than 0.001, the uncertainty is flagged up as probably not having a genuine shape effect. This means a 0.1% variation in one bin is enough to avoid being reported, but many smaller variations can also sum to be large enough to pass the threshold. It should be noted that the chosen threshold is somewhat arbitrary: if an uncertainty is flagged up as probably having no genuine shape effect you should take this as a starting point to investigate. </p> <p>The information given in the output file for this check is:</p> <pre><code>smallShapeEff: {\n  &lt;Uncertainty name&gt;: {\n    &lt;analysis category&gt;: {\n      &lt;process&gt;: {\n        \"diff_d\":&lt;value&gt;\n        \"diff_u\":&lt;value&gt;\n      } \n    }\n  }\n}\n</code></pre> <p>Where <code>diff_d</code> and <code>diff_u</code> are the values of the sums described above for the 'down' variation and the 'up' variation.</p>"},{"location":"part3/validation/#empty-process","title":"Empty process","text":"<p>If a process is listed in the datacard, but the yield is 0, it is flagged up by this check. </p> <p>The information given in the output file for this check is:</p> <pre><code>emptyProcessShape: {\n  &lt;analysis category&gt;: {\n    &lt;process1&gt;,\n    &lt;process2&gt;,\n    &lt;process3&gt;\n  }\n}\n</code></pre>"},{"location":"part3/validation/#bins-that-have-signal-but-no-background","title":"Bins that have signal but no background","text":"<p>For shape-based analyses, this checks whether there are any bins in the nominal templates that have signal contributions, but no background contributions. </p> <p>The information given in the output file for this check is:</p> <pre><code>emptyBkgBin: {\n  &lt;analysis category&gt;: {\n    &lt;bin_nr1&gt;,\n    &lt;bin_nr2&gt;,\n    &lt;bin_nr3&gt;\n  }\n}\n</code></pre>"},{"location":"part3/validation/#small-signal-process","title":"Small signal process","text":"<p>This reports signal processes that contribute less than the fraction specified by <code>--reportSigUnder</code> (default 0.001 = 0.1%) of the total signal in a given category. This produces an alert, not a warning, as it does not hint at a potential problem. However, in analyses with many signal contributions and with long fitting times, it can be helpful to remove signals from a category in which they do not contribute a significant amount.</p> <p>The information given in the output file for this check is:</p> <pre><code>smallSignalProc: {\n  &lt;analysis category&gt;: {\n    &lt;process&gt;: {\n      \"sigrate_tot\":&lt;value&gt;\n      \"procrate\":&lt;value&gt;\n    } \n  }\n}\n</code></pre> <p>Where <code>sigrate_tot</code> is the total signal yield in the analysis category and <code>procrate</code> is the yield of signal process <code>&lt;process&gt;</code>.</p>"},{"location":"part3/validation/#what-to-do-in-case-of-a-warning","title":"What to do in case of a warning","text":"<p>These checks are mostly a tool to help you investigate your datacards: a warning does not necessarily mean there is a mistake in your datacard, but you should use it as a starting point to investigate. Empty processes and emtpy shape uncertainties connected to nonempty processes will most likely be unintended. The same holds for cases where the 'up' and 'down' shape templates are identical. If there are bins that contain signal but no background contributions, this should be corrected. See the FAQ for more information on that point.</p> <p>For other checks it depends on the situation whether there is a problem or not. Some examples:</p> <ul> <li>An analysis-specific nonclosure uncertainty could be larger than 10%. A theoretical uncertainty in the ttbar normalization probably not.</li> <li>In an analysis with a selection that requires the presence of exactly 1 jet, 'up' and 'down' variations in the jet energy uncertainty could both change the process normalization in the same direction. (But they do not have to!)</li> </ul> <p>As always: think about whether you expect a check to yield a warning in case of your analysis, and if not, investigate to make sure there are no issues.</p>"},{"location":"part4/usefullinks/","title":"Useful links and further reading","text":""},{"location":"part4/usefullinks/#tutorials-and-reading-material","title":"Tutorials and reading material","text":"<p>There are several tutorials that have been run over the last few years with instructions and examples for running the Combine tool.</p> <p>Tutorial Sessions:</p> <ul> <li>1st tutorial 17th Nov 2015.</li> <li>2nd tutorial 30th Nov 2016.</li> <li>3rd tutorial 29th Nov 2017</li> <li>4th tutorial 31st Oct 2018 - Latest for <code>81x-root606</code> branch.</li> <li>5th tutorial 2nd-4th Dec 2019</li> <li>6th tutorial 14th-16th Dec 2020 - Latest for <code>102x</code> branch</li> <li>7th tutorial 3rd Feb 2023 - Uses <code>113x</code> branch</li> </ul> <p>Worked examples from Higgs analyses using Combine:</p> <ul> <li>The CMS DAS at CERN 2014</li> <li>The CMS DAS at DESY 2018</li> </ul> <p>Higgs combinations procedures</p> <ul> <li> <p>Conventions to be used when preparing inputs for Higgs combinations</p> </li> <li> <p>CMS AN-2011/298 Procedure for the LHC Higgs boson search combination in summer 2011. This describes in more detail some of the methods used in Combine.</p> </li> </ul>"},{"location":"part4/usefullinks/#citations","title":"Citations","text":"<p>There is no document currently which can be cited for using the Combine tool, however, you can use the following publications for the procedures we use,</p> <ul> <li> <p>Summer 2011 public ATLAS-CMS note for any Frequentist limit setting procedures with toys or Bayesian limits, constructing likelihoods, descriptions of nuisance parameter options (like log-normals (<code>lnN</code>) or gamma (<code>gmN</code>), and for definitions of test-statistics.</p> </li> <li> <p>CCGV paper if you use any of the asymptotic (eg with <code>-M AsymptoticLimits</code> or <code>-M Significance</code> approximations for limits/p-values.</p> </li> <li> <p>If you use the Barlow-Beeston approach to MC stat (bin-by-bin) uncertainties, please cite their paper Barlow-Beeston. You should also cite this note if you use the <code>autoMCStats</code> directive to produce a single parameter per bin.</p> </li> <li> <p>If you use <code>shape</code> uncertainties for template (<code>TH1</code> or <code>RooDataHist</code>) based datacards, you can cite this note from J. Conway.</p> </li> <li> <p>If you are extracting uncertainties from LH scans - i.e using -2\\Delta Log{L}=1 etc for the 1\\sigma intervals, you can cite either the ATLAS+CMS or CMS Higgs paper.</p> </li> <li> <p>There is also a long list of citation recommendations from the CMS Statistics Committee pages.</p> </li> </ul>"},{"location":"part4/usefullinks/#combine-based-packages","title":"Combine based packages","text":"<ul> <li> <p>SWGuideHiggs2TauLimits (Deprecated)</p> </li> <li> <p>ATGCRooStats</p> </li> <li> <p>CombineHarvester</p> </li> </ul>"},{"location":"part4/usefullinks/#contacts","title":"Contacts","text":"<ul> <li>CMStalk forum: https://cms-talk.web.cern.ch/c/physics/cat/cat-stats/279</li> </ul>"},{"location":"part4/usefullinks/#cms-statistics-committee","title":"CMS Statistics Committee","text":"<ul> <li>You can find much more statistics theory and reccomendations on various statistical procedures in the CMS Statistics Committee Twiki Pages</li> </ul>"},{"location":"part4/usefullinks/#faq","title":"FAQ","text":"<ul> <li>Why does Combine have trouble with bins that have zero expected contents?<ul> <li>If you are computing only upper limits, and your zero-prediction bins are all empty in data, then you can just set the background to a very small value instead of zero as the computation is regular for background going to zero (e.g. a counting experiment with B\\leq1 will have essentially the same expected limit and observed limit as one with B=0). If you are computing anything else, e.g. p-values, or if your zero-prediction bins are not empty in data, you're out of luck, and you should find a way to get a reasonable background prediction there (and set an uncertainty on it, as per the point above)</li> </ul> </li> <li>How can an uncertainty be added to a zero quantity?<ul> <li>You can put an uncertainty even on a zero event yield if you use a gamma distribution. That is in fact the more proper way of doing it if the prediction of zero comes from the limited size of your MC or data sample used to compute it.</li> </ul> </li> <li>Why does changing the observation in data affect my expected limit?<ul> <li>The expected limit (if using either the default behaviour of <code>-M AsymptoticLimits</code> or using the <code>LHC-limits</code> style limit setting with toys) uses the post-fit expectation of the background model to generate toys. This means that first the model is fit to the observed data before toy generation. See the sections on blind limits and toy generation to avoid this behavior. </li> </ul> </li> <li>How can I deal with an interference term which involves a negative contribution?<ul> <li>You will need to set up a specific PhysicsModel to deal with this, however you can see this section to implement such a model that can incorperate a negative contribution to the physics process</li> </ul> </li> <li>How does Combine work?<ul> <li>That is not a question that can be answered without someone's head exploding; please try to formulate something specific.</li> </ul> </li> <li>What does fit status XYZ mean? <ul> <li>Combine reports the fit status in some routines (for example in the <code>FitDiagnostics</code> method). These are typically the status of the last call from Minuit. For details on the meanings of these status codes see the Minuit2Minimizer documentation page.</li> </ul> </li> <li>Why does my fit not converge? <ul> <li>There are several reasons why some fits may not converge. Often some indication can be obtained from the <code>RooFitResult</code> or status that you will see information from when using the <code>--verbose X</code> (with X&gt;2) option. Sometimes however, it can be that the likelihood for your data is very unusual. You can get a rough idea about what the likelihood looks like as a function of your parameters (POIs and nuisances) using <code>combineTool.py -M FastScan -w myworkspace.root</code> (use --help for options). </li> <li>We have often seen that fits in Combine using <code>RooCBShape</code> as a parametric function will fail. This is related to an optimization that fails. You can try to fix the problem as described in this issue: issues#347 (i.e add the option <code>--X-rtd ADDNLL_CBNLL=0</code>).</li> </ul> </li> <li>Why does the fit/fits take so long? <ul> <li>The minimization routines are common to many methods in Combine. You can tune the fits using the generic optimization command line options described here. For example, setting the default minimizer strategy to 0 can greatly improve the speed, since this avoids running HESSE. In calculations such as <code>AsymptoticLimits</code>, HESSE is not needed and hence this can be done, however, for <code>FitDiagnostics</code> the uncertainties and correlations are part of the output, so using strategy 0 may not be particularly accurate. </li> </ul> </li> <li>Why are the results for my counting experiment so slow or unstable? <ul> <li>There is a known issue with counting experiments with large numbers of events that will cause unstable fits or even the fit to fail. You can avoid this by creating a \"fake\" shape datacard (see this section from the setting up the datacards page). The simplest way to do this is to run <code>combineCards.py -S mycountingcard.txt &gt; myshapecard.txt</code>. You may still find that your parameter uncertainties are not correct when you have large numbers of events. This can be often fixed using the <code>--robustHesse</code> option. An example of this issue is detailed here. </li> </ul> </li> <li>Why do some of my nuisance parameters have uncertainties &gt; 1?<ul> <li>When running <code>-M FitDiagnostics</code> you may find that the post-fit uncertainties of the nuisances are &gt; 1 (or larger than their pre-fit values). If this is the case, you should first check if the same is true when adding the option <code>--minos all</code>, which will invoke MINOS to scan the likelihood as a function of these parameters to determine the crossing at -2\\times\\Delta\\log\\mathcal{L}=1 rather than relying on the estimate from HESSE. However, this is not guaranteed to succeed, in which case you can scan the likelihood yourself using <code>MultiDimFit</code> (see here ) and specifying the option <code>--poi X</code> where <code>X</code> is your nuisance parameter. </li> </ul> </li> <li>How can I avoid using the data? <ul> <li>For almost all methods, you can use toy data (or an Asimov dataset) in place of the real data for your results to be blind. You should be careful however as in some methods, such as <code>-M AsymptoticLimits</code> or <code>-M HybridNew --LHCmode LHC-limits</code> or any other method using the option <code>--toysFrequentist</code>, the data will be used to determine the most likely nuisance parameter values (to determine the so-called a-posteriori expectation). See the section on toy data generation for details on this. </li> </ul> </li> <li>What if my nuisance parameters have correlations which are not 0 or 1?<ul> <li>Combine is designed under the assumption that each source of nuisance parameter is uncorrelated with the other sources. If you have a case where some pair (or set) of nuisances have some known correlation structure, you can compute the eigenvectors of their correlation matrix and provide these diagonalised nuisances to Combine. You can also model partial correlations, between different channels or data taking periods, of a given nuisance parameter using the <code>combineTool</code> as described in this page. </li> </ul> </li> <li>My nuisances are (artificially) constrained and/or the impact plot show some strange behaviour, especially after including MC statistical uncertainties. What can I do?<ul> <li>Depending on the details of the analysis, several solutions can be adopted to mitigate these effects. We advise to run the validation tools at first, to identify possible redundant shape uncertainties that can be safely eliminated or replaced with lnN ones. Any remaining artificial constraints should be studies. Possible mitigating strategies can be to (a) smooth the templates or (b) adopt some rebinning in order to reduce statistical fluctuations in the templates. A description of possible strategies and effects can be found in this talk by Margaret Eminizer</li> </ul> </li> <li>What do CLs, CLs+b and CLb in the code mean?<ul> <li>The names CLs+b and CLb what are found within some of the <code>RooStats</code> tools are rather outdated and should instead be referred to as p-values - p_{\\mu} and 1-p_{b}, respectively. We use the CLs (which itself is not a p-value) criterion often in High energy physics as it is designed to avoid excluding a signal model when the sensitivity is low (and protects against excluding due to underfluctuations in the data). Typically, when excluding a signal model the p-value p_{\\mu} often refers to the p-value under the signal+background hypothesis, assuming a particular value of the signal strength (\\mu) while p_{b} is the p-value under the background only hypothesis. You can find more details and definitions of the CLs criterion and p_{\\mu} and p_{b} in section 39.4.2.4 of the 2016 PDG review.       </li> </ul> </li> </ul>"},{"location":"part5/longexercise/","title":"Main Features of Combine (Long Exercises)","text":"<p>This exercise is designed to give a broad overview of the tools available for statistical analysis in CMS using the combine tool. Combine is a high-level tool for building <code>RooFit</code>/<code>RooStats</code> models and running common statistical methods. We will cover the typical aspects of setting up an analysis and producing the results, as well as look at ways in which we can diagnose issues and get a deeper understanding of the statistical model. This is a long exercise - expect to spend some time on it especially if you are new to Combine. If you get stuck while working through this exercise or have questions specifically about the exercise, you can ask them on this mattermost channel. Finally, we also provide some solutions to some of the questions that are asked as part of the exercise. These are available here.</p> <p>For the majority of this course we will work with a simplified version of a real analysis, that nonetheless will have many features of the full analysis. The analysis is a search for an additional heavy neutral Higgs boson decaying to tau lepton pairs. Such a signature is predicted in many extensions of the standard model, in particular the minimal supersymmetric standard model (MSSM). You can read about the analysis in the paper here. The statistical inference makes use of a variable called the total transverse mass (M_{\\mathrm{T}}^{\\mathrm{tot}}) that provides good discrimination between the resonant high-mass signal and the main backgrounds, which have a falling distribution in this high-mass region. The events selected in the analysis are split into a several categories which target the main di-tau final states as well as the two main production modes: gluon-fusion (ggH) and b-jet associated production (bbH). One example is given below for the fully-hadronic final state in the b-tag category which targets the bbH signal:</p> <p></p> <p>Initially we will start with the simplest analysis possible: a one-bin counting experiment using just the high M_{\\mathrm{T}}^{\\mathrm{tot}} region of this distribution, and from there each section of this exercise will expand on this, introducing a shape-based analysis and adding control regions to constrain the backgrounds.</p>"},{"location":"part5/longexercise/#background","title":"Background","text":"<p>You can find a presentation with some more background on likelihoods and extracting confidence intervals here. A presentation that discusses limit setting in more detail can be found here. If you are not yet familiar with these concepts, or would like to refresh your memory, we recommend that you have a look at these presentations before you start with the exercise. </p>"},{"location":"part5/longexercise/#getting-started","title":"Getting started","text":"<p>We need to set up a new CMSSW area and checkout the Combine package: </p> <pre><code>cmsrel CMSSW_11_3_4\ncd CMSSW_11_3_4/src\ncmsenv\ngit clone https://github.com/cms-analysis/HiggsAnalysis-CombinedLimit.git HiggsAnalysis/CombinedLimit\ncd HiggsAnalysis/CombinedLimit\n\ncd $CMSSW_BASE/src/HiggsAnalysis/CombinedLimit\ngit fetch origin\ngit checkout v9.0.0\n</code></pre> <p>We will also make use another package, <code>CombineHarvester</code>, which contains some high-level tools for working with Combine. The following command will download the repository and checkout just the parts of it we need for this tutorial:</p> <pre><code>bash &lt;(curl -s https://raw.githubusercontent.com/cms-analysis/CombineHarvester/main/CombineTools/scripts/sparse-checkout-https.sh)\n</code></pre> <p>Now make sure the CMSSW area is compiled:</p> <pre><code>scramv1 b clean; scramv1 b\n</code></pre> <p>Now we will move to the working directory for this tutorial, which contains all the inputs needed to run the exercises below:</p> <pre><code>cd $CMSSW_BASE/src/HiggsAnalysis/CombinedLimit/data/tutorials/longexercise/\n</code></pre>"},{"location":"part5/longexercise/#part-1-a-one-bin-counting-experiment","title":"Part 1: A one-bin counting experiment","text":"<p>Topics covered in this section:</p> <ul> <li>A: Computing limits using the asymptotic approximation</li> <li>Advanced section: B: Computing limits with toys</li> </ul> <p>We will begin with a simplified version of a datacard from the MSSM \\phi\\rightarrow\\tau\\tau analysis that has been converted to a one-bin counting experiment, as described above. While the full analysis considers a range of signal mass hypotheses, we will start by considering just one: m_{\\phi}=800GeV. Click the text below to study the datacard (<code>datacard_part1.txt</code> in the <code>longexercise</code> directory):</p> Show datacard <pre><code>imax    1 number of bins\njmax    4 number of processes minus 1\nkmax    * number of nuisance parameters\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------\nbin          signal_region\nobservation  10.0\n--------------------------------------------------------------------------------\nbin                      signal_region   signal_region   signal_region   signal_region   signal_region\nprocess                  ttbar           diboson         Ztautau         jetFakes        bbHtautau\nprocess                  1               2               3               4               0\nrate                     4.43803         3.18309         3.7804          1.63396         0.711064\n--------------------------------------------------------------------------------\nCMS_eff_b          lnN   1.02            1.02            1.02            -               1.02\nCMS_eff_t          lnN   1.12            1.12            1.12            -               1.12\nCMS_eff_t_highpt   lnN   1.1             1.1             1.1             -               1.1\nacceptance_Ztautau lnN   -               -               1.08            -               -\nacceptance_bbH     lnN   -               -               -               -               1.05\nacceptance_ttbar   lnN   1.005           -               -               -               -\nnorm_jetFakes      lnN   -               -               -               1.2             -\nxsec_diboson       lnN   -               1.05            -               -               -\n</code></pre> <p>The layout of the datacard is as follows:</p> <ul> <li>At the top are the numbers <code>imax</code>, <code>jmax</code> and <code>kmax</code> representing the number of bins, processes and nuisance parameters respectively. Here a \"bin\" can refer to a literal single event count as in this example, or a full distribution we are fitting, in general with many histogram bins, as we will see later. We will refer to both as \"channels\" from now on. It is possible to replace these numbers with <code>*</code> and they will be deduced automatically.</li> <li>The first line starting with <code>bin</code> gives a unique label to each channel, and the following line starting with <code>observation</code> gives the number of events observed in data.</li> <li>In the remaining part of the card there are several columns: each one represents one process in one channel. The first four lines labelled <code>bin</code>, <code>process</code>, <code>process</code> and <code>rate</code> give the channel label, the process label, a process identifier (<code>&lt;=0</code> for signal, <code>&gt;0</code> for background) and the number of expected events respectively.</li> <li>The remaining lines describe sources of systematic uncertainty. Each line gives the name of the uncertainty, (which will become the name of the nuisance parameter inside our RooFit model), the type of uncertainty (\"lnN\" = log-normal normalisation uncertainty) and the effect on each process in each channel. E.g. a 20% uncertainty on the yield is written as 1.20.</li> <li>It is also possible to add a hash symbol (<code>#</code>) at the start of a line, which Combine will then ignore when it reads the card.</li> </ul> <p>We can now run Combine directly using this datacard as input. The general format for running Combine is:</p> <pre><code>combine -M [method] [datacard] [additional options...]\n</code></pre>"},{"location":"part5/longexercise/#a-computing-limits-using-the-asymptotic-approximation","title":"A: Computing limits using the asymptotic approximation","text":"<p>As we are searching for a signal process that does not exist in the standard model, it's natural to set an upper limit on the cross section times branching fraction of the process (assuming our dataset does not contain a significant discovery of new physics). Combine has dedicated method for calculating upper limits. The most commonly used one is <code>AsymptoticLimits</code>, which implements the CLs criterion and uses the profile likelihood ratio as the test statistic. As the name implies, the test statistic distributions are determined analytically in the asymptotic approximation, so there is no need for more time-intensive toy throwing and fitting. Try running the following command:</p> <pre><code>combine -M AsymptoticLimits datacard_part1.txt -n .part1A\n</code></pre> <p>You should see the results of the observed and expected limit calculations printed to the screen. Here we have added an extra option, <code>-n .part1A</code>, which is short for <code>--name</code>, and is used to label the output file Combine produces, which in this case will be called <code>higgsCombine.part1A.AsymptoticLimits.mH120.root</code>. The file name depends on the options we ran with, and is of the form: <code>higgsCombine[name].[method].mH[mass].root</code>. The file contains a TTree called <code>limit</code> which stores the numerical values returned by the limit computation. Note that in our case we did not set a signal mass when running Combine (i.e. <code>-m 800</code>), so the output file just uses the default value of <code>120</code>. This does not affect our result in any way though, just the label that is used on the output file.</p> <p>The limits are given on a parameter called <code>r</code>. This is the default parameter of interest (POI) that is added to the model automatically. It is a linear scaling of the normalization of all signal processes given in the datacard, i.e. if s_{i,j} is the nominal number of signal events in channel i for signal process j, then the normalization of that signal in the model is given as r\\cdot s_{i,j}(\\vec{\\theta}), where \\vec{\\theta} represents the set of nuisance parameters which may also affect the signal normalization. We therefore have some choice in the interpretation of r: for the measurement of a process with a well-defined SM prediction we may enter this as the nominal yield in the datacard, such that r=1 corresponds to this SM expectation, whereas for setting limits on BSM processes we may choose the nominal yield to correspond to some cross section, e.g. 1 pb, such that we can interpret the limit as a cross section limit directly. In this example the signal has been normalised to a cross section times branching fraction of 1 fb.</p> <p>The expected limit is given under the background-only hypothesis. The median value under this hypothesis as well as the quantiles needed to give the 68% and 95% intervals are also calculated. These are all the ingredients needed to produce the standard limit plots you will see in many CMS results, for example the \\sigma \\times \\mathcal{B} limits for the \\text{bb}\\phi\\rightarrow\\tau\\tau process:</p> <p></p> <p>In this case we only computed the values for one signal mass hypothesis, indicated by a red dashed line.</p> <p>Tasks and questions:</p> <ul> <li>There are some important uncertainties missing from the datacard above. Add the uncertainty on the luminosity (name: <code>lumi_13TeV</code>) which has a 2.5% effect on all processes (except the <code>jetFakes</code>, which are taken from data), and uncertainties on the inclusive cross sections of the <code>Ztautau</code> and <code>ttbar</code> processes (with names <code>xsec_Ztautau</code> and <code>xsec_ttbar</code>) which are 4% and 6% respectively.</li> <li>Try changing the values of some uncertainties (up or down, or removing them altogether) - how do the expected and observed limits change?</li> <li>Now try changing the number of observed events. The observed limit will naturally change, but the expected does too - why might this be?</li> </ul> <p>There are other command line options we can supply to Combine which will change its behaviour when run. You can see the full set of supported options by doing <code>combine -h</code>. Many options are specific to a given method, but others are more general and are applicable to all methods. Throughout this tutorial we will highlight some of the most useful options you may need to use, for example:</p> <ul> <li>The range on the signal strength modifier: <code>--rMin=X</code> and <code>--rMax=Y</code>: In <code>RooFit</code> parameters can optionally have a range specified. The implication of this is that their values cannot be adjusted beyond the limits of this range. The min and max values can be adjusted though, and we might need to do this for our POI <code>r</code> if the order of magnitude of our measurement is different from the default range of <code>[0, 20]</code>. This will be discussed again later in the tutorial.</li> <li>Verbosity: <code>-v X</code>: By default combine does not usually produce much output on the screen other the main result at the end. However, much more detailed information can be printed by setting the <code>-v N</code> with N larger than zero. For example at <code>-v 3</code> the logs from the minimizer, Minuit, will also be printed. These are very useful for debugging problems with the fit.</li> </ul>"},{"location":"part5/longexercise/#advanced-section-b-computing-limits-with-toys","title":"Advanced section: B: Computing limits with toys","text":"<p>Now we will look at computing limits without the asymptotic approximation, so instead using toy datasets to determine the test statistic distributions under the signal+background and background-only hypotheses. This can be necessary if we are searching for signal in bins with a small number of events expected. In Combine we will use the <code>HybridNew</code> method to calculate limits using toys. This mode is capable of calculating limits with several different test statistics and with fine-grained control over how the toy datasets are generated internally. To calculate LHC-style profile likelihood limits (i.e. the same as we did with the asymptotic) we set the option <code>--LHCmode LHC-limits</code>. You can read more about the different options in the Combine documentation.</p> <p>Run the following command:</p> <pre><code>combine -M HybridNew datacard_part1.txt --LHCmode LHC-limits -n .part1B --saveHybridResult\n</code></pre> <p>In contrast to <code>AsymptoticLimits</code> this will only determine the observed limit, and will take a few minutes. There will not be much output to the screen while combine is running. You can add the option <code>-v 1</code> to get a better idea of what is going on. You should see Combine stepping around in <code>r</code>, trying to find the value for which CLs = 0.05, i.e. the 95% CL limit. The <code>--saveHybridResult</code> option will cause the test statistic distributions that are generated at each tested value of <code>r</code> to be saved in the output ROOT file.</p> <p>To get an expected limit add the option <code>--expectedFromGrid X</code>, where <code>X</code> is the desired quantile, e.g. for the median:</p> <pre><code>combine -M HybridNew datacard_part1.txt --LHCmode LHC-limits -n .part1B --saveHybridResult --expectedFromGrid 0.500\n</code></pre> <p>Calculate the median expected limit and the 68% range. The 95% range could also be done, but note it will take much longer to run the 0.025 quantile. While Combine is running you can move on to the next steps below.</p> <p>Tasks and questions: - In contrast to <code>AsymptoticLimits</code>, with <code>HybridNew</code> each limit comes with an uncertainty. What is the origin of this uncertainty? - How good is the agreement between the asymptotic and toy-based methods? - Why does it take longer to calculate the lower expected quantiles (e.g. 0.025, 0.16)? Think about how the statistical uncertainty on the CLs value depends on Pmu and Pb.</p> <p>Next plot the test statistic distributions stored in the output file:</p> <pre><code>python3 $CMSSW_BASE/src/HiggsAnalysis/CombinedLimit/test/plotTestStatCLs.py --input higgsCombine.part1B.HybridNew.mH120.root --poi r --val all --mass 120\n</code></pre> <p>This produces a new ROOT file <code>cls_qmu_distributions.root</code> containing the plots, to save them as pdf/png files run this small script and look at the resulting figures:</p> <pre><code>python3 printTestStatPlots.py cls_qmu_distributions.root\n</code></pre>"},{"location":"part5/longexercise/#advanced-section-b-asymptotic-approximation-limitations","title":"Advanced section: B: Asymptotic approximation limitations","text":"<p>These distributions can be useful in understanding features in the CLs limits, especially in the low statistics regime. To explore this, try reducing the observed and expected yields in the datacard by a factor of 10, and rerun the above steps to compare the observed and expected limits with the asymptotic approach, and plot the test statistic distributions.</p> <p>Tasks and questions:</p> <ul> <li>Is the asymptotic limit still a good approximation?</li> <li>You might notice that the test statistic distributions are not smooth but rather have several \"bump\" structures? Where might this come from? Try reducing the size of the systematic uncertainties to make them more pronounced.</li> </ul> <p>Note that for more complex models the fitting time can increase significantly, making it infeasible to run all the toy-based limits interactively like this. An alternative strategy is documented here</p>"},{"location":"part5/longexercise/#part-2-a-shape-based-analysis","title":"Part 2: A shape-based analysis","text":"<p>Topics covered in this section:</p> <ul> <li>A: Setting up the datacard</li> <li>B: Running Combine for a blind analysis</li> <li>C: Using FitDiagnostics</li> <li>D: MC statistical uncertainties</li> </ul>"},{"location":"part5/longexercise/#a-setting-up-the-datacard","title":"A: Setting up the datacard","text":"<p>Now we move to the next step: instead of a one-bin counting experiment we will fit a binned distribution. In a typical analysis we will produce TH1 histograms of some variable sensitive to the presence of signal: one for the data and one for each signal and background processes. Then we add a few extra lines to the datacard to link the declared processes to these shapes which are saved in a ROOT file, for example:</p> Show datacard <pre><code>imax 1\njmax 1\nkmax *\n---------------\nshapes * * simple-shapes-TH1_input.root $PROCESS $PROCESS_$SYSTEMATIC\nshapes signal * simple-shapes-TH1_input.root $PROCESS$MASS $PROCESS$MASS_$SYSTEMATIC\n---------------\nbin bin1\nobservation 85\n------------------------------\nbin             bin1       bin1\nprocess         signal     background\nprocess         0          1\nrate            10         100\n--------------------------------\nlumi     lnN    1.10       1.0\nbgnorm   lnN    1.00       1.3\nalpha  shape    -          1\n</code></pre> <p>Note that as with the one-bin card, the total nominal rate of a given process must be specified in the <code>rate</code> line of the datacard. This should agree with the value returned by <code>TH1::Integral</code>. However, we can also put a value of <code>-1</code> and the Integral value will be substituted automatically.</p> <p>There are two other differences with respect to the one-bin card:</p> <ul> <li>A new block of lines at the top defining how channels and processes are mapped to the histograms (more than one line can be used)</li> <li>In the list of systematic uncertainties some are marked as shape instead of lnN</li> </ul> <p>The syntax of the \"shapes\" line is: <code>shapes [process] [channel] [file] [histogram] [histogram_with_systematics]</code>. It is possible to use the <code>*</code> wildcard to map multiple processes and/or channels with one line. The histogram entries can contain the <code>$PROCESS</code>, <code>$CHANNEL</code> and <code>$MASS</code> place-holders which will be substituted when searching for a given (process, channel) combination. The value of <code>$MASS</code> is specified by the <code>-m</code> argument when combine. By default the observed data process name will be <code>data_obs</code>.</p> <p>Shape uncertainties can be added by supplying two additional histograms for a process, corresponding to the distribution obtained by shifting that parameter up and down by one standard deviation. These shapes will be interpolated (see the template shape uncertainties section for details) for shifts within \\pm1\\sigma and linearly extrapolated beyond. The normalizations are interpolated linearly in log scale just like we do for log-normal uncertainties.</p> <p></p> <p>The final argument of the \"shapes\" line above should contain the <code>$SYSTEMATIC</code> place-holder which will be substituted by the systematic name given in the datacard.</p> <p>In the list of uncertainties the interpretation of the values for <code>shape</code> lines is a bit different from <code>lnN</code>. The effect can be \"-\" or 0 for no effect, 1 for normal effect, and possibly something different from 1 to test larger or smaller effects (in that case, the unit Gaussian is scaled by that factor before using it as parameter for the interpolation).</p> <p>In this section we will use a datacard corresponding to the full distribution that was shown at the start of section 1, not just the high mass region. Have a look at <code>datacard_part2.txt</code>: this is still currently a one-bin counting experiment, however the yields are much higher since we now consider the full range of M_{\\mathrm{T}}^{\\mathrm{tot}}. If you run the asymptotic limit calculation on this you should find the sensitivity is significantly worse than before.</p> <p>The first task is to convert this to a shape analysis: the file <code>datacard_part2.shapes.root</code> contains all the necessary histograms, including those for the relevant shape systematic uncertainties. Add the relevant <code>shapes</code> lines to the top of the datacard (after the <code>kmax</code> line) to map the processes to the correct TH1s in this file. Hint: you will need a different line for the signal process.</p> <p>Compared to the counting experiment we must also consider the effect of uncertainties that change the shape of the distribution. Some, like <code>CMS_eff_t_highpt</code>, were present before, as it has both a shape and normalisation effect. Others are primarily shape effects so were not included before.</p> <p>Add the following shape uncertainties: <code>top_pt_ttbar_shape</code> affecting <code>ttbar</code>,the tau energy scale uncertainties <code>CMS_scale_t_1prong0pi0_13TeV</code>, <code>CMS_scale_t_1prong1pi0_13TeV</code> and <code>CMS_scale_t_3prong0pi0_13TeV</code> affecting all processes except <code>jetFakes</code>, and <code>CMS_eff_t_highpt</code> also affecting the same processes.</p> <p>Once this is done you can run the asymptotic limit calculation on this datacard. From now on we will convert the text datacard into a RooFit workspace ourselves instead of combine doing it internally every time we run. This is a good idea for more complex analyses since the conversion step can take a notable amount of time. For this we use the <code>text2workspace.py</code> command:</p> <pre><code>text2workspace.py datacard_part2.txt -m 800 -o workspace_part2.root\n</code></pre> <p>And then we can use this as input to combine instead of the text datacard:</p> <pre><code>combine -M AsymptoticLimits workspace_part2.root -m 800\n</code></pre> <p>Tasks and questions:</p> <ul> <li>Verify that the sensitivity of the shape analysis is indeed improved over the counting analysis in the first part.</li> <li>Advanced task: You can open the workspace ROOT file interactively and print the contents: <code>w-&gt;Print();</code>. Each process is represented by a PDF object that depends on the shape morphing nuisance parameters. From the workspace, choose a process and shape uncertainty, and make a plot overlaying the nominal shape with different values of the shape morphing nuisance parameter. You can change the value of a parameter with <code>w-&gt;var(\"X\")-&gt;setVal(Y)</code>, and access a particular pdf with <code>w-&gt;pdf(\"Z\")</code>. PDF objects in RooFit have a createHistogram method that requires the name of the observable (the variable defining the x-axis) - this is called <code>CMS_th1x</code> in combine datacards. Feel free to ask for help with this!</li> </ul>"},{"location":"part5/longexercise/#b-running-combine-for-a-blind-analysis","title":"B: Running combine for a blind analysis","text":"<p>Most analyses are developed and optimised while we are \"blind\" to the region of data where we expect our signal to be. With <code>AsymptoticLimits</code> we can choose just to run the expected limit (<code>--run expected</code>), so as not to calculate the observed. However the data is still used, even for the expected, since in the frequentist approach a background-only fit to the data is performed to define the Asimov dataset used to calculate the expected limits. To skip this fit to data and use the pre-fit state of the model the option <code>--run blind</code> or <code>--noFitAsimov</code> can be used. Task: Compare the expected limits calculated with <code>--run expected</code> and <code>--run blind</code>. Why are they different?</p> <p>A more general way of blinding is to use combine's toy and Asimov dataset generating functionality. You can read more about this here. These options can be used with any method in combine, not just <code>AsymptoticLimits</code>.</p> <p>Task: Calculate a blind limit by generating a background-only Asimov with the <code>-t -1</code> option instead of using the <code>AsymptoticLimits</code> specific options. You should find the observed limit is the same as the expected. Then see what happens if you inject a signal into the Asimov dataset using the <code>--expectSignal [X]</code> option.</p>"},{"location":"part5/longexercise/#c-using-fitdiagnostics","title":"C: Using FitDiagnostics","text":"<p>We will now explore one of the most commonly used modes of Combine: <code>FitDiagnostics</code> . As well as allowing us to make a measurement of some physical quantity (as opposed to just setting a limit on it), this method is useful to gain additional information about the model and the behaviour of the fit. It performs two fits:</p> <ul> <li>A \"background-only\" (b-only) fit: first POI (usually \"r\") fixed to zero</li> <li>A \"signal+background\" (s+b) fit: all POIs are floating</li> </ul> <p>With the s+b fit Combine will report the best-fit value of our signal strength modifier <code>r</code>. As well as the usual output file, a file named <code>fitDiagnosticsTest.root</code> is produced which contains additional information. In particular it includes two <code>RooFitResult</code> objects, one for the b-only and one for the s+b fit, which store the fitted values of all the nuisance parameters (NPs) and POIs as well as estimates of their uncertainties. The covariance matrix from both fits is also included, from which we can learn about the correlations between parameters. Run the <code>FitDiagnostics</code> method on our workspace:</p> <pre><code>combine -M FitDiagnostics workspace_part2.root -m 800 --rMin -20 --rMax 20\n</code></pre> <p>Open the resulting <code>fitDiagnosticsTest.root</code> interactively and print the contents of the s+b RooFitResult:</p> <pre><code>root [1] fit_s-&gt;Print()\n</code></pre> Show output <pre><code>RooFitResult: minimized FCN value: -2.55338e-05, estimated distance to minimum: 7.54243e-06\n                covariance matrix quality: Full, accurate covariance matrix\n                Status : MINIMIZE=0 HESSE=0\n\n    Floating Parameter    FinalValue +/-  Error\n  --------------------  --------------------------\n             CMS_eff_b   -4.5380e-02 +/-  9.93e-01\n             CMS_eff_t   -2.6311e-01 +/-  7.33e-01\n      CMS_eff_t_highpt   -4.7146e-01 +/-  9.62e-01\n  CMS_scale_t_1prong0pi0_13TeV   -1.5989e-01 +/-  5.93e-01\n  CMS_scale_t_1prong1pi0_13TeV   -1.6426e-01 +/-  4.94e-01\n  CMS_scale_t_3prong0pi0_13TeV   -3.0698e-01 +/-  6.06e-01\n    acceptance_Ztautau   -3.1262e-01 +/-  8.62e-01\n        acceptance_bbH   -2.8676e-05 +/-  1.00e+00\n      acceptance_ttbar    4.9981e-03 +/-  1.00e+00\n            lumi_13TeV   -5.6366e-02 +/-  9.89e-01\n         norm_jetFakes   -9.3327e-02 +/-  2.56e-01\n                     r   -2.7220e+00 +/-  2.59e+00\n    top_pt_ttbar_shape    1.7586e-01 +/-  7.00e-01\n          xsec_Ztautau   -1.6007e-01 +/-  9.66e-01\n          xsec_diboson    3.9758e-02 +/-  1.00e+00\n            xsec_ttbar    5.7794e-02 +/-  9.46e-01\n</code></pre> <p>There are several useful pieces of information here. At the top the status codes from the fits that were performed is given. In this case we can see that two algorithms were run: <code>MINIMIZE</code> and <code>HESSE</code>, both of which returned a successful status code (0). Both of these are routines in the Minuit2 minimization package - the default minimizer used in RooFit. The first performs the main fit to the data, and the second calculates the covariance matrix at the best-fit point. It is important to always check this second step was successful and the message \"Full, accurate covariance matrix\" is printed, otherwise the parameter uncertainties can be very inaccurate, even if the fit itself was successful.</p> <p>Underneath this the best-fit values (\\theta) and symmetrised uncertainties for all the floating parameters are given. For all the constrained nuisance parameters a convention is used by which the nominal value (\\theta_I) is zero, corresponding to the mean of a Gaussian constraint PDF with width 1.0, such that the parameter values \\pm 1.0 correspond to the \\pm 1\\sigma input uncertainties.</p> <p>A more useful way of looking at this is to compare the pre- and post-fit values of the parameters, to see how much the fit to data has shifted and constrained these parameters with respect to the input uncertainty. The script <code>diffNuisances.py</code> can be used for this:</p> <pre><code>python diffNuisances.py fitDiagnosticsTest.root --all\n</code></pre> Show output <pre><code>name                                              b-only fit            s+b fit         rho\nCMS_eff_b                                        -0.04, 0.99        -0.05, 0.99       +0.01\nCMS_eff_t                                     * -0.24, 0.73*     * -0.26, 0.73*       +0.06\nCMS_eff_t_highpt                              * -0.56, 0.94*     * -0.47, 0.96*       +0.02\nCMS_scale_t_1prong0pi0_13TeV                  * -0.17, 0.58*     * -0.16, 0.59*       -0.04\nCMS_scale_t_1prong1pi0_13TeV                  ! -0.12, 0.45!     ! -0.16, 0.49!       +0.20\nCMS_scale_t_3prong0pi0_13TeV                  * -0.31, 0.61*     * -0.31, 0.61*       +0.02\nacceptance_Ztautau                            * -0.31, 0.86*     * -0.31, 0.86*       -0.05\nacceptance_bbH                                   +0.00, 1.00        -0.00, 1.00       +0.05\nacceptance_ttbar                                 +0.01, 1.00        +0.00, 1.00       +0.00\nlumi_13TeV                                       -0.05, 0.99        -0.06, 0.99       +0.01\nnorm_jetFakes                                 ! -0.09, 0.26!     ! -0.09, 0.26!       -0.05\ntop_pt_ttbar_shape                            * +0.24, 0.69*     * +0.18, 0.70*       +0.22\nxsec_Ztautau                                     -0.16, 0.97        -0.16, 0.97       -0.02\nxsec_diboson                                     +0.03, 1.00        +0.04, 1.00       -0.02\nxsec_ttbar                                       +0.08, 0.95        +0.06, 0.95       +0.02\n</code></pre> <p>The numbers in each column are respectively \\frac{\\theta-\\theta_I}{\\sigma_I} (This is often called the pull, but note that this is a misnomer. In this tutorial we will refer to it as the fitted value of the nuisance parameter relative to the input uncertainty. The true pull is defined as discussed under <code>diffPullAsym</code> here ), where \\sigma_I is the input uncertainty; and the ratio of the post-fit to the pre-fit uncertainty \\frac{\\sigma}{\\sigma_I}. </p> <p>Tasks and questions:</p> <ul> <li>Which parameter has the largest shift from the nominal value (0) in the fitted value of the nuisance parameter relative to the input uncertainty? Which has the tightest constraint?</li> <li>Should we be concerned when a parameter is more strongly constrained than the input uncertainty (i.e. \\frac{\\sigma}{\\sigma_I}&lt;1.0)?</li> <li>Check the fitted values of the nuisance parameters and constraints on a b-only and s+b asimov dataset instead. This check is required for all analyses in the Higgs PAG. It serves both as a closure test (do we fit exactly what signal strength we input?) and a way to check whether there are any infeasibly strong constraints while the analysis is still blind (typical example: something has probably gone wrong if we constrain the luminosity uncertainty to 10% of the input!)</li> <li>Advanced task: Sometimes there are problems in the fit model that aren't apparent from only fitting the Asimov dataset, but will appear when fitting randomised data. Follow the exercise on toy-by-toy diagnostics here to explore the tools available for this.</li> </ul>"},{"location":"part5/longexercise/#d-mc-statistical-uncertainties","title":"D: MC statistical uncertainties","text":"<p>So far there is an important source of uncertainty we have neglected. Our estimates of the backgrounds come either from MC simulation or from sideband regions in data, and in both cases these estimates are subject to a statistical uncertainty on the number of simulated or data events.  In principle we should include an independent statistical uncertainty for every bin of every process in our model.  It's important to note that Combine/<code>RooFit</code> does not take this into account automatically - statistical fluctuations of the data are implicitly accounted  for in the likelihood formalism, but statistical uncertainties in the model must be specified by us.</p> <p>One way to implement these uncertainties is to create a <code>shape</code> uncertainty for each bin of each process, in which the up and down histograms have the contents of the bin  shifted up and down by the 1\\sigma uncertainty.  However this makes the likelihood evaluation computationally inefficient, and can lead to a large number of nuisance parameters  in more complex models. Instead we will use a feature in Combine called <code>autoMCStats</code> that creates these automatically from the datacard,  and uses a technique called \"Barlow-Beeston-lite\" to reduce the number of systematic uncertainties that are created.  This works on the assumption that for high MC event counts we can model the uncertainty with a Gaussian distribution. Given the uncertainties in different bins are independent, the total uncertainty of several processes in a particular bin is just the sum of N individual Gaussians, which is itself a Gaussian distribution.  So instead of N nuisance parameters we need only one. This breaks down when the number of events is small and we are not in the Gaussian regime.  The <code>autoMCStats</code> tool has a threshold setting on the number of events below which the the Barlow-Beeston-lite approach is not used, and instead a  Poisson PDF is used to model per-process uncertainties in that bin.</p> <p>After reading the full documentation on <code>autoMCStats</code> here, add the corresponding line to your datacard.  Start by setting a threshold of 0, i.e. <code>[channel] autoMCStats 0</code>, to force the use of Barlow-Beeston-lite in all bins.</p> <p>Tasks and questions:</p> <ul> <li>Check how much the cross section measurement and uncertainties change using <code>FitDiagnostics</code>.</li> <li>It is also useful to check how the expected uncertainty changes using an Asimov dataset, say with <code>r=10</code> injected.</li> <li>Advanced task: See what happens if the Poisson threshold is increased. Based on your results, what threshold would you recommend for this analysis?</li> </ul>"},{"location":"part5/longexercise/#part-3-adding-control-regions","title":"Part 3: Adding control regions","text":"<p>Topics covered in this section:</p> <ul> <li>A: Use of rateParams</li> <li>B: Nuisance parameter impacts</li> <li>C: Post-fit distributions</li> <li>D: Calculating the significance</li> <li>E: Signal strength measurement and uncertainty breakdown</li> <li>F: Use of channel masking</li> </ul> <p>In a modern analysis it is typical for some or all of the backgrounds to be estimated using the data, instead of relying purely on MC simulation.  This can take many forms, but a common approach is to use \"control regions\" (CRs) that are pure and/or have higher statistics for a given process.  These are defined by event selections that are similar to, but non-overlapping with, the signal region. In our \\phi\\rightarrow\\tau\\tau example the \\text{Z}\\rightarrow\\tau\\tau  background normalisation can be calibrated using a \\text{Z}\\rightarrow\\mu\\mu CR, and the \\text{t}\\bar{\\text{t}} background using an e+\\mu CR.  By comparing the number of data events in these CRs to our MC expectation we can obtain scale factors to apply to the corresponding backgrounds in the signal region (SR).  The idea is that the data will gives us a more accurate prediction of the background with less systematic uncertainties.  For example, we can remove the cross section and acceptance uncertainties in the SR, since we are no longer using the MC prediction (with a caveat discussed below).  While we could simply derive these correction factors and apply them to our signal region datacard and better way is to include these regions in our fit model and  tie the normalisations of the backgrounds in the CR and SR together. This has a number of advantages:</p> <ul> <li>Automatically handles the statistical uncertainty due to the number of data events in the CR</li> <li>Allows for the presence of some signal contamination in the CR to be handled correctly</li> <li>The CRs are typically not 100% pure in the background they're meant to control - other backgrounds may be present, with their own systematic uncertainties, some of which may be correlated with the SR or other CRs. Propagating these effects through to the SR \"by hand\" can become very challenging.</li> </ul> <p>In this section we will continue to use the same SR as in the previous one, however we will switch to a lower signal mass hypothesis, m_{\\phi}=200GeV, as its sensitivity depends more strongly on the background prediction than the high mass signal, so is better for illustrating the use of CRs. Here the nominal signal (<code>r=1</code>) has been normalised to a cross section of 1 pb.</p> <p>The SR datacard for the 200 GeV signal is <code>datacard_part3.txt</code>. Two further datacards are provided: <code>datacard_part3_ttbar_cr.txt</code> and <code>datacard_part3_DY_cr.txt</code>  which represent the CRs for the Drell-Yan and \\text{t}\\bar{\\text{t}} processes as described above.  The cross section and acceptance uncertainties for these processes have pre-emptively been removed from the SR card.  However we cannot get away with neglecting acceptance effects altogether.  We are still implicitly using the MC simulation to predict to the ratio of events in the CR and SR, and this ratio will in general carry a theoretical acceptance uncertainty.  If the CRs are well chosen then this uncertainty should be smaller than the direct acceptance uncertainty in the SR however.  The uncertainties <code>acceptance_ttbar_cr</code> and <code>acceptance_DY_cr</code> have been added to these datacards cover this effect. Task: Calculate the ratio of CR to SR events for these two processes, as well as their CR purity to verify that these are useful CRs.</p> <p>The next step is to combine these datacards into one, which is done with the <code>combineCards.py</code> script:</p> <pre><code>combineCards.py signal_region=datacard_part3.txt ttbar_cr=datacard_part3_ttbar_cr.txt DY_cr=datacard_part3_DY_cr.txt &amp;&gt; part3_combined.txt\n</code></pre> <p>Each argument is of the form <code>[new channel name]=[datacard.txt]</code>. The new datacard is written to the screen by default, so we redirect the output into our new datacard file. The output looks like:</p> Show datacard <pre><code>imax 3 number of bins\njmax 8 number of processes minus 1\nkmax 15 number of nuisance parameters\n----------------------------------------------------------------------------------------------------------------------------------\nshapes *              DY_cr          datacard_part3_DY_cr.shapes.root DY_control_region/$PROCESS DY_control_region/$PROCESS_$SYSTEMATIC\nshapes *              signal_region  datacard_part3.shapes.root signal_region/$PROCESS signal_region/$PROCESS_$SYSTEMATIC\nshapes bbHtautau      signal_region  datacard_part3.shapes.root signal_region/bbHtautau$MASS signal_region/bbHtautau$MASS_$SYSTEMATIC\nshapes *              ttbar_cr       datacard_part3_ttbar_cr.shapes.root tt_control_region/$PROCESS tt_control_region/$PROCESS_$SYSTEMATIC\n----------------------------------------------------------------------------------------------------------------------------------\nbin          signal_region  ttbar_cr       DY_cr        \nobservation  3416           79251          365754       \n----------------------------------------------------------------------------------------------------------------------------------\nbin                                               signal_region  signal_region  signal_region  signal_region  signal_region  ttbar_cr       ttbar_cr       ttbar_cr       ttbar_cr       ttbar_cr       DY_cr          DY_cr          DY_cr          DY_cr          DY_cr          DY_cr        \nprocess                                           bbHtautau      ttbar          diboson        Ztautau        jetFakes       W              QCD            ttbar          VV             Ztautau        W              QCD            Zmumu          ttbar          VV             Ztautau      \nprocess                                           0              1              2              3              4              5              6              1              7              3              5              6              8              1              7              3            \nrate                                              198.521        683.017        96.5185        742.649        2048.94        597.336        308.965        67280.4        10589.6        150.025        59.9999        141.725        305423         34341.1        5273.43        115.34       \n----------------------------------------------------------------------------------------------------------------------------------\nCMS_eff_b               lnN                       1.02           1.02           1.02           1.02           -              -              -              -              -              -              -              -              -              -              -              -            \nCMS_eff_e               lnN                       -              -              -              -              -              1.02           -              -              1.02           1.02           -              -              -              -              -              -            \n...\n</code></pre> <p>The <code>[new channel name]=</code> part of the input arguments is not required, but it gives us control over how the channels in the combined card will be named,  otherwise default values like <code>ch1</code>, <code>ch2</code> etc will be used.</p>"},{"location":"part5/longexercise/#a-use-of-rateparams","title":"A: Use of rateParams","text":"<p>We now have a combined datacard that we can run text2workspace.py on and start doing fits, however there is still one important ingredient missing. Right now the yields of the <code>Ztautau</code> process in the SR and <code>Zmumu</code> in the CR are not connected to each other in any way, and similarly for the <code>ttbar</code> processes. In the fit both would be adjusted by the nuisance parameters only, and constrained to the nominal yields. To remedy this we introduce <code>rateParam</code> directives to the datacard. A <code>rateParam</code> is a new free parameter that multiples the yield of a given process, just in the same way the signal strength <code>r</code> multiplies the signal yield. The syntax of a <code>rateParam</code> line in the datacard is</p> <pre><code>[name] rateParam [channel] [process] [init] [min,max]\n</code></pre> <p>where <code>name</code> is the chosen name for the parameter, <code>channel</code> and <code>process</code> specify which (channel, process) combination it should affect, <code>init</code> gives the initial value, and optionally <code>[min,max]</code> specifies the ranges on the RooRealVar that will be created. The <code>channel</code> and <code>process</code> arguments support the use of the wildcard <code>*</code> to match multiple entries. Task: Add two <code>rateParam</code>s with nominal values of <code>1.0</code> to the end of the combined datacard named <code>rate_ttbar</code> and <code>rate_Zll</code>. The former should affect the <code>ttbar</code> process in all channels, and the latter should affect the <code>Ztautau</code> and <code>Zmumu</code> processes in all channels. Set ranges of <code>[0,5]</code> to both. Note that a <code>rateParam</code> name can be repeated to apply it to multiple processes, e.g.:</p> <pre><code>rateScale rateParam * procA 1.0\nrateScale rateParam * procB 1.0\n</code></pre> <p>is perfectly valid and only one <code>rateParam</code> will be created. These parameters will allow the yields to float in the fit without prior constraint (unlike a regular <code>lnN</code> or <code>shape</code> systematic), with the yields in the CRs and SR tied together.</p> <p>Tasks and questions:</p> <ul> <li>Run <code>text2workspace.py</code> on this combined card (don't forget to set the mass and output name <code>-m 200 -o workspace_part3.root</code>) and then use <code>FitDiagnostics</code> on an Asimov dataset with <code>r=1</code> to get the expected uncertainty. Suggested command line options: <code>--rMin 0 --rMax 2</code></li> <li>Using the RooFitResult in the <code>fitDiagnosticsTest.root</code> file, check the post-fit value of the rateParams. To what level are the normalisations of the DY and ttbar processes constrained?</li> <li>To compare to the previous approach of fitting the SR only, with cross section and acceptance uncertainties restored, an additional card is provided: <code>datacard_part3_nocrs.txt</code>. Run the same fit on this card to verify the improvement of the SR+CR approach</li> </ul>"},{"location":"part5/longexercise/#b-nuisance-parameter-impacts","title":"B: Nuisance parameter impacts","text":"<p>It is often useful to examine in detail the effects the systematic uncertainties have on the signal strength measurement. This is often referred to as calculating the \"impact\" of each uncertainty. What this means is to determine the shift in the signal strength, with respect to the best-fit, that is induced if a given nuisance parameter is shifted by its \\pm1\\sigma post-fit uncertainty values. If the signal strength shifts a lot, it tells us that it has a strong dependency on this systematic uncertainty. In fact, what we are measuring here is strongly related to the correlation coefficient between the signal strength and the nuisance parameter. The <code>MultiDimFit</code> method has an algorithm for calculating the impact for a given systematic: <code>--algo impact -P [parameter name]</code>, but it is typical to use a higher-level script, <code>combineTool.py</code> (part of the CombineHarvester package you checked out at the beginning) to automatically run the impacts for all parameters. Full documentation on this is given here. There is a three step process for running this. First we perform an initial fit for the signal strength and its uncertainty:</p> <pre><code>combineTool.py -M Impacts -d workspace_part3.root -m 200 --rMin -1 --rMax 2 --robustFit 1 --doInitialFit\n</code></pre> <p>Then we run the impacts for all the nuisance parameters:</p> <pre><code>combineTool.py -M Impacts -d workspace_part3.root -m 200 --rMin -1 --rMax 2 --robustFit 1 --doFits\n</code></pre> <p>This will take a little bit of time. When finished we collect all the output and convert it to a json file:</p> <pre><code>combineTool.py -M Impacts -d workspace_part3.root -m 200 --rMin -1 --rMax 2 --robustFit 1 --output impacts.json\n</code></pre> <p>We can then make a plot showing the fitted values of the nuisance parameters, relative to the input uncertainty, and parameter impacts, sorted by the largest impact:</p> <pre><code>plotImpacts.py -i impacts.json -o impacts\n</code></pre> <p>Tasks and questions:</p> <ul> <li>Identify the most important uncertainties using the impacts tool.</li> <li>In the plot, some parameters do not show a fitted value of the nuisance parameter relative to the input uncertainty, but rather just a numerical value - why?</li> </ul>"},{"location":"part5/longexercise/#c-post-fit-distributions","title":"C: Post-fit distributions","text":"<p>Another thing the <code>FitDiagnostics</code> mode can help us with is visualising the distributions we are fitting, and the uncertainties on those distributions, both before the fit is performed (\"pre-fit\") and after (\"post-fit\"). The pre-fit can give us some idea of how well our uncertainties cover any data-MC discrepancy, and the post-fit if discrepancies remain after the fit to data (as well as possibly letting us see the presence of a significant signal!).</p> <p>To produce these distributions add the <code>--saveShapes</code> and <code>--saveWithUncertainties</code> options when running <code>FitDiagnostics</code>:</p> <pre><code>combine -M FitDiagnostics workspace_part3.root -m 200 --rMin -1 --rMax 2 --saveShapes --saveWithUncertainties -n .part3B\n</code></pre> <p>Combine will produce pre- and post-fit distributions (for fit_s and fit_b) in the fitDiagnosticsTest.root output file:</p> <p></p> <p>Tasks and questions:</p> <ul> <li> <p>Make a plot showing the expected background and signal contributions using the output from <code>FitDiagnostics</code> - do this for both the pre-fit and post-fit. You will find a script <code>postFitPlot.py</code> in the <code>longexercise</code> directory that can help you get started.  The bin errors on the TH1s in the fitDiagnostics file are determined from the systematic uncertainties. In the post-fit these take into account the additional constraints on the nuisance parameters as well as any correlations.</p> </li> <li> <p>Why is the uncertainty on the post-fit so much smaller than on the pre-fit?</p> </li> </ul>"},{"location":"part5/longexercise/#d-calculating-the-significance","title":"D: Calculating the significance","text":"<p>In the event that you observe a deviation from your null hypothesis, in this case the b-only hypothesis, Combine can be used to calculate the p-value or significance. To do this using the asymptotic approximation simply do:</p> <pre><code>combine -M Significance workspace_part3.root -m 200 --rMin -1 --rMax 2\n</code></pre> <p>To calculate the expected significance for a given signal strength we can just generate an Asimov dataset first:</p> <pre><code>combine -M Significance workspace_part3.root -m 200 --rMin -1 --rMax 5 -t -1 --expectSignal 1.5\n</code></pre> <p>Note that the Asimov dataset generated this way uses the nominal values of all model parameters to define the dataset. Another option is to add <code>--toysFrequentist</code>, which causes a fit to the data to be performed first (with <code>r</code> frozen to the <code>--expectSignal</code> value) and then any subsequent Asimov datasets or toys are generated using the post-fit values of the model parameters. In general this will result in a different value for the expected significance due to changes in the background normalisation and shape induced by the fit to data:</p> <pre><code>combine -M Significance workspace_part3.root -m 200 --rMin -1 --rMax 5 -t -1 --expectSignal 1.5 --toysFrequentist\n</code></pre> <p>Tasks and questions:</p> <ul> <li>Note how much the expected significance changes with the --toysFrequentist option. Does the change make sense given the difference in the post-fit and pre-fit distributions you looked at in the previous section?</li> <li>Advanced task It is also possible to calculate the significance using toys with <code>HybridNew</code> (details here) if we are in a situation where the asymptotic approximation is not reliable or if we just want to verify the result. Why might this be challenging for a high significance, say larger than 5\\sigma?</li> </ul>"},{"location":"part5/longexercise/#e-signal-strength-measurement-and-uncertainty-breakdown","title":"E: Signal strength measurement and uncertainty breakdown","text":"<p>We have seen that with <code>FitDiagnostics</code> we can make a measurement of the best-fit signal strength and uncertainty. In the asymptotic approximation we find an interval at the \\alpha CL around the best fit by identifying the parameter values at which our test statistic q=\u22122\\Delta \\ln L equals a critical value. This value is the \\alpha quantile of the \\chi^2 distribution with one degree of freedom. In the expression for q we calculate the difference in the profile likelihood between some fixed point and the best-fit.</p> <p>Depending on what we want to do with the measurement, e.g. whether it will be published in a journal, we may want to choose a more precise method for finding these intervals. There are a number of ways that parameter uncertainties are estimated in combine, and some are more precise than others:</p> <ul> <li>Covariance matrix: calculated by the Minuit HESSE routine, this gives a symmetric uncertainty by definition and is only accurate when the profile likelihood for this parameter is symmetric and parabolic.</li> <li>Minos error: calculated by the Minuit MINOS route - performs a search for the upper and lower values of the parameter that give the critical value of q for the desired CL. Return an asymmetric interval. This is what <code>FitDiagnostics</code> does by default, but only for the parameter of interest. Usually accurate but prone to fail on more complex models and not easy to control the tolerance for terminating the search.</li> <li>RobustFit error: a custom implementation in combine similar to Minos that returns an asymmetric interval, but with more control over the precision. Enabled by adding <code>--robustFit 1</code> when running <code>FitDiagnostics</code>.</li> <li>Explicit scan of the profile likelihood on a chosen grid of parameter values. Interpolation between points to find parameter values corresponding to appropriate d. It is a good idea to use this for important measurements since we can see by eye that there are no unexpected features in the shape of the likelihood curve.</li> </ul> <p>In this section we will look at the last approach, using the <code>MultiDimFit</code> mode of combine. By default this mode just performs a single fit to the data:</p> <pre><code>combine -M MultiDimFit workspace_part3.root -n .part3E -m 200 --rMin -1 --rMax 2\n</code></pre> <p>You should see the best-fit value of the signal strength reported and nothing else. By adding the <code>--algo X</code> option combine will run an additional algorithm after this best fit. Here we will use <code>--algo grid</code>, which performs a scan of the likelihood with <code>r</code> fixed to a set of different values. The set of points will be equally spaced between the <code>--rMin</code> and <code>--rMax</code> values, and the number of points is controlled with <code>--points N</code>:</p> <pre><code>combine -M MultiDimFit workspace_part3.root -n .part3E -m 200 --rMin -1 --rMax 2 --algo grid --points 30\n</code></pre> <p>The results of the scan are written into the output file, if opened interactively should see:</p> Show output <pre><code>root [1] limit-&gt;Scan(\"r:deltaNLL\")\n************************************\n*    Row   *         r *  deltaNLL *\n************************************\n*        0 * 0.5399457 *         0 *\n*        1 * -0.949999 * 5.6350698 *\n*        2 * -0.850000 * 4.9482779 *\n*        3 *     -0.75 * 4.2942519 *\n*        4 * -0.649999 * 3.6765284 *\n*        5 * -0.550000 * 3.0985388 *\n*        6 * -0.449999 * 2.5635135 *\n*        7 * -0.349999 * 2.0743820 *\n*        8 *     -0.25 * 1.6337506 *\n*        9 * -0.150000 * 1.2438088 *\n*       10 * -0.050000 * 0.9059833 *\n*       11 * 0.0500000 * 0.6215767 *\n*       12 * 0.1500000 * 0.3910581 *\n*       13 *      0.25 * 0.2144184 *\n*       14 * 0.3499999 * 0.0911308 *\n*       15 * 0.4499999 * 0.0201983 *\n*       16 * 0.5500000 * 0.0002447 *\n*       17 * 0.6499999 * 0.0294311 *\n*       18 *      0.75 * 0.1058298 *\n*       19 * 0.8500000 * 0.2272539 *\n*       20 * 0.9499999 * 0.3912534 *\n*       21 * 1.0499999 * 0.5952836 *\n*       22 * 1.1499999 * 0.8371513 *\n*       23 *      1.25 * 1.1142146 *\n*       24 * 1.3500000 * 1.4240909 *\n*       25 * 1.4500000 * 1.7644306 *\n*       26 * 1.5499999 * 2.1329684 *\n*       27 * 1.6499999 * 2.5273966 *\n*       28 *      1.75 * 2.9458723 *\n*       29 * 1.8500000 * 3.3863399 *\n*       30 * 1.9500000 * 3.8469560 *\n************************************\n</code></pre> <p>To turn this into a plot run:</p> <pre><code>python plot1DScan.py higgsCombine.part3E.MultiDimFit.mH200.root -o single_scan\n</code></pre> <p>This script will also perform a spline interpolation of the points to give accurate values for the uncertainties.</p> <p>In the next step we will split this total uncertainty into two components. It is typical to separate the contribution from statistics and systematics, and sometimes even split the systematic part into different components. This gives us an idea of which aspects of the uncertainty dominate.  The statistical component is usually defined as the uncertainty we would have if all the systematic uncertainties went to zero. We can emulate this effect by freezing all the nuisance parameters when we do the scan in <code>r</code>,  such that they do not vary in the fit. This is achieved by adding the <code>--freezeParameters allConstrainedNuisances</code> option. It would also work if the parameters are specified explicitly, e.g. <code>--freezeParameters CMS_eff_t,lumi_13TeV,...,</code> but the <code>allConstrainedNuisances</code> option is more concise. Run the scan again with the systematics frozen, and use the plotting script to overlay this curve with the previous one:</p> <pre><code>combine -M MultiDimFit workspace_part3.root -n .part3E.freezeAll -m 200 --rMin -1 --rMax 2 --algo grid --points 30 --freezeParameters allConstrainedNuisances\npython plot1DScan.py higgsCombine.part3E.MultiDimFit.mH200.root --others 'higgsCombine.part3E.freezeAll.MultiDimFit.mH200.root:FreezeAll:2' -o freeze_first_attempt\n</code></pre> <p></p> <p>This doesn't look quite right - the best-fit has been shifted because unfortunately the <code>--freezeParameters</code> option acts before the initial fit, whereas we only want to add it for the scan after this fit. To remedy this we can use a feature of Combine that lets us save a \"snapshot\" of the best-fit parameter values, and reuse this snapshot in subsequent fits. First we perform a single fit, adding the <code>--saveWorkspace</code> option:</p> <pre><code>combine -M MultiDimFit workspace_part3.root -n .part3E.snapshot -m 200 --rMin -1 --rMax 2 --saveWorkspace\n</code></pre> <p>The output file will now contain a copy of our workspace from the input, and this copy will contain a snapshot of the best-fit parameter values. We can now run the frozen scan again, but instead using this copy of the workspace as input, and restoring the snapshot that was saved:</p> <pre><code>combine -M MultiDimFit higgsCombine.part3E.snapshot.MultiDimFit.mH200.root -n .part3E.freezeAll -m 200 --rMin -1 --rMax 2 --algo grid --points 30 --freezeParameters allConstrainedNuisances --snapshotName MultiDimFit\npython plot1DScan.py higgsCombine.part3E.MultiDimFit.mH200.root --others 'higgsCombine.part3E.freezeAll.MultiDimFit.mH200.root:FreezeAll:2' -o freeze_second_attempt --breakdown Syst,Stat\n</code></pre> <p>Now the plot should look correct:</p> <p></p> <p>We added the <code>--breakdown Syst,Stat</code> option to the plotting script to make it calculate the systematic component, which is defined simply as \\sigma_{\\text{syst}} = \\sqrt{\\sigma^2_{\\text{tot}} - \\sigma^2_{\\text{stat}}}. To split the systematic uncertainty into different components we just need to run another scan with a subset of the systematics frozen. For example, say we want to split this into experimental and theoretical uncertainties, we would calculate the uncertainties as:</p> <p>\\sigma_{\\text{theory}} = \\sqrt{\\sigma^2_{\\text{tot}} - \\sigma^2_{\\text{fr.theory}}}</p> <p>\\sigma_{\\text{expt}} = \\sqrt{\\sigma^2_{\\text{fr.theory}} - \\sigma^2_{\\text{fr.theory+expt}}}</p> <p>\\sigma_{\\text{stat}} = \\sigma_{\\text{fr.theory+expt}}</p> <p>where fr.=freeze.</p> <p>While it is perfectly fine to just list the relevant nuisance parameters in the <code>--freezeParameters</code> argument for the \\sigma_{\\text{fr.theory}} scan, a convenient way can be to define a named group of parameters in the text datacard and then freeze all parameters in this group with <code>--freezeNuisanceGroups</code>. The syntax for defining a group is:</p> <pre><code>[group name] group = uncertainty_1 uncertainty_2 ... uncertainty_N\n</code></pre> <p>** Tasks and questions: **</p> <ul> <li>Take our stat+syst split one step further and separate the systematic part into two: one part for hadronic tau uncertainties and one for all others.</li> <li>Do this by defining a <code>tauID</code> group in the datacard including the following parameters: <code>CMS_eff_t</code>, <code>CMS_eff_t_highpt</code>, and the three <code>CMS_scale_t_X</code> uncertainties.</li> <li>To plot this and calculate the split via the relations above you can just add further arguments to the <code>--others</code> option in the <code>plot1DScan.py</code> script. Each is of the form: <code>'[file]:[label]:[color]'</code>. The <code>--breakdown</code> argument should also be extended to three terms.</li> <li>How important are these tau-related uncertainties compared to the others?</li> </ul>"},{"location":"part5/longexercise/#f-use-of-channel-masking","title":"F: Use of channel masking","text":"<p>We will now return briefly to the topic of blinding. We've seen that we can compute expected results by performing any Combine method on an Asimov dataset generated using <code>-t -1</code>. This is useful, because we can optimise our analysis without introducing any accidental bias that might come from looking at the data in the signal region. However our control regions have been chosen specifically to be signal-free, and it would be useful to use the data here to set the normalisation of our backgrounds even while the signal region remains blinded. Unfortunately there's no easy way to generate a partial Asimov dataset just for the signal region, but instead we can use a feature called \"channel masking\" to remove specific channels from the likelihood evaluation. One useful application of this feature is to make post-fit plots of the signal region from a control-region-only fit.</p> <p>To use the masking we first need to rerun <code>text2workspace.py</code> with an extra option that will create variables named like <code>mask_[channel]</code> in the workspace:</p> <pre><code>text2workspace.py part3_combined.txt -m 200 -o workspace_part3_with_masks.root --channel-masks\n</code></pre> <p>These parameters have a default value of 0 which means the channel is not masked. By setting it to 1 the channel is masked from the likelihood evaluation. Task: Run the same <code>FitDiagnostics</code> command as before to save the post-fit shapes, but add an option <code>--setParameters mask_signal_region=1</code>. Note that the s+b fit will probably fail in this case, since we are no longer fitting a channel that contains signal, however the b-only fit should work fine. Task: Compare the expected background distribution and uncertainty to the pre-fit, and to the background distribution from the full fit you made before.</p>"},{"location":"part5/longexercise/#part-4-physics-models","title":"Part 4: Physics models","text":"<p>Topics covered in this section:</p> <ul> <li>A: Writing a simple physics model</li> <li>B: Performing and plotting 2D likelihood scans</li> </ul> <p>With Combine we are not limited to parametrising the signal with a single scaling parameter <code>r</code>. In fact we can define any arbitrary scaling using whatever functions and parameters we would like.  For example, when measuring the couplings of the Higgs boson to the different SM particles we would introduce a POI for each coupling parameter, for example \\kappa_{\\text{W}}, \\kappa_{\\text{Z}}, \\kappa_{\\tau} etc. We would then generate scaling terms for each i\\rightarrow \\text{H}\\rightarrow j process in terms of how the cross section (\\sigma_i(\\kappa)) and branching ratio (\\frac{\\Gamma_i(\\kappa)}{\\Gamma_{\\text{tot}}(\\kappa)}) scale relative to the SM prediction.</p> <p>This parametrisation of the signal (and possibly backgrounds too) is specified in a physics model. This is a python class that is used by <code>text2workspace.py</code> to construct the model in terms of RooFit objects. There is documentation on using phyiscs models here.</p>"},{"location":"part5/longexercise/#a-writing-a-simple-physics-model","title":"A: Writing a simple physics model","text":"<p>An example physics model that just implements a single parameter <code>r</code> is given in <code>DASModel.py</code>:</p> Show DASModel.py <pre><code>from HiggsAnalysis.CombinedLimit.PhysicsModel import PhysicsModel\n\n\nclass DASModel(PhysicsModel):\n    def doParametersOfInterest(self):\n        \"\"\"Create POI and other parameters, and define the POI set.\"\"\"\n        self.modelBuilder.doVar(\"r[0,0,10]\")\n        self.modelBuilder.doSet(\"POI\", \",\".join([\"r\"]))\n\n    def getYieldScale(self, bin, process):\n        \"Return the name of a RooAbsReal to scale this yield by or the two special values 1 and 0 (don't scale, and set to zero)\"\n        if self.DC.isSignal[process]:\n            print(\"Scaling %s/%s by r\" % (bin, process))\n            return \"r\"\n        return 1\n\n\ndasModel = DASModel()\n</code></pre> <p>In this we override two methods of the basic <code>PhysicsModel</code> class: <code>doParametersOfInterest</code> and <code>getYieldScale</code>. In the first we define our POI variables, using the doVar function which accepts the RooWorkspace factory syntax for creating variables, and then define all our POIs in a set via the doSet function. The second function will be called for every process in every channel (bin), and using the corresponding strings we have to specify how that process should be scaled. Here we check if the process was declared as signal in the datacard, and if so scale it by <code>r</code>, otherwise if it is a background no scaling is applied (<code>1</code>). To use the physics model with <code>text2workspace.py</code> first copy it to the python directory in the Combine package:</p> <pre><code>cp DASModel.py $CMSSW_BASE/src/HiggsAnalysis/CombinedLimit/python/\n</code></pre> <p>In this section we will use the full datacards from the MSSM analysis. Have a look in <code>part4/200/combined.txt</code>. You will notice that there are now two signal processes declared: <code>ggH</code> and <code>bbH</code>. In the MSSM these cross sections can vary independently depending on the exact parameters of the model, so it is useful to be able to measure them independently too. First run <code>text2workspace.py</code> as follows, adding the <code>-P</code> option to specify the physics model, then verify the result of the fit:</p> <pre><code>text2workspace.py part4/200/combined.txt -P HiggsAnalysis.CombinedLimit.DASModel:dasModel -m 200 -o workspace_part4.root\ncombine -M MultiDimFit workspace_part4.root -n .part4A -m 200 --rMin 0 --rMax 2\n</code></pre> <p>Tasks and questions:</p> <ul> <li>Modify the physics model to scale the ggH and bbH processes by <code>r_ggH</code> and <code>r_bbH</code> separately.</li> <li>Then rerun the <code>MultiDimFit</code> command - you should see the result for both signal strengths printed.</li> </ul>"},{"location":"part5/longexercise/#b-performing-and-plotting-2d-likelihood-scans","title":"B: Performing and plotting 2D likelihood scans","text":"<p>For a model with two POIs it is often useful to look at the how well we are able to measure both simultaneously. A natural extension of determining 1D confidence intervals on a single parameter like we did in part 3D is to determine confidence level regions in 2D. To do this we also use combine in a similar way, with <code>-M MultiDimFit --algo grid</code>. When two POIs are found, Combine will scan a 2D grid of points instead of a 1D array.</p> <p>Tasks and questions:</p> <ul> <li>Run a 2D likelihood scan in <code>r_ggH</code> and <code>r_bbH</code>. You can start with around 100 points but may need to increase this later too see more detail in the resulting plot.</li> <li>Have a look at the output limit tree, it should have branches for each POI as well as the usual deltaNLL value. You can use TTree::Draw to plot a 2D histogram of deltaNLL with <code>r_ggH</code> and <code>r_bbH</code> on the axes.</li> </ul>"},{"location":"part5/longexerciseanswers/","title":"Answers to tasks and questions","text":""},{"location":"part5/longexerciseanswers/#part-1-a-one-bin-counting-experiment","title":"Part 1: A one-bin counting experiment","text":""},{"location":"part5/longexerciseanswers/#a-computing-limits-using-the-asymptotic-approximation","title":"A: Computing limits using the asymptotic approximation","text":"<p>Tasks and questions:</p> <ul> <li>There are some important uncertainties missing from the datacard above. Add the uncertainty on the luminosity (name: <code>lumi_13TeV</code>) which has a 2.5% effect on all processes (except the <code>jetFakes</code>, which are taken from data), and uncertainties on the inclusive cross sections of the <code>Ztautau</code> and <code>ttbar</code> processes (with names <code>xsec_Ztautau</code> and <code>xsec_diboson</code>) which are 4% and 6% respectively.</li> <li>Try changing the values of some uncertainties (up or down, or removing them altogether) - how do the expected and observed limits change?</li> </ul> Show answer  Larger uncertainties make the limits worse (ie, higher values of the limit); smaller uncertainties improve the limit (lower values of the limit).  <ul> <li>Now try changing the number of observed events. The observed limit will naturally change, but the expected does too - why might this be?</li> </ul> Show answer  This is because the expected limit relies on a background-only Asimov dataset that is created  after  a background-only fit to the data. By changing the observed the pulls on the NPs in this fit also change, and therefore so does the expected sensitivity."},{"location":"part5/longexerciseanswers/#advanced-section-b-computing-limits-with-toys","title":"Advanced section: B: Computing limits with toys","text":"<p>Tasks and questions:</p> <ul> <li>In contrast to <code>AsymptoticLimits</code>, with <code>HybridNew</code> each limit comes with an uncertainty. What is the origin of this uncertainty?</li> </ul> Show answer  The uncertainty is caused by the limited number of toys: the values of Pmu and Pb come from counting the number of toys in the tails of the test statistic distributions. The number of toys used can be adjusted with the option <code> --toysH </code> <ul> <li>How good is the agreement between the asymptotic and toy-based methods?</li> </ul> Show answer  The agreement should be pretty good in this example, but will generally break down once we get to the level of 0-5 events.  <ul> <li>Why does it take longer to calculate the lower expected quantiles (e.g. 0.025, 0.16)? Think about how the statistical uncertainty on the CLs value depends on Pmu and Pb.</li> </ul> Show answer  For this we need the definition of CLs = Pmu / (1-Pb). The 0.025 expected quantile is by definition where Pb = 0.025, so for a 95% CL limit we have CLs = 0.05, implying we are looking for the value of r where Pmu = 0.00125. With 1000 s+b toys we would then only expect `1000 * 0.00125 = 1.25` toys in the tail region we have to integrate over. Contrast this to the median limit where 25 toys would be in this region. This means we have to generate a much larger numbers of toys to get the same statistical power."},{"location":"part5/longexerciseanswers/#advanced-section-b-asymptotic-approximation-limitations","title":"Advanced section: B: Asymptotic approximation limitations","text":"<p>Tasks and questions:</p> <ul> <li>Is the asymptotic limit still a good approximation?</li> </ul> Show answer  A \"good\" approximation is not well defined, but the difference is clearly larger here.  <ul> <li>You might notice that the test statistic distributions are not smooth but rather have several \"bump\" structures? Where might this come from? Try reducing the size of the systematic uncertainties to make them more pronounced.</li> </ul> Show answer  This bump structure comes from the discrete-ness of the Poisson sampling of the toy datasets. Systematic uncertainties then smear these bumps out, but without systematics we would see delta functions corresponding to the possible integer number of events that could be observed. Once we go to more typical multi-bin analyses with more events and systematic uncertainties these discrete-ness washes out very quickly."},{"location":"part5/longexerciseanswers/#part-2-a-shape-based-analysis","title":"Part 2: A shape-based analysis","text":""},{"location":"part5/longexerciseanswers/#a-setting-up-the-datacard","title":"A: Setting up the datacard","text":"<p>Only tasks, no questions in this section</p>"},{"location":"part5/longexerciseanswers/#b-running-combine-for-a-blind-analysis","title":"B: Running combine for a blind analysis","text":"<p>Tasks and questions:</p> <ul> <li>Compare the expected limits calculated with --run expected and --run blind. Why are they different?</li> </ul> Show answer  When using --run blind combine will create a background-only Asimov dataset without performing a fit to data first. With --run expected, the observed limit isn't shown, but the background-only Asimov dataset used for the limit calculation is still created after a background-only fit to the data.  <ul> <li>Calculate a blind limit by generating a background-only Asimov with the -t option instead of using the AsymptoticLimits specific options. You should find the observed limit is the same as the expected. Then see what happens if you inject a signal into the Asimov dataset using the --expectSignal [X] option.</li> </ul> Show answer  You should see that with a signal injected the observed limit is worse (has a higher value) than the expected limit: for the expected limit the b-only Asimov dataset is still used, but the observed limit is now calculated on the signal + background Asimov dataset, with a signal at the specified cross section [X]."},{"location":"part5/longexerciseanswers/#c-using-fitdiagnostics","title":"C: Using FitDiagnostics","text":"<p>Tasks and questions:</p> <ul> <li>Which parameter has the largest shift from the nominal value? Which has the tightest constraint?</li> </ul> Show answer <code> CMS_eff_t_highpt </code> should have the largest shift from the nominal value (around 0.47), <code> norm_jetFakes </code> has the tightest constraint (to 25% of the input uncertainty).  <ul> <li>Should we be concerned when a parameter is more strongly constrained than the input uncertainty (i.e. \\frac{\\sigma}{\\sigma_I}&lt;1.0)?</li> </ul> Show answer  This is still a hot topic in CMS analyses today, and there isn't a right or wrong answer. Essentially we have to judge if our analysis should really be able to provide more information about this parameter than the external measurement that gave us the input uncertainty. So we would not expect to be able to constrain the luminosity uncertainty for example, but uncertainties specific to the analysis might legitimately be constrained."},{"location":"part5/longexerciseanswers/#d-mc-statistical-uncertainties","title":"D: MC statistical uncertainties","text":"<p>Tasks and questions:</p> <ul> <li>Check how much the cross section measurement and uncertainties change using <code>FitDiagnostics</code>.</li> </ul> Show answer  Without autoMCStats we find: <code> Best fit r: -2.73273  -2.13428/+3.38185</code>, with autoMCStats: <code> Best fit r: -3.07825  -3.17742/+3.7087 </code> <ul> <li>It is also useful to check how the expected uncertainty changes using an Asimov dataset, say with <code>r=10</code> injected.</li> </ul> Show answer  Without autoMCStats we find: <code> Best fit r: 9.99978  -4.85341/+6.56233 </code>, with autoMCStats: <code> Best fit r: 9.99985  -5.24634/+6.98266 </code> <ul> <li>Advanced task: See what happens if the Poisson threshold is increased. Based on your results, what threshold would you recommend for this analysis?</li> </ul> Show answer  At first the uncertainties increase, as the threshold increases, and at some point they stabilise. A Poisson threshold at 10 is probably reasonable for this analysis."},{"location":"part5/longexerciseanswers/#part-3-adding-control-regions","title":"Part 3: Adding control regions","text":""},{"location":"part5/longexerciseanswers/#a-use-of-rateparams","title":"A: Use of rateParams","text":"<p>Tasks and questions:</p> <ul> <li>Run <code>text2workspace.py</code> on this combined card and then use <code>FitDiagnostics</code> on an Asimov dataset with <code>r=1</code> to get the expected uncertainty. Suggested command line options: <code>--rMin 0 --rMax 2</code></li> </ul> Show answer  As expected uncertainty you should get <code> -0.417238/+0.450593 </code> <ul> <li>Using the RooFitResult in the <code>fitDiagnosticsTest.root</code> file, check the post-fit value of the rateParams. To what level are the normalisations of the DY and ttbar processes constrained?</li> </ul> Show answer  They are constrained to around 1-2%  <ul> <li>To compare to the previous approach of fitting the SR only, with cross section and acceptance uncertainties restored, an additional card is provided: <code>datacard_part3_nocrs.txt</code>. Run the same fit on this card to verify the improvement of the SR+CR approach</li> </ul> Show answer  The expected uncertainty is larger with only the SR: <code> -0.465799/+0.502088 </code> compared with <code> -0.417238/+0.450593 </code> in the SR+CR approach."},{"location":"part5/longexerciseanswers/#b-nuisance-parameter-impacts","title":"B: Nuisance parameter impacts","text":"<p>Tasks and questions:</p> <ul> <li>Identify the most important uncertainties using the impacts tool.</li> </ul> Show answer  The most important uncertainty is <code>norm_jetFakes</code>, followed by two MC statistical uncerainties (<code>prop_binsignal_region_bin8</code> and <code>prop_binsignal_region_bin9</code>). <ul> <li>In the plot, some parameters do not show a plotted point for the fitted value, but rather just a numerical value - why?</li> </ul> Show answer  These are freely floating parameters (<code> rate_ttbar </code> and <code> rate_Zll </code>). They have no prior constraint (and so no shift from the nominal value relative to the input uncertainty) - we show the best-fit value + uncertainty directly."},{"location":"part5/longexerciseanswers/#c-post-fit-distributions","title":"C: Post-fit distributions","text":"<p>Tasks and questions:</p> <p>The bin errors on the TH1s in the fitdiagnostics file are determined from the systematic uncertainties. In the post-fit these take into account the additional constraints on the nuisance parameters as well as any correlations.</p> <ul> <li>Why is the uncertainty on the post-fit so much smaller than on the pre-fit?</li> </ul> Show answer  There are two effects at play here: the nuisance parameters get constrained, and there are anti-correlations between the parameters which also have the effect of reducing the total uncertainty. Note: the post-fit uncertainty could become larger when rateParams are present as they are not taken into account in the pre-fit uncertainty but do enter in the post-fit uncertainty."},{"location":"part5/longexerciseanswers/#d-calculating-the-significance","title":"D: Calculating the significance","text":"<p>Tasks and questions:</p> <ul> <li>Advanced task It is also possible to calculate the significance using toys with <code>HybridNew</code> (details here) if we are in a situation where the asymptotic approximation is not reliable or if we just want to verify the result. Why might this be challenging for a high significance, say larger than 5\\sigma?</li> </ul> Show answer  A significance of $5\\sigma$ corresponds to a p-value of around $3\\cdot 10^{-7}$ - so we need to populate the very tail of the test statistic distribution and this requires generating a large number of toys."},{"location":"part5/longexerciseanswers/#e-signal-strength-measurement-and-uncertainty-breakdown","title":"E: Signal strength measurement and uncertainty breakdown","text":"<p>** Tasks and questions: **</p> <ul> <li>Take our stat+syst split one step further and separate the systematic part into two: one part for hadronic tau uncertainties and one for all others. Do this by defining a <code>tauID</code> group in the datacard including the following parameters: <code>CMS_eff_t</code>, <code>CMS_eff_t_highpt</code>, and the three <code>CMS_scale_t_X</code> uncertainties.</li> </ul> Show datacard line  You should add this line to the end of the datacard:  <pre><code>tauID group = CMS_eff_t CMS_eff_t_highpt CMS_scale_t_1prong0pi0_13TeV CMS_scale_t_1prong1pi0_13TeV CMS_scale_t_3prong0pi0_13TeV\n</code></pre> <ul> <li>To plot this and calculate the split via the relations above you can just add further arguments to the <code>--others</code> option in the <code>plot1DScan.py</code> script. Each is of the form: <code>'[file]:[label]:[color]'</code>. The <code>--breakdown</code> argument should also be extended to three terms.</li> </ul> Show code  This can be done as:  <pre><code>python plot1DScan.py higgsCombine.part3E.MultiDimFit.mH200.root --others 'higgsCombine.part3E.freezeTauID.MultiDimFit.mH200.root:FreezeTauID:4' 'higgsCombine.part3E.freezeAll.MultiDimFit.mH200.root:FreezeAll:2' -o freeze_third_attempt --breakdown TauID,OtherSyst,Stat\n\n</code></pre> <ul> <li>How important are these tau-related uncertainties compared to the others?</li> </ul> Show answer  They are smaller than both the statistical uncertainty and the remaining systematic uncertainties"},{"location":"part5/roofit/","title":"RooFit Basics","text":"<p><code>RooFit</code> is a OO analysis environment built on <code>ROOT</code>. It has a collection of classes designed to augment root for data modeling.</p> <p>This section covers a few of the basics of <code>RooFit</code>. There are many more tutorials available at this link: https://root.cern.ch/root/html600/tutorials/roofit/index.html</p>"},{"location":"part5/roofit/#objects","title":"Objects","text":"<p>In <code>RooFit</code>, any variable, data point, function, PDF (etc.) is represented by a c++ object The most basic of these is the <code>RooRealVar</code>. We will create one that will represent the mass of some hypothetical particle, we name it and give it an initial starting value and range.</p> <pre><code>RooRealVar MH(\"MH\",\"mass of the Hypothetical Boson (H-boson) in GeV\",125,120,130);\nMH.Print();\n</code></pre> <pre><code>RooRealVar::MH = 125  L(120 - 130)\n</code></pre> <p>Ok, great. This variable is now an object we can play around with. We can access this object and modify its properties, such as its value. </p> <pre><code>MH.setVal(130);\nMH.getVal();\n</code></pre> <p>In particle detectors we typically do not observe this particle mass, but usually define some observable which is sensitive to this mass. We will assume we can detect and reconstruct the decay products of the H-boson and measure the invariant mass of those particles. We need to make another variable that represents that invariant mass.</p> <pre><code>RooRealVar mass(\"m\",\"m (GeV)\",100,80,200);\n</code></pre> <p>In the perfect world we would perfectly measure the exact mass of the particle in every single event. However, our detectors are usually far from perfect so there will be some resolution effect. We will assume the resolution of our measurement of the invariant mass is 10 GeV and call it \"sigma\"</p> <pre><code>RooRealVar sigma(\"resolution\",\"#sigma\",10,0,20);\n</code></pre> <p>More exotic variables can be constructed out of these <code>RooRealVar</code>s using <code>RooFormulaVars</code>. For example, suppose we wanted to make a function out of the variables that represented the relative resolution as a function of the hypothetical mass MH. </p> <pre><code>RooFormulaVar func(\"R\",\"@0/@1\",RooArgList(sigma,mass));\nfunc.Print(\"v\");\n</code></pre> Show <pre><code>--- RooAbsArg ---\n  Value State: DIRTY\n  Shape State: DIRTY\n  Attributes: \n  Address: 0x10e878068\n  Clients: \n  Servers: \n    (0x10dcd47b0,V-) RooRealVar::resolution \"#sigma\"\n    (0x10dcd4278,V-) RooRealVar::m \"m (GeV)\"\n  Proxies: \n    actualVars -&gt; \n      1)  resolution\n      2)           m\n--- RooAbsReal ---\n\n  Plot label is \"R\"\n    --- RooFormula ---\n    Formula: \"@0/@1\"\n    (resolution,m)\n</code></pre> <p>Notice how there is a list of the variables we passed (the servers or \"actual vars\"). We can now plot the function. <code>RooFit</code> has a special plotting object <code>RooPlot</code> which keeps track of the objects (and their normalisations) that we want to draw. Since <code>RooFit</code> does not know the difference between objects that are and are not dependent, we need to tell it. </p> <p>Right now, we have the relative resolution as R(m,\\sigma), whereas we want to plot  R(m,\\sigma(m))!</p> <pre><code>TCanvas *can = new TCanvas();\n\n//make the x-axis the \"mass\"\nRooPlot *plot = mass.frame(); \nfunc.plotOn(plot);\n\nplot-&gt;Draw();\ncan-&gt;Draw();\n</code></pre> <p></p> <p>The main objects we are interested in using from <code>RooFit</code> are probability denisty functions or (PDFs). We can construct the PDF,</p>  f(m|M_{H},\\sigma)  <p>as a simple Gaussian shape for example or a <code>RooGaussian</code> in <code>RooFit</code> language (think McDonald's logic, everything is a <code>RooSomethingOrOther</code>)</p> <pre><code>RooGaussian gauss(\"gauss\",\"f(m|M_{H},#sigma)\",mass,MH,sigma);\ngauss.Print(\"V\");\n</code></pre> Show <pre><code>--- RooAbsArg ---\n  Value State: DIRTY\n  Shape State: DIRTY\n  Attributes: \n  Address: 0x10ecf4188\n  Clients: \n  Servers: \n    (0x10dcd4278,V-) RooRealVar::m \"m (GeV)\"\n    (0x10a08a9d8,V-) RooRealVar::MH \"mass of the Hypothetical Boson (H-boson) in GeV\"\n    (0x10dcd47b0,V-) RooRealVar::resolution \"#sigma\"\n  Proxies: \n    x -&gt; m\n    mean -&gt; MH\n    sigma -&gt; resolution\n--- RooAbsReal ---\n\n  Plot label is \"gauss\"\n--- RooAbsPdf ---\nCached value = 0\n</code></pre> <p>Notice how the gaussian PDF, like the <code>RooFormulaVar</code> depends on our <code>RooRealVar</code> objects, these are its servers.  Its evaluation will depend on their values. </p> <p>The main difference between PDFs and Functions in RooFit is that PDFs are automatically normalised to unitiy, hence they represent a probability density, you don't need to normalise yourself. Lets plot it for the different values of m.</p> <pre><code>plot = mass.frame();\n\ngauss.plotOn(plot);\n\nMH.setVal(120);\ngauss.plotOn(plot,RooFit::LineColor(kBlue));\n\nMH.setVal(125);\ngauss.plotOn(plot,RooFit::LineColor(kRed));\n\nMH.setVal(135);\ngauss.plotOn(plot,RooFit::LineColor(kGreen));\n\nplot-&gt;Draw();\n\ncan-&gt;Update();\ncan-&gt;Draw();\n</code></pre> <p></p> <p>Note that as we change the value of <code>MH</code>, the PDF gets updated at the same time.</p> <p>PDFs can be used to generate Monte Carlo data. One of the benefits of <code>RooFit</code> is that to do so only uses a single line of code! As before, we have to tell <code>RooFit</code> which variables to generate in (e.g which are the observables for an experiment). In this case, each of our events will be a single value of \"mass\" m. The arguments for the function are the set of observables, follwed by the number of events,</p> <pre><code>RooDataSet *gen_data = (RooDataSet*) gauss.generate(RooArgSet(mass),500); \n</code></pre> <p>Now we can plot the data as with other RooFit objects.</p> <pre><code>plot = mass.frame();\n\ngen_data-&gt;plotOn(plot);\ngauss.plotOn(plot);\ngauss.paramOn(plot);\n\nplot-&gt;Draw();\ncan-&gt;Update();\ncan-&gt;Draw();\n</code></pre> <p></p> <p>Of course we are not in the business of generating MC events, but collecting real data!. Next we will look at using real data in <code>RooFit</code>.</p>"},{"location":"part5/roofit/#datasets","title":"Datasets","text":"<p>A dataset is essentially just a collection of points in N-dimensional (N-observables) space. There are two basic implementations in <code>RooFit</code>, </p> <p>1) an \"unbinned\" dataset - <code>RooDataSet</code></p> <p>2) a \"binned\" dataset - <code>RooDataHist</code></p> <p>both of these use the same basic structure as below</p> <p></p> <p>We will create an empty dataset where the only observable is the mass. Points can be added to the dataset one by one ...</p> <pre><code>RooDataSet mydata(\"dummy\",\"My dummy dataset\",RooArgSet(mass)); \n// We've made a dataset with one observable (mass)\n\nmass.setVal(123.4);\nmydata.add(RooArgSet(mass));\nmass.setVal(145.2);\nmydata.add(RooArgSet(mass));\nmass.setVal(170.8);\nmydata.add(RooArgSet(mass));\n\nmydata.Print();\n</code></pre> <pre><code>RooDataSet::dummy[m] = 3 entries\n</code></pre> <p>There are also other ways to manipulate datasets in this way as shown in the diagram below </p> <p></p> <p>Luckily there are also Constructors for a <code>RooDataSet</code> from a <code>TTree</code> and for a <code>RooDataHist</code> from a <code>TH1</code> so its simple to convert from your usual ROOT objects.</p> <p>We will take an example dataset put together already. The file <code>tutorial.root</code> can be downloaded here.</p> <pre><code>TFile *file = TFile::Open(\"tutorial.root\");\nfile-&gt;ls();\n</code></pre> Show file contents <pre><code>TFile**     tutorial.root\n TFile*     tutorial.root\n  KEY: RooWorkspace workspace;1 Tutorial Workspace\n  KEY: TProcessID   ProcessID0;1    48737500-e7e5-11e6-be6f-0d0011acbeef\n</code></pre> <p>Inside the file, there is something called a <code>RooWorkspace</code>. This is just the <code>RooFit</code> way of keeping a persistent link between the objects for a model. It is a very useful way to share data and PDFs/functions etc among CMS collaborators.</p> <p>We will now take a look at it. It contains a <code>RooDataSet</code> and one variable. This time we called our variable (or observable) <code>CMS_hgg_mass</code>, we will assume that this is the invariant mass of photon pairs where we assume our H-boson decays to photons.  </p> <pre><code>RooWorkspace *wspace = (RooWorkspace*) file-&gt;Get(\"workspace\");\nwspace-&gt;Print(\"v\");\n</code></pre> Show <pre><code>RooWorkspace(workspace) Tutorial Workspace contents\n\nvariables\n---------\n(CMS_hgg_mass)\n\ndatasets\n--------\nRooDataSet::dataset(CMS_hgg_mass)\n</code></pre> <p>Now we will have a look at the data. The <code>RooWorkspace</code> has several accessor functions, we will use the <code>RooWorkspace::data</code> one.  There are also <code>RooWorkspace::var</code>, <code>RooWorkspace::function</code> and <code>RooWorkspace::pdf</code> with (hopefully) obvious purposes.</p> <pre><code>RooDataSet *hgg_data = (RooDataSet*) wspace-&gt;data(\"dataset\");\nRooRealVar *hgg_mass = (RooRealVar*) wspace-&gt;var(\"CMS_hgg_mass\");\n\nplot = hgg_mass-&gt;frame();\n\nhgg_data-&gt;plotOn(plot,RooFit::Binning(160)); \n// Here we've picked a certain number of bins just for plotting purposes \n\nTCanvas *hggcan = new TCanvas();\nplot-&gt;Draw();\nhggcan-&gt;Update();\nhggcan-&gt;Draw();\n</code></pre> <p></p>"},{"location":"part5/roofit/#likelihoods-and-fitting-to-data","title":"Likelihoods and Fitting to data","text":"<p>The data we have in our file does not look like a Gaussian distribution. Instead, we could probably use something like an exponential to describe it. </p> <p>There is an exponential PDF already in <code>RooFit</code> (yes, you guessed it) <code>RooExponential</code>. For a PDF, we only need one parameter which is the exponential slope \\alpha so our pdf is,  </p>  f(m|\\alpha) = \\dfrac{1}{N} e^{-\\alpha m} <p>Where of course, N = \\int_{110}^{150} e^{-\\alpha m} dm is the normalisation constant.</p> <p>You can find several available <code>RooFit</code> functions here: https://root.cern.ch/root/html/ROOFIT_ROOFIT_Index.html</p> <p>There is also support for a generic PDF in the form of a <code>RooGenericPdf</code>, check this link: https://root.cern.ch/doc/v608/classRooGenericPdf.html</p> <p>Now we will create an exponential PDF for our background, </p> <pre><code>RooRealVar alpha(\"alpha\",\"#alpha\",-0.05,-0.2,0.01);\nRooExponential expo(\"exp\",\"exponential function\",*hgg_mass,alpha);\n</code></pre> <p>We can use <code>RooFit</code> to tell us to estimate the value of \\alpha using this dataset. You will learn more about parameter estimation, but for now we will just assume you know about maximizing likelihoods. This maximum likelihood estimator is common in HEP and is known to give unbiased estimates for things like distribution means etc. </p> <p>This also introduces the other main use of PDFs in <code>RooFit</code>. They can be used to construct likelihoods easily.</p> <p>The likelihood \\mathcal{L} is defined for a particluar dataset (and model) as being proportional to the probability to observe the data assuming some pdf. For our data, the probability to observe an event with a value in an interval bounded by a and b is given by,</p>  P\\left(m~\\epsilon~[a,b] \\right) = \\int_{a}^{b} f(m|\\alpha)dm   <p>As that interval shrinks we can say this probability just becomes equal to f(m|\\alpha)dm.</p> <p>The probability to observe the dataset we have is given by the product of such probabilities for each of our data points, so that </p> \\mathcal{L}(\\alpha) \\propto \\prod_{i} f(m_{i}|\\alpha) <p>Note that for a specific dataset, the dm factors which should be there are constnant. They can therefore be absorbed into the constant of proportionality!</p> <p>The maximum likelihood esitmator for \\alpha, usually written as \\hat{\\alpha}, is found by maximising \\mathcal{L}(\\alpha).</p> <p>Note that this will not depend on the value of the constant of proportionality so we can ignore it. This is true in most scenarios because usually only the ratio of likelihoods is needed, in which the constant factors out. </p> <p>Obviously this multiplication of exponentials can lead to very large (or very small) numbers which can lead to numerical instabilities. To avoid this, we can take logs of the likelihood. Its also common to multiply this by -1 and minimize the resulting Negative Log Likelihood : \\mathrm{-Log}\\mathcal{L}(\\alpha).</p> <p><code>RooFit</code> can construct the NLL for us.</p> <pre><code>RooNLLVar *nll = (RooNLLVar*) expo.createNLL(*hgg_data);\nnll-&gt;Print(\"v\");\n</code></pre> Show <pre><code>--- RooAbsArg ---\n  Value State: DIRTY\n  Shape State: DIRTY\n  Attributes:\n  Address: 0x7fdddbe46200\n  Clients:\n  Servers:\n    (0x11eab5638,V-) RooRealVar::alpha \"#alpha\"\n  Proxies:\n    paramSet -&gt;\n      1)  alpha\n--- RooAbsReal ---\n\n  Plot label is \"nll_exp_dataset\"\n</code></pre> <p>Notice that the NLL object knows which RooRealVar is the parameter because it doesn't find that one in the dataset. This is how <code>RooFit</code> distiguishes between observables and parameters.</p> <p><code>RooFit</code> has an interface to Minuit via the <code>RooMinimizer</code> class which takes the NLL as an argument. To minimize, we just call the <code>RooMinimizer::minimize()</code> function. <code>Minuit2</code> is the program and <code>migrad</code> is the minimization routine which uses gradient descent.</p> <pre><code>RooMinimizer minim(*nll);\nminim.minimize(\"Minuit2\",\"migrad\");  \n</code></pre> Show <pre><code> **********\n **    1 **SET PRINT           1\n **********\n **********\n **    2 **SET NOGRAD\n **********\n PARAMETER DEFINITIONS:\n    NO.   NAME         VALUE      STEP SIZE      LIMITS\n     1 alpha       -5.00000e-02  2.10000e-02   -2.00000e-01  1.00000e-02\n **********\n **    3 **SET ERR         0.5\n **********\n **********\n **    4 **SET PRINT           1\n **********\n **********\n **    5 **SET STR           1\n **********\n NOW USING STRATEGY  1: TRY TO BALANCE SPEED AGAINST RELIABILITY\n **********\n **    6 **MIGRAD         500           1\n **********\n FIRST CALL TO USER FUNCTION AT NEW START POINT, WITH IFLAG=4.\n START MIGRAD MINIMIZATION.  STRATEGY  1.  CONVERGENCE WHEN EDM .LT. 1.00e-03\n FCN=3589.52 FROM MIGRAD    STATUS=INITIATE        4 CALLS           5 TOTAL\n                     EDM= unknown      STRATEGY= 1      NO ERROR MATRIX\n  EXT PARAMETER               CURRENT GUESS       STEP         FIRST\n  NO.   NAME      VALUE            ERROR          SIZE      DERIVATIVE\n   1  alpha       -5.00000e-02   2.10000e-02   2.24553e-01  -9.91191e+01\n                               ERR DEF= 0.5\n MIGRAD MINIMIZATION HAS CONVERGED.\n MIGRAD WILL VERIFY CONVERGENCE AND ERROR MATRIX.\n COVARIANCE MATRIX CALCULATED SUCCESSFULLY\n FCN=3584.68 FROM MIGRAD    STATUS=CONVERGED      18 CALLS          19 TOTAL\n                     EDM=1.4449e-08    STRATEGY= 1      ERROR MATRIX ACCURATE\n  EXT PARAMETER                                   STEP         FIRST\n  NO.   NAME      VALUE            ERROR          SIZE      DERIVATIVE\n   1  alpha       -4.08262e-02   2.91959e-03   1.33905e-03  -3.70254e-03\n                               ERR DEF= 0.5\n EXTERNAL ERROR MATRIX.    NDIM=  25    NPAR=  1    ERR DEF=0.5\n  8.527e-06\n</code></pre> <p><code>RooFit</code> has found the best fit value of alpha for this dataset. It also estimates an uncertainty on alpha using the Hessian matrix from the fit.</p> <pre><code>alpha.Print(\"v\");\n</code></pre> <pre><code>--- RooAbsArg ---\n  Value State: clean\n  Shape State: clean\n  Attributes:\n  Address: 0x11eab5638\n  Clients:\n    (0x11eab5978,V-) RooExponential::exp \"exponential function\"\n    (0x7fdddbe46200,V-) RooNLLVar::nll_exp_dataset \"-log(likelihood)\"\n    (0x7fdddbe95600,V-) RooExponential::exp \"exponential function\"\n    (0x7fdddbe5a400,V-) RooRealIntegral::exp_Int[CMS_hgg_mass] \"Integral of exponential function\"\n  Servers:\n  Proxies:\n--- RooAbsReal ---\n\n  Plot label is \"alpha\"\n--- RooAbsRealLValue ---\n  Fit range is [ -0.2 , 0.01 ]\n--- RooRealVar ---\n  Error = 0.00291959\n</code></pre> <p>We will plot the resulting exponential on top of the data. Notice that the value of \\hat{\\alpha} is used for the exponential. </p> <pre><code>expo.plotOn(plot);\nexpo.paramOn(plot);\nplot-&gt;Draw();\nhggcan-&gt;Update();\nhggcan-&gt;Draw();\n</code></pre> <p></p> <p>It looks like there could be a small region near 125 GeV for which our fit does not quite go through the points. Maybe our hypothetical H-boson is not so hypothetical after all!</p> <p>We will now see what happens if we include some resonant signal into the fit. We can take our Gaussian function again and use that as a signal model. A reasonable value for the resolution of a resonant signal with a mass around 125 GeV decaying to a pair of photons is around a GeV.</p> <pre><code>sigma.setVal(1.);\nsigma.setConstant();\n\nMH.setVal(125);\nMH.setConstant();\n\nRooGaussian hgg_signal(\"signal\",\"Gaussian PDF\",*hgg_mass,MH,sigma);\n</code></pre> <p>By setting these parameters constant, <code>RooFit</code> knows (either when creating the NLL by hand or when using <code>fitTo</code>) that there is not need to fit for these parameters. </p> <p>We need to add this to our exponential model and fit a \"Sigmal+Background model\" by creating a <code>RooAddPdf</code>. In <code>RooFit</code> there are two ways to add PDFs, recursively where the fraction of yields for the signal and background is a parameter or absolutely where each PDF has its own normalization. We're going to use the second one.</p> <pre><code>RooRealVar norm_s(\"norm_s\",\"N_{s}\",10,100);\nRooRealVar norm_b(\"norm_b\",\"N_{b}\",0,1000);\n\nconst RooArgList components(hgg_signal,expo);\nconst RooArgList coeffs(norm_s,norm_b);\n\nRooAddPdf model(\"model\",\"f_{s+b}\",components,coeffs);\nmodel.Print(\"v\");\n</code></pre> Show <pre><code>--- RooAbsArg ---\n  Value State: DIRTY\n  Shape State: DIRTY\n  Attributes: \n  Address: 0x11ed5d7a8\n  Clients: \n  Servers: \n    (0x11ed5a0f0,V-) RooGaussian::signal \"Gaussian PDF\"\n    (0x11ed5d058,V-) RooRealVar::norm_s \"N_{s}\"\n    (0x11eab5978,V-) RooExponential::exp \"exponential function\"\n    (0x11ed5d398,V-) RooRealVar::norm_b \"N_{b}\"\n  Proxies: \n    !refCoefNorm -&gt; \n    !pdfs -&gt; \n      1)  signal\n      2)     exp\n    !coefficients -&gt; \n      1)  norm_s\n      2)  norm_b\n--- RooAbsReal ---\n\n  Plot label is \"model\"\n--- RooAbsPdf ---\nCached value = 0\n</code></pre> <p>Ok, now we will fit the model. Note this time we add the option <code>Extended()</code>, which tells <code>RooFit</code> that we care about the overall number of observed events in the data n too. It will add an additional Poisson term in the likelihood to account for this so our likelihood this time looks like,</p> L_{s+b}(N_{s},N_{b},\\alpha) = \\dfrac{ N_{s}+N_{b}^{n} e^{N_{s}+N_{b}} }{n!} \\cdot \\prod_{i}^{n} \\left[ c f_{s}(m_{i}|M_{H},\\sigma)+ (1-c)f_{b}(m_{i}|\\alpha)  \\right]  <p>where c = \\dfrac{ N_{s} }{ N_{s} + N_{b} },   f_{s}(m|M_{H},\\sigma) is the Gaussian signal pdf and f_{b}(m|\\alpha) is the exponential pdf. Remember that M_{H} and \\sigma are fixed so that they are no longer parameters of the likelihood.</p> <p>There is a simpler interface for maximum-likelihood fits which is the <code>RooAbsPdf::fitTo</code> method. With this simple method, <code>RooFit</code> will construct the negative log-likelihood function, from the pdf, and minimize all of the free parameters in one step.</p> <pre><code>model.fitTo(*hgg_data,RooFit::Extended());\n\nmodel.plotOn(plot,RooFit::Components(\"exp\"),RooFit::LineColor(kGreen));\nmodel.plotOn(plot,RooFit::LineColor(kRed));\nmodel.paramOn(plot);\n\nhggcan-&gt;Clear();\nplot-&gt;Draw();\nhggcan-&gt;Update();\nhggcan-&gt;Draw();\n</code></pre> <p></p> <p>What about if we also fit for the mass (M_{H})? we can easily do this by removing the constant setting on MH.</p> <pre><code>MH.setConstant(false);\nmodel.fitTo(*hgg_data,RooFit::Extended());\n</code></pre> Show output <pre><code>[#1] INFO:Minization -- RooMinimizer::optimizeConst: activating const optimization\n[#1] INFO:Minization --  The following expressions will be evaluated in cache-and-track mode: (signal,exp)\n **********\n **    1 **SET PRINT           1\n **********\n **********\n **    2 **SET NOGRAD\n **********\n PARAMETER DEFINITIONS:\n    NO.   NAME         VALUE      STEP SIZE      LIMITS\n     1 MH           1.25000e+02  1.00000e+00    1.20000e+02  1.30000e+02\n     2 alpha       -4.08793e-02  2.96856e-03   -2.00000e-01  1.00000e-02\n     3 norm_b       9.67647e+02  3.25747e+01    0.00000e+00  1.00000e+03\n MINUIT WARNING IN PARAMETR\n ============== VARIABLE3 BROUGHT BACK INSIDE LIMITS.\n     4 norm_s       3.22534e+01  1.16433e+01    1.00000e+01  1.00000e+02\n **********\n **    3 **SET ERR         0.5\n **********\n **********\n **    4 **SET PRINT           1\n **********\n **********\n **    5 **SET STR           1\n **********\n NOW USING STRATEGY  1: TRY TO BALANCE SPEED AGAINST RELIABILITY\n **********\n **    6 **MIGRAD        2000           1\n **********\n FIRST CALL TO USER FUNCTION AT NEW START POINT, WITH IFLAG=4.\n START MIGRAD MINIMIZATION.  STRATEGY  1.  CONVERGENCE WHEN EDM .LT. 1.00e-03\n FCN=-2327.53 FROM MIGRAD    STATUS=INITIATE       10 CALLS          11 TOTAL\n                     EDM= unknown      STRATEGY= 1      NO ERROR MATRIX       \n  EXT PARAMETER               CURRENT GUESS       STEP         FIRST   \n  NO.   NAME      VALUE            ERROR          SIZE      DERIVATIVE \n   1  MH           1.25000e+02   1.00000e+00   2.01358e-01   1.12769e+01\n   2  alpha       -4.08793e-02   2.96856e-03   3.30048e-02  -1.22651e-01\n   3  norm_b       9.67647e+02   3.25747e+01   2.56674e-01  -1.96463e-02\n   4  norm_s       3.22534e+01   1.16433e+01   3.10258e-01  -8.97036e-04\n                               ERR DEF= 0.5\n MIGRAD MINIMIZATION HAS CONVERGED.\n MIGRAD WILL VERIFY CONVERGENCE AND ERROR MATRIX.\n COVARIANCE MATRIX CALCULATED SUCCESSFULLY\n FCN=-2327.96 FROM MIGRAD    STATUS=CONVERGED      65 CALLS          66 TOTAL\n                     EDM=1.19174e-05    STRATEGY= 1      ERROR MATRIX ACCURATE \n  EXT PARAMETER                                   STEP         FIRST   \n  NO.   NAME      VALUE            ERROR          SIZE      DERIVATIVE \n   1  MH           1.24628e+02   3.98153e-01   2.66539e-03   2.46327e-02\n   2  alpha       -4.07708e-02   2.97195e-03   1.10093e-03   8.33780e-02\n   3  norm_b       9.66105e+02   3.25772e+01   5.96627e-03   1.83523e-03\n   4  norm_s       3.39026e+01   1.17380e+01   9.60816e-03  -2.32681e-03\n                               ERR DEF= 0.5\n EXTERNAL ERROR MATRIX.    NDIM=  25    NPAR=  4    ERR DEF=0.5\n  1.589e-01 -3.890e-05  1.462e-01 -1.477e-01 \n -3.890e-05  8.836e-06 -2.020e-04  2.038e-04 \n  1.462e-01 -2.020e-04  1.073e+03 -1.072e+02 \n -1.477e-01  2.038e-04 -1.072e+02  1.420e+02 \n PARAMETER  CORRELATION COEFFICIENTS  \n       NO.  GLOBAL      1      2      3      4\n        1  0.04518   1.000 -0.033  0.011 -0.031\n        2  0.03317  -0.033  1.000 -0.002  0.006\n        3  0.27465   0.011 -0.002  1.000 -0.275\n        4  0.27610  -0.031  0.006 -0.275  1.000\n **********\n **    7 **SET ERR         0.5\n **********\n **********\n **    8 **SET PRINT           1\n **********\n **********\n **    9 **HESSE        2000\n **********\n COVARIANCE MATRIX CALCULATED SUCCESSFULLY\n FCN=-2327.96 FROM HESSE     STATUS=OK             23 CALLS          89 TOTAL\n                     EDM=1.19078e-05    STRATEGY= 1      ERROR MATRIX ACCURATE \n  EXT PARAMETER                                INTERNAL      INTERNAL  \n  NO.   NAME      VALUE            ERROR       STEP SIZE       VALUE   \n   1  MH           1.24628e+02   3.98106e-01   5.33077e-04  -7.45154e-02\n   2  alpha       -4.07708e-02   2.97195e-03   2.20186e-04   5.42722e-01\n   3  norm_b       9.66105e+02   3.26003e+01   2.38651e-04   1.20047e+00\n   4  norm_s       3.39026e+01   1.17445e+01   3.84326e-04  -4.87967e-01\n                               ERR DEF= 0.5\n EXTERNAL ERROR MATRIX.    NDIM=  25    NPAR=  4    ERR DEF=0.5\n  1.588e-01 -3.888e-05  1.304e-01 -1.304e-01 \n -3.888e-05  8.836e-06 -1.954e-04  1.954e-04 \n  1.304e-01 -1.954e-04  1.074e+03 -1.082e+02 \n -1.304e-01  1.954e-04 -1.082e+02  1.421e+02 \n PARAMETER  CORRELATION COEFFICIENTS  \n       NO.  GLOBAL      1      2      3      4\n        1  0.04274   1.000 -0.033  0.010 -0.027\n        2  0.03314  -0.033  1.000 -0.002  0.006\n        3  0.27694   0.010 -0.002  1.000 -0.277\n        4  0.27806  -0.027  0.006 -0.277  1.000\n[#1] INFO:Minization -- RooMinimizer::optimizeConst: deactivating const optimization\n</code></pre> <p>Notice the result for the fitted MH is not 125 and is included in the list of fitted parameters.  We can get more information about the fit, via the <code>RooFitResult</code>, using the option <code>Save()</code>. </p> <pre><code>RooFitResult *fit_res = (RooFitResult*) model.fitTo(*hgg_data,RooFit::Extended(),RooFit::Save());\n</code></pre> <p>For example, we can get the Correlation Matrix from the fit result... Note that the order of the parameters are the same as listed in the \"Floating Parameter\" list above</p> <pre><code>TMatrixDSym cormat = fit_res-&gt;correlationMatrix();\ncormat.Print();\n</code></pre> <pre><code>4x4 matrix is as follows\n\n     |      0    |      1    |      2    |      3    |\n---------------------------------------------------------\n   0 |          1    -0.03282    0.009538    -0.02623 \n   1 |   -0.03282           1   -0.001978    0.005439 \n   2 |   0.009538   -0.001978           1     -0.2769 \n   3 |   -0.02623    0.005439     -0.2769           1 \n</code></pre> <p>A nice feature of <code>RooFit</code> is that once we have a PDF, data and results like this, we can import this new model into our <code>RooWorkspace</code> and show off our new discovery to our LHC friends (if we weren't already too late!). We can also save the \"state\" of our parameters for later, by creating a snapshot of the current values. </p> <pre><code>wspace-&gt;import(model);  \nRooArgSet *params = model.getParameters(*hgg_data);\nwspace-&gt;saveSnapshot(\"nominal_values\",*params);\n\nwspace-&gt;Print(\"V\");\n</code></pre> Show output <pre><code>RooWorkspace(workspace) Tutorial Workspace contents\n\nvariables\n---------\n(CMS_hgg_mass,MH,alpha,norm_b,norm_s,resolution)\n\np.d.f.s\n-------\nRooExponential::exp[ x=CMS_hgg_mass c=alpha ] = 0.00248636\nRooAddPdf::model[ norm_s * signal + norm_b * exp ] = 0.00240205\nRooGaussian::signal[ x=CMS_hgg_mass mean=MH sigma=resolution ] = 5.34013e-110\n\ndatasets\n--------\nRooDataSet::dataset(CMS_hgg_mass)\n\nparameter snapshots\n-------------------\nnominal_values = (MH=124.627 +/- 0.398094,resolution=1[C],norm_s=33.9097 +/- 11.7445,alpha=-0.040779 +/- 0.00297195,norm_b=966.109 +/- 32.6025)\n</code></pre> <p>This is exactly what needs to be done when you want to use shape based datacards in Combine with parametric models.</p>"},{"location":"part5/roofit/#a-likelihood-for-a-counting-experiment","title":"A likelihood for a counting experiment","text":"<p>An introductory presentation about likelihoods and interval estimation is available here.</p> <p>**Note: We will use python syntax in this section; you should use a .py script. Make sure to do <code>import ROOT</code> at the top of your script **</p> <p>We have seen how to create variables and PDFs, and how to fit a PDF to data. But what if we have a counting experiment, or a histogram template shape? And what about systematic uncertainties?  We are going to build a likelihood  for this:</p> <p>\\mathcal{L} \\propto p(\\text{data}|\\text{parameters})</p> <p>where our parameters are parameters of interest, \\mu, and nuisance parameters, \\theta. The nuisance parameters are constrained by external measurements, so we add constraint terms \\pi(\\vec{\\theta}_0|\\vec{\\theta})</p> <p>So we have \\mathcal{L} \\propto p(\\text{data}|\\mu,\\vec{\\theta})\\cdot \\pi(\\vec{\\theta}_0|\\vec{\\theta})</p> <p>now we will try to build the likelihood by hand for a 1-bin counting experiment. The data is the number of observed events N, and the probability is just a Poisson probability p(N|\\lambda) = \\frac{\\lambda^N e^{-\\lambda}}{N!}, where \\lambda is the number of events expected in our signal+background model: \\lambda = \\mu\\cdot s(\\vec{\\theta}) + b(\\vec{\\theta}). </p> <p>In the expression, s and b are the numbers of expected signal and background events, which both depend on the nuisance parameters. We will start by building a simple likelihood function with one signal process and one background process. We will assume there are no nuisance parameters for now. The number of observed events in data is 15, the expected number of signal events is 5 and the expected number of background events 8.1.</p> <p>It is easiest to use the <code>RooFit</code> workspace factory to build our model (this tutorial has more information on the factory syntax).</p> <pre><code>import ROOT\nw = ROOT.RooWorkspace(\"w\")\n</code></pre> <p>We need to create an expression for the number of events in our model, \\mu s +b:</p> <pre><code>w.factory('expr::n(\"mu*s +b\", mu[1.0,0,4], s[5],b[8.1])')\n</code></pre> <p>Now we can build the likelihood, which is just our Poisson PDF:</p> <pre><code>w.factory('Poisson::poisN(N[15],n)')\n</code></pre> <p>To find the best fit value for our parameter of interest \\mu we need to maximize the likelihood. In practice it is actually easier to minimize the Negative log of the likelihood, or NLL:</p> <pre><code>w.factory('expr::NLL(\"-log(@0)\",poisN)')\n</code></pre> <p>We can now use the <code>RooMinimizer</code> to find the minimum of the NLL</p> <pre><code>nll = w.function(\"NLL\")\nminim = ROOT.RooMinimizer(nll)\nminim.setErrorLevel(0.5)\nminim.minimize(\"Minuit2\",\"migrad\")\nbestfitnll = nll.getVal()\n</code></pre> <p>Notice that we need to set the error level to 0.5 to get the uncertainties (relying on Wilks' theorem!) - note that there is a more reliable way of extracting the confidence interval (explicitly rather than relying on migrad). We will discuss this a bit later in this section.</p> <p>Now we will add a nuisance parameter, lumi, which represents the luminosity uncertainty. It has a 2.5% effect on both the signal and the background. The parameter will be log-normally distributed: when it's 0, the normalization of the signal and background are not modified; at +1\\sigma the signal and background normalizations will be multiplied by 1.025 and at -1\\sigma they will be divided by 1.025.  We should modify the expression for the number of events in our model:</p> <pre><code>w.factory('expr::n(\"mu*s*pow(1.025,lumi) +b*pow(1.025,lumi)\", mu[1.0,0,4], s[5],b[8.1],lumi[0,-4,4])')\n</code></pre> <p>And we add a unit gaussian constraint </p> <pre><code>w.factory('Gaussian::lumiconstr(lumi,0,1)')\n</code></pre> <p>Our full likelihood will now be</p> <pre><code>w.factory('PROD::likelihood(poisN,lumiconstr)')\n</code></pre> <p>and the NLL</p> <pre><code>w.factory('expr::NLL(\"-log(@0)\",likelihood)')\n</code></pre> <p>Which we can minimize in the same way as before. </p> <p>Now we will extend our model a bit. </p> <ul> <li>Expanding on what was demonstrated above, build the likelihood for N=15, a signal process s with expectation 5 events, a background ztt with expectation 3.7 events and a background tt with expectation 4.4 events. The luminosity uncertainty applies to all three processes. The signal process is further subject to a 5% log-normally distributed uncertainty sigth, tt is subject to a 6% log-normally distributed uncertainty ttxs, and ztt is subject to a 4% log-normally distributed uncertainty zttxs. Find the best-fit value and the associated uncertainty</li> <li>Also perform an explicit scan of the \\Delta NLL ( = log of profile likelihood ratio) and make a graph of the scan. Some example code can be found below to get you started. Hint: you'll need to perform fits for different values of mu, where mu is fixed. In <code>RooFit</code> you can set a variable to be constant as <code>var(\"VARNAME\").setConstant(True)</code></li> <li>From the curve that you have created by performing an explicit scan, we can extract the 68% CL interval. You can do so by eye or by writing some code to find the relevant intersections of the curve. </li> </ul> <pre><code>gr = ROOT.TGraph()\n\nnpoints = 0\nfor i in range(0,60):\n  npoints+=1\n  mu=0.05*i\n  ...\n  [perform fits for different values of mu with mu fixed]\n  ...\n  deltanll = ...\n  gr.SetPoint(npoints,mu,deltanll)\n\n\ncanv = ROOT.TCanvas()\ngr.Draw(\"ALP\")\ncanv.SaveAs(\"likelihoodscan.pdf\")\n</code></pre> <p>Well, this is doable - but we were only looking at a simple one-bin counting experiment. This might become rather cumbersome for large models... [*] We will now switch to Combine which will make it a lot easier to set up your model and do the statistical analysis than trying to build the likelihood yourself.</p> <p>[*] Side note - <code>RooFit</code> does have additional functionality to help with statistical model building, but we will not go into detail today.   </p>"},{"location":"tutorial2023/parametric_exercise/","title":"Parametric Models in Combine","text":""},{"location":"tutorial2023/parametric_exercise/#getting-started","title":"Getting started","text":"<p>By now you should have a working setup of Combine v9 from the pre-tutorial exercise. If so then move onto the cloning of the parametric fitting exercise gitlab repo below. If not then you need to set up a CMSSW area and checkout the combine package:</p> <pre><code>cmsrel CMSSW_11_3_4\ncd CMSSW_11_3_4/src\ncmsenv\ngit clone https://github.com/cms-analysis/HiggsAnalysis-CombinedLimit.git HiggsAnalysis/CombinedLimit\ncd HiggsAnalysis/CombinedLimit\n\ncd $CMSSW_BASE/src/HiggsAnalysis/CombinedLimit\ngit fetch origin\ngit checkout v9.0.0\n</code></pre> <p>We will also make use of another package, <code>CombineHarvester</code>, which contains some high-level tools for working with combine. The following command will download the repository and checkout just the parts of it we need for this exercise:</p> <pre><code>cd $CMSSW_BASE/src/\nbash &lt;(curl -s https://raw.githubusercontent.com/cms-analysis/CombineHarvester/main/CombineTools/scripts/sparse-checkout-https.sh)\n</code></pre> <p>Now let's compile the CMSSW area:</p> <pre><code>scramv1 b clean; scramv1 b\ncmsenv\n</code></pre> <p>Finally, let's clone the working directory for this tutorial which contains all of the inputs and scripts needed to run the parametric fitting exercise:</p> <pre><code>cd $CMSSW_BASE/src/\ngit clone https://gitlab.cern.ch/jlangfor/combinetutorial-2023-parametric.git\ncd combinetutorial-2023-parametric\n</code></pre>"},{"location":"tutorial2023/parametric_exercise/#session-structure","title":"Session structure","text":"<p>The exercise is split into six parts which cover:</p> <p>1) Parametric model building</p> <p>2) Simple fits</p> <p>3) Systematic uncertainties</p> <p>4) Toy generation</p> <p>5) Discrete profiling</p> <p>6) Multi-signal hypothesis</p> <p>Throughout the tutorial there are a number of questions and exercises for you to complete. These are shown by the bullet points in this markdown file.</p> <p>All the code required to run the different parts is available in python scripts. We have purposely commented out the code to encourage you to open the scripts and take a look what is inside. Each block is separated by a divider and a blank line. When you are happy and understand the code, you can uncomment (block by block) and then run the scripts (using python3) e.g.:</p> <pre><code>python3 construct_models_part1.py\n</code></pre> <p>A number of scripts will produce plots (as .png files). The default path to store these plots is in the current working directory. You can change this (e.g. pipe to an eos webpage) by changing the <code>plot_dir</code> variable in the <code>config.py</code> script.</p> <p>There's also a set of combine (.txt) datacards which will help you get through the various parts of the exercise. The exercises should help you become familiar with the structure of parametric fitting datacards.</p> <p>Finally, this exercise is heavily based off the <code>RooFit</code> package. So if you find yourself using the python interpreter for any checks, don't forget to...</p> <pre><code>import ROOT\n</code></pre>"},{"location":"tutorial2023/parametric_exercise/#jupyter-notebooks","title":"Jupyter notebooks","text":"<p>Alternatively, we have provided <code>Jupyter</code> notebooks to run the different parts of the exercise e.g. <code>part1.ipynb</code>. You will have already downloaded these notebooks when cloning the tutorial gitlab repo. To open Jupyter notebooks on lxplus within a CMSSW environment, you can add the following option when you <code>ssh</code> into lxplus:</p> <pre><code>ssh -X -Y username@lxplus.cern.ch -L8xxx:localhost:8xxx\n</code></pre> <p>where you should replace <code>xxx</code> with some three digit number. Then <code>cd</code> into the <code>combinetutorial-2023-parametric</code> directory and set up the CMSSW environment with:</p> <pre><code>cmsenv\n</code></pre> <p>You can then open the Jupyter notebook inside the environment with:</p> <pre><code>jupyter notebook --no-browser --port 8xxx\n</code></pre> <p>replacing <code>xxx</code> with the same three digit number. You should now be able to copy the url it provides into a browser and access the various exercise notebooks.</p>"},{"location":"tutorial2023/parametric_exercise/#analysis-overview","title":"Analysis overview","text":"<p>In this exercise we will look at one of the most famous parametric fitting analyses at the LHC: the Higgs boson decaying to two photons (H \\rightarrow \\gamma\\gamma). This decay channel is key in understanding the properties of the Higgs boson due to its clean final state topology. The excellent energy resolution- of the CMS electromagnetic calorimeter leads to narrow signal peak in the diphoton invariant mass spectrum, m_{\\gamma\\gamma}, above a smoothly falling background continuum. The mass spectrum for the legacy Run 2 analysis is shown below.</p> <p></p> <p>In the analysis, we construct parametric models (analytic functions) of both signal and background events to fit the m_{\\gamma\\gamma} spectrum in data. From the fit we can extract measurements of Higgs boson properties including its rate of production, its mass (m_H), its coupling behaviour, to name a few. This exercise will show how to construct parametric models using RooFit, and subsequently how to use combine to extract the results.</p>"},{"location":"tutorial2023/parametric_exercise/#part-1-parametric-model-building","title":"Part 1: Parametric model building","text":"<p>As with any fitting exercise, the first step is to understand the format of the input data, explore its contents and construct a model. The python script which performs the model construction is <code>construct_models_part1.py</code>. This section will explain what the various lines of code are doing.</p>"},{"location":"tutorial2023/parametric_exercise/#signal-modelling","title":"Signal modelling","text":"<p>Firstly, we will construct a model to fit the signal (H \\rightarrow\\gamma\\gamma) mass peak using a Monte Carlo simulation sample of gluon-gluon fusion production (ggH) events with m_H=125 GeV. This production mode has the largest cross section in the SM, and the LO Feynman diagram is shown below.</p> <p></p> <p>There has already been a dedicated selection performed on the events to increase the signal-to-background ratio (e.g. using some ML event classifier). Events passing this selection enter the analysis category, Tag0. Events entering Tag0 are used for the parametric fitting of the m_{\\gamma\\gamma} spectrum. </p> <p>The events are stored in a ROOT <code>TTree</code>, where the diphoton mass, <code>CMS_hgg_mass</code>, and the event weight, <code>weight</code>, are saved. Let's begin by loading the MC, and converting the <code>TTree</code> data into <code>RooDataSet</code>:</p> <pre><code>import ROOT\nROOT.gROOT.SetBatch(True)\n\nf = ROOT.TFile(\"mc_part1.root\",\"r\")\n# Load TTree\nt = f.Get(\"ggH_Tag0\")\n\n# Define mass and weight variables\nmass = ROOT.RooRealVar(\"CMS_hgg_mass\", \"CMS_hgg_mass\", 125, 100, 180)\nweight = ROOT.RooRealVar(\"weight\",\"weight\",0,0,1)\n\n# Convert to RooDataSet\nmc = ROOT.RooDataSet(\"ggH_Tag0\",\"ggH_Tag0\", t, ROOT.RooArgSet(mass,weight), \"\", \"weight\" )\n\n# Lets plot the signal mass distribution\ncan = ROOT.TCanvas()\nplot = mass.frame()\nmc.plotOn(plot)\nplot.Draw()\ncan.Update()\ncan.SaveAs(\"part1_signal_mass.png\")\n</code></pre> <p></p> <p>The plot shows a peak centred on the Higgs mass at 125 GeV. Let's use a simple Gaussian to model the peak.</p> <pre><code># Introduce a RooRealVar into the workspace for the Higgs mass\nMH = ROOT.RooRealVar(\"MH\", \"MH\", 125, 120, 130 )\nMH.setConstant(True)\n\n# Signal peak width\nsigma = ROOT.RooRealVar(\"sigma_ggH_Tag0\", \"sigma_ggH_Tag0\", 2, 1, 5)\n\n# Define the Gaussian with mean=MH and width=sigma\nmodel = ROOT.RooGaussian( \"model_ggH_Tag0\", \"model_ggH_Tag0\", mass, MH, sigma ) \n\n# Fit Gaussian to MC events and plot\nmodel.fitTo(mc,ROOT.RooFit.SumW2Error(True))\n\ncan = ROOT.TCanvas()\nplot = mass.frame()\nmc.plotOn(plot)\nmodel.plotOn( plot, ROOT.RooFit.LineColor(2) )\nplot.Draw()\ncan.Update()\ncan.Draw()\ncan.SaveAs(\"part1_signal_model_v0.png\")\n</code></pre> <p></p> <p>It looks like a good fit! </p> <ul> <li>Do you understand the output from the <code>fitTo</code> command (i.e the mimimization)? From now on we will add the option <code>ROOT.RooFit.PrintLevel(-1)</code> when fitting the models to surpress the minimizer output. </li> </ul> <p>But what if the mean of the model does not correspond directly to the Higgs boson mass i.e. there are some reconstruction effects. Let's instead define the mean of the model as:</p> \\mu = m_H + \\delta <p>and we can fit for \\delta in the model construction. For this we introduce a <code>RooFormulaVar</code>.</p> <pre><code>dMH = ROOT.RooRealVar(\"dMH_ggH_Tag0\", \"dMH_ggH_Tag0\", 0, -1, 1 )\nmean = ROOT.RooFormulaVar(\"mean_ggH_Tag0\", \"mean_ggH_Tag0\", \"(@0+@1)\", ROOT.RooArgList(MH,dMH))\nmodel = ROOT.RooGaussian( \"model_ggH_Tag0\", \"model_ggH_Tag0\", mass, mean, sigma )\n\n# Fit the new model with a variable mean\nmodel.fitTo(mc,ROOT.RooFit.SumW2Error(True),ROOT.RooFit.PrintLevel(-1))\n\n# Model is parametric in MH. Let's show this by plotting for different values of MH\ncan = ROOT.TCanvas()\nplot = mass.frame()\nMH.setVal(120)\nmodel.plotOn( plot, ROOT.RooFit.LineColor(2) )\nMH.setVal(125)\nmodel.plotOn( plot, ROOT.RooFit.LineColor(3) )\nMH.setVal(130)\nmodel.plotOn( plot, ROOT.RooFit.LineColor(4) )\nplot.Draw()\ncan.Update()\ncan.SaveAs(\"part1_signal_model_v1.png\")\n</code></pre> <p></p> <p>Let's now save the model inside a <code>RooWorkspace</code>. Combine will load this model when performing the fits. Crucially, we need to freeze the fit parameters of the signal model, otherwise they will be freely floating in the final results extraction. </p> <ul> <li>This choice of setting the shape parameters to constant means we believe our MC will perfectly model the Higgs boson events in data. Is this the case? How could we account for the MC mis-modelling in the fit? (See part 3).</li> </ul> <pre><code>MH.setVal(125)\ndMH.setConstant(True)\nsigma.setConstant(True)\n\nf_out = ROOT.TFile(\"workspace_sig.root\", \"RECREATE\")\nw_sig = ROOT.RooWorkspace(\"workspace_sig\",\"workspace_sig\")\ngetattr(w_sig, \"import\")(model)\nw_sig.Print()\nw_sig.Write()\nf_out.Close()\n</code></pre> <p>We have successfully constructed a parametric model to fit the shape of the signal peak. But we also need to know the yield/normalisation of the ggH signal process. In the SM, the ggH event yield in Tag0 is equal to:</p>  N = \\sigma_{ggH} \\cdot \\mathcal{B}^{\\gamma\\gamma} \\cdot \\epsilon \\cdot \\mathcal{L} <p>Where \\sigma_{ggH} is the SM ggH cross section, \\mathcal{B}^{\\gamma\\gamma} is the SM branching fraction of the Higgs boson to two photons, \\epsilon is the efficiency factor and corresponds to the fraction of the total ggH events landing in the Tag0 analysis category. Finally \\mathcal{L} is the integrated luminosity.</p> <p>In this example, the ggH MC events are normalised before any selection is performed to \\sigma_{ggH} \\cdot \\mathcal{B}^{\\gamma\\gamma}, taking the values from the LHCHWG twiki. Note this does not include the lumi scaling, which may be different to what you have in your own analyses! We can then calculate the efficiency factor, \\epsilon, by taking the sum of weights in the MC dataset and dividing through by \\sigma_{ggH} \\cdot \\mathcal{B}^{\\gamma\\gamma}. This will tell us what fraction of ggH events land in Tag0.</p> <pre><code># Define SM cross section and branching fraction values\nxs_ggH = 48.58 #in [pb]\nbr_gamgam = 2.7e-3\n\n# Calculate the efficiency and print output\nsumw = mc.sumEntries()\neff = sumw/(xs_ggH*br_gamgam)\nprint(\"Efficiency of ggH events landing in Tag0 is: %.2f%%\"%(eff*100))\n\n# Calculate the total yield (assuming full Run 2 lumi) and print output\nlumi = 138000\nN = xs_ggH*br_gamgam*eff*lumi\nprint(\"For 138fb^-1, total normalisation of signal is: N = xs * br * eff * lumi = %.2f events\"%N)\n</code></pre> <p>Gives the output:</p> <pre><code>Efficiency of ggH events landing in Tag0 is: 1.00%\nFor 138fb^-1, total normalisation of signal is: N = xs * br * eff * lumi = 181.01 events\n</code></pre> <p>So we find 1% of all ggH events enter Tag0. And the total expected yield of ggH events in Tag0 (with lumi scaling) is <code>181.01</code>. Lets make a note of this for later!</p>"},{"location":"tutorial2023/parametric_exercise/#background-modelling","title":"Background modelling","text":"<p>In the H \\rightarrow\\gamma\\gamma analysis we construct the background model directly from data. To avoid biasing our background estimate, we remove the signal region from the model construction and fit the mass sidebands. Let's begin by loading the data <code>TTree</code> and converting to a <code>RooDataSet</code>. We will then plot the mass sidebands.</p> <pre><code>f = ROOT.TFile(\"data_part1.root\",\"r\")\nt = f.Get(\"data_Tag0\")\n\n# Convert TTree to a RooDataSet\ndata = ROOT.RooDataSet(\"data_Tag0\", \"data_Tag0\", t, ROOT.RooArgSet(mass), \"\", \"weight\")\n\n# Define mass sideband ranges on the mass variable: 100-115 and 135-180\nn_bins = 80\nbinning = ROOT.RooFit.Binning(n_bins,100,180)\nmass.setRange(\"loSB\", 100, 115 )\nmass.setRange(\"hiSB\", 135, 180 )\nmass.setRange(\"full\", 100, 180 )\nfit_range = \"loSB,hiSB\"\n\n# Plot the data in the mass sidebands\ncan = ROOT.TCanvas()\nplot = mass.frame()\ndata.plotOn( plot, ROOT.RooFit.CutRange(fit_range), binning )\nplot.Draw()\ncan.Update()\ncan.Draw()\ncan.SaveAs(\"part1_data_sidebands.png\")\n</code></pre> <p></p> <p>By eye, it looks like an exponential function would fit the data sidebands well. Let's construct the background model using a <code>RooExponential</code> and fit the data sidebands:</p> <pre><code>alpha = ROOT.RooRealVar(\"alpha\", \"alpha\", -0.05, -0.2, 0 )\nmodel_bkg = ROOT.RooExponential(\"model_bkg_Tag0\", \"model_bkg_Tag0\", mass, alpha )\n\n# Fit model to data sidebands\nmodel_bkg.fitTo( data, ROOT.RooFit.Range(fit_range),  ROOT.RooFit.PrintLevel(-1))\n\n# Let's plot the model fit to the data\ncan = ROOT.TCanvas()\nplot = mass.frame()\n# We have to be careful with the normalisation as we only fit over sidebands\n# First do an invisible plot of the full data set\ndata.plotOn( plot, binning, ROOT.RooFit.MarkerColor(0), ROOT.RooFit.LineColor(0) )\nmodel_bkg.plotOn( plot, ROOT.RooFit.NormRange(fit_range), ROOT.RooFit.Range(\"full\"), ROOT.RooFit.LineColor(2))\ndata.plotOn( plot, ROOT.RooFit.CutRange(fit_range), binning )\nplot.Draw()\ncan.Update()\ncan.Draw()\ncan.SaveAs(\"part1_bkg_model.png\")\n</code></pre> <p></p> <p>As the background model is extracted from data, we want to introduce a freely floating normalisation term. We use the total number of data events (including in the signal region) as the initial prefit value of this normalisation object i.e. assuming no signal in the data. The syntax to name this normalisation object is <code>{model}_norm</code> which will the be picked up automatically by combine. Note we also allow the shape parameter to float in the final fit to data (by not setting to constant).</p> <pre><code>norm = ROOT.RooRealVar(\"model_bkg_Tag0_norm\", \"Number of background events in Tag0\", data.numEntries(), 0, 3*data.numEntries() )\nalpha.setConstant(False)\n</code></pre> <p>Let's then save the background model, the normalisation object, and the data distribution to a new <code>RooWorkspace</code>:</p> <pre><code>f_out = ROOT.TFile(\"workspace_bkg.root\", \"RECREATE\")\nw_bkg = ROOT.RooWorkspace(\"workspace_bkg\",\"workspace_bkg\")\ngetattr(w_bkg, \"import\")(data)\ngetattr(w_bkg, \"import\")(norm)\ngetattr(w_bkg, \"import\")(model_bkg)\nw_bkg.Print()\nw_bkg.Write()\nf_out.Close()\n</code></pre>"},{"location":"tutorial2023/parametric_exercise/#datacard","title":"Datacard","text":"<p>The model workspaces have now been constructed. But before we can run any fits in combine we need to build the so-called datacard. This is a text file which defines the different processes entering the fit and their expected yields, and maps these processes to the corresponding (parametric) models. We also store information on the systematic uncertainties in the datacard (see part 3). Given the low complexity of this example, the datacard is reasonably short. The datacard for this section is titled <code>datacard_part1.txt</code>. Take some time to understand the different lines. In particular, the values for the process normalisations:</p> <ul> <li>Where does the signal (ggH) normalisation come from?</li> <li>Why do we use a value of 1.0 for the background model normalisation in this analysis?</li> </ul> <pre><code># Datacard example for combine tutorial 2023 (part 1)\n---------------------------------------------\nimax 1\njmax 1\nkmax *\n---------------------------------------------\n\nshapes      ggH          Tag0      workspace_sig.root      workspace_sig:model_ggH_Tag0\nshapes      bkg_mass     Tag0      workspace_bkg.root      workspace_bkg:model_bkg_Tag0\nshapes      data_obs     Tag0      workspace_bkg.root      workspace_bkg:data_Tag0\n\n---------------------------------------------\nbin             Tag0\nobservation     -1\n---------------------------------------------\nbin             Tag0         Tag0\nprocess         ggH          bkg_mass\nprocess         0            1\nrate            181.01       1.0\n---------------------------------------------\n</code></pre> <p>To compile the datacard we run the following command, using a value of the Higgs mass of 125.0:</p> <pre><code>text2workspace.py datacard_part1.txt -m 125\n</code></pre> <ul> <li>This compiles the datacard into a RooWorkspace, effectively building the likelihood function. Try opening the compiled workspace (<code>root datacard_part1.root</code>) and print the contents.</li> </ul> <pre><code>w-&gt;Print()\n</code></pre> <ul> <li>Do you understand what all the different objects are? What does the variable <code>r</code> correspond to? Try (verbose) printing with: </li> </ul> <pre><code>w-&gt;var(\"r\")-&gt;Print(\"v\")\n</code></pre>"},{"location":"tutorial2023/parametric_exercise/#extension-signal-normalisation-object","title":"Extension: signal normalisation object","text":"<p>In the example above, the signal model normalisation is input by hand in the datacard. We can instead define the signal normalisation components in the model in a similar fashion to the background model normalisation object. Let's build the cross section (ggH), branching fraction (H-&gt;gamgam), and efficiency variables. It's important to set these terms to be constant for the final fit to data:</p> <pre><code>xs_ggH = ROOT.RooRealVar(\"xs_ggH\", \"Cross section of ggH in [pb]\", 48.58 )\nbr_gamgam = ROOT.RooRealVar(\"BR_gamgam\", \"Branching ratio of Higgs to gamma gamma\", 0.0027 )\neff_ggH_Tag0 = ROOT.RooRealVar(\"eff_ggH_Tag0\", \"Efficiency for ggH events to land in Tag0\", eff )\n\nxs_ggH.setConstant(True)\nbr_gamgam.setConstant(True)\neff_ggH_Tag0.setConstant(True)\n</code></pre> <p>The normalisation component is then defined as the product of these three variables:</p> <pre><code>norm_sig = ROOT.RooProduct(\"model_ggH_Tag0_norm\", \"Normalisation term for ggH in Tag 0\", ROOT.RooArgList(xs_ggH,br_gamgam,eff_ggH_Tag0))\n</code></pre> <p>Again the syntax <code>{model}_norm</code> has been used so that combine will automatically assign this object as the normalisation for the model (<code>model_ggH_Tag0</code>). Firstly we need to save a new version of the signal model workspace with the normalisation term included. </p> <pre><code>f_out = ROOT.TFile(\"workspace_sig_with_norm.root\", \"RECREATE\")\nw_sig = ROOT.RooWorkspace(\"workspace_sig\",\"workspace_sig\")\ngetattr(w_sig, \"import\")(model)\ngetattr(w_sig, \"import\")(norm_sig)\nw_sig.Print()\nw_sig.Write()\nf_out.Close()\n</code></pre> <p>We then need to modify the datacard to account for this normalisation term. Importantly, the <code>{model}_norm</code> term in our updated signal model workspace does not contain the integrated luminosity. Therefore, the <code>rate</code> term in the datacard must be set equal to the integrated luminosity in [pb^-1] (as the cross section was defined in [pb]). The total normalisation for the signal model is then the product of the <code>{model}_norm</code> and the <code>rate</code> value. </p> <ul> <li>You can find the example datacard here: <code>datacard_part1_with_norm.txt</code> with the signal normalisation object included. Check if it compiles successfully using <code>text2workspace</code>? If so, try printing out the contents of the workspace. Can you see the normalisation component?</li> </ul>"},{"location":"tutorial2023/parametric_exercise/#extension-unbinned-vs-binned","title":"Extension: unbinned vs binned","text":"<p>In a parametric analysis, the fit can be performed using a binned or unbinned likelihood function. The consequences of binned vs unbinned likelihoods were discussed in the morning session. In combine, we can simply toggle between binned and unbinned fits by changing how the data set is stored in the workspace. In the example above, the data was saved as a <code>RooDataSet</code>. This means that an unbinned maximum likelihood function would be used.</p> <p>To switch to a binned maximum likelihood fit, we need to store the data set in the workspace as a <code>RooDataHist</code>. Let's first load the data as a <code>RooDataSet</code> as before:</p> <pre><code>f = ROOT.TFile(\"data_part1.root\",\"r\")\nt = f.Get(\"data_Tag0\")\n\n# Convert TTree to a RooDataSet\ndata = ROOT.RooDataSet(\"data_Tag0\", \"data_Tag0\", t, ROOT.RooArgSet(mass, weight), \"\", \"weight\")\n</code></pre> <p>We then need to set the number of bins in the observable and convert the data to a <code>RooDataHist</code>. In this example we will use 320 bins over the full mass range (0.25 GeV per bin). It is important that the binning is sufficiently granular so that we do not lose information in the data by switching to a binned likelihood fit. When fitting a signal peak over a background we want the bin width to be sufficiently smaller than the signal model mass resolution.</p> <pre><code># Set bin number for mass variables\nmass.setBins(320)\ndata_hist = ROOT.RooDataHist(\"data_hist_Tag0\", \"data_hist_Tag0\", mass, data)\n\n# Save the background model with the RooDataHist instead\nf_out = ROOT.TFile(\"workspace_bkg_binned.root\", \"RECREATE\")\nw_bkg = ROOT.RooWorkspace(\"workspace_bkg\",\"workspace_bkg\")\ngetattr(w_bkg, \"import\")(data_hist)\ngetattr(w_bkg, \"import\")(norm)\ngetattr(w_bkg, \"import\")(model_bkg)\nw_bkg.Print()\nw_bkg.Write()\nf_out.Close()\n</code></pre>"},{"location":"tutorial2023/parametric_exercise/#part-2-simple-fits","title":"Part 2: Simple fits","text":"<p>Now the parametric models have been constructed and the datacard has been compiled, we are ready to start using combine for running fits. In CMS analyses we begin by blinding ourselves to the data in the signal region, and looking only at the expected results based off toys datasets (asimov or pseudo-experiments). In this exercise, we will look straight away at the observed results. Note, the python commands in this section are taken from <code>simple_fits.py</code>.</p> <p>To run a simple best-fit for the signal strength, <code>r</code>, fixing the Higgs mass to 125 GeV, you can run the command in the terminal:</p> <pre><code>combine -M MultiDimFit datacard_part1_with_norm.root -m 125 --freezeParameters MH --saveWorkspace -n .bestfit\n</code></pre> <p>We obtain a best-fit signal strength of <code>r = 1.548</code> i.e. the observed signal yield is 1.548 times the SM prediction.</p> <p>The option <code>--saveWorkspace</code> stores a snapshot of the postfit workspace in the output file (<code>higgsCombine.bestfit.MultiDimFit.mH125.root</code>). We can load the postfit workspace and look at how the values of all the fit parameters change (compare the <code>clean</code> and <code>MultiDimFit</code> parameter snapshots):</p> <pre><code>import ROOT\n\nf = ROOT.TFile(\"higgsCombine.bestfit.MultiDimFit.mH125.root\")\nw = f.Get(\"w\")\nw.Print(\"v\")\n</code></pre> <p>We can even plot the postfit signal-plus-background model using the workspace snapshot:</p> <pre><code>n_bins = 80\nbinning = ROOT.RooFit.Binning(n_bins,100,180)\n\ncan = ROOT.TCanvas()\nplot = w.var(\"CMS_hgg_mass\").frame()\nw.data(\"data_obs\").plotOn( plot, binning )\n\n# Load the S+B model\nsb_model = w.pdf(\"model_s\").getPdf(\"Tag0\")\n\n# Prefit\nsb_model.plotOn( plot, ROOT.RooFit.LineColor(2), ROOT.RooFit.Name(\"prefit\") )\n\n# Postfit\nw.loadSnapshot(\"MultiDimFit\")\nsb_model.plotOn( plot, ROOT.RooFit.LineColor(4), ROOT.RooFit.Name(\"postfit\") )\nr_bestfit = w.var(\"r\").getVal()\n\nplot.Draw()\n\nleg = ROOT.TLegend(0.55,0.6,0.85,0.85)\nleg.AddEntry(\"prefit\", \"Prefit S+B model (r=1.00)\", \"L\")\nleg.AddEntry(\"postfit\", \"Postfit S+B model (r=%.2f)\"%r_bestfit, \"L\")\nleg.Draw(\"Same\")\n\ncan.Update()\ncan.SaveAs(\"part2_sb_model.png\")\n</code></pre> <p></p>"},{"location":"tutorial2023/parametric_exercise/#confidence-intervals","title":"Confidence intervals","text":"<p>We not only want to find the best-fit value of the signal strength, r, but also the confidence intervals. The <code>singles</code> algorithm will find the 68% CL intervals:</p> <pre><code>combine -M MultiDimFit datacard_part1_with_norm.root -m 125 --freezeParameters MH -n .singles --algo singles\n</code></pre> <p>To perform a likelihood scan (i.e. calculate 2NLL at fixed values of the signal strength, profiling the other parameters), we use the <code>grid</code> algorithm. We can control the number of points in the scan using the <code>--points</code> option. Also, it is important to set a suitable range for the signal strength parameter. The <code>singles</code> algorithm has shown us that the 1 stdev interval on r is around +/-0.2. </p> <ul> <li>Use these intervals to define a suitable range for the scan, and change <code>lo,hi</code> in the following options accordingly: <code>--setParameterRanges r=lo,hi</code>.</li> </ul> <pre><code>combine -M MultiDimFit datacard_part1_with_norm.root -m 125 --freezeParameters MH -n .scan --algo grid --points 20 --setParameterRanges r=lo,hi\n</code></pre> <p>We can use the <code>plot1DScan.py</code> function from combineTools to plot the likelihood scan:</p> <pre><code>plot1DScan.py higgsCombine.scan.MultiDimFit.mH125.root -o part2_scan\n</code></pre> <p></p> <ul> <li>Do you understand what the plot is showing? What information about the signal strength parameter can be inferred from the plot?</li> </ul>"},{"location":"tutorial2023/parametric_exercise/#extension-expected-fits","title":"Extension: expected fits","text":"<p>To run expected fits we simply add <code>-t N</code> to the combine command. For <code>N&gt;0</code>, this will generate N random toys from the model and fit each one independently. For <code>N=-1</code>, this will generate an asimov toy in which all statistical fluctuations from the model are suppressed. </p> <p>You can use the <code>--expectSignal 1</code> option to set the signal strength parameter to 1 when generating the toy. Alternatively, <code>--expectSignal 0</code> will generate a toy from the background-only model. For multiple parameter models you can set the initial values when generating the toy(s) using the <code>--setParameters</code> option of combine. For example, if you want to throw a toy where the Higgs mass is at 124 GeV and the background slope parameter <code>alpha</code> is equal to -0.05, you would add <code>--setParameters MH=124.0,alpha=-0.05</code>.</p> <ul> <li>Try running the asimov likelihood scan for <code>r=1</code> and <code>r=0</code>, and plotting them using the <code>plot1DScan.py</code> script.</li> </ul>"},{"location":"tutorial2023/parametric_exercise/#extension-goodness-of-fit-tests","title":"Extension: goodness-of-fit tests","text":"<p>The goodness-of-fit tests available in combine are only well-defined for binned maximum likelihood fits. Therefore, to perform a goodness-of-fit test with a parametric datacard, make sure to save the data object as a <code>RooDataHist</code>, as in <code>workspace_bkg_binned.root</code>. </p> <ul> <li>Try editing the <code>datacard_part1_with_norm.txt</code> file to pick up the correct binned workspace file, and the <code>RooDataHist</code>. The goodness-of-fit method requires at-least one nuisance parameter in the model to run successfully. Append the following line to the end of the datacard:</li> </ul> <pre><code>lumi_13TeV      lnN          1.01         -\n</code></pre> <ul> <li>Does the datacard compile with the <code>text2workspace.py</code> command?</li> </ul> <p>We use the <code>GoodnessOfFit</code> method in combine to evaluate how compatible the observed data are with the model pdf. There are three types of GoF algorithm within combine, this example will use the <code>saturated</code> algorithm. You can find more information about the other algorithms here.</p> <p>Firstly, we want to calculate the value of the test statistic for the observed data:</p> <pre><code>combine -M GoodnessOfFit datacard_part1_binned.root --algo saturated -m 125 --freezeParameters MH -n .goodnessOfFit_data\n</code></pre> <p>Now lets calculate the test statistic value for many toys thrown from the model:</p> <pre><code>combine -M GoodnessOfFit datacard_part1_binned.root --algo saturated -m 125 --freezeParameters MH -n .goodnessOfFit_toys -t 1000\n</code></pre> <p>To make a plot of the GoF test-statistic distribution you can run the following commands, which first collect the values of the test-statistic into a json file, and then plots from the json file:</p> <pre><code>combineTool.py -M CollectGoodnessOfFit --input higgsCombine.goodnessOfFit_data.GoodnessOfFit.mH125.root higgsCombine.goodnessOfFit_toys.GoodnessOfFit.mH125.123456.root -m 125.0 -o gof.json\n\nplotGof.py gof.json --statistic saturated --mass 125.0 -o part2_gof\n</code></pre> <p></p> <ul> <li>What does the plot tell us? Does the model fit the data well? You can refer back to the discussion here</li> </ul>"},{"location":"tutorial2023/parametric_exercise/#part-3-systematic-uncertainties","title":"Part 3: Systematic uncertainties","text":"<p>In this section, we will learn how to add systematic uncertainties to a parametric fit analysis. The python commands are taken from the <code>systematics.py</code> script. </p> <p>For uncertainties which only affect the process normalisation, we can simply implement these as <code>lnN</code> uncertainties in the datacard. The file <code>mc_part3.root</code> contains the systematic-varied trees i.e. Monte-Carlo events where some systematic uncertainty source <code>{photonID,JEC,scale,smear}</code> has been varied up and down by 1\\sigma.</p> <pre><code>import ROOT\n\nf = ROOT.TFile(\"mc_part3.root\")\nf.ls()\n</code></pre> <p>Gives the output:</p> <pre><code>TFile**     mc_part3.root   \n TFile*     mc_part3.root   \n  KEY: TTree    ggH_Tag0;1  ggH_Tag0\n  KEY: TTree    ggH_Tag0_photonIDUp01Sigma;1    ggH_Tag0_photonIDUp01Sigma\n  KEY: TTree    ggH_Tag0_photonIDDown01Sigma;1  ggH_Tag0_photonIDDown01Sigma\n  KEY: TTree    ggH_Tag0_scaleUp01Sigma;1   ggH_Tag0_scaleUp01Sigma\n  KEY: TTree    ggH_Tag0_scaleDown01Sigma;1 ggH_Tag0_scaleDown01Sigma\n  KEY: TTree    ggH_Tag0_smearUp01Sigma;1   ggH_Tag0_smearUp01Sigma\n  KEY: TTree    ggH_Tag0_smearDown01Sigma;1 ggH_Tag0_smearDown01Sigma\n  KEY: TTree    ggH_Tag0_JECUp01Sigma;1 ggH_Tag0_JECUp01Sigma\n  KEY: TTree    ggH_Tag0_JECDown01Sigma;1   ggH_Tag0_JECDown01Sigma\n</code></pre> <p>Let's first load the systematic-varied trees as RooDataSets and store them in a python dictionary, <code>mc</code>:</p> <pre><code># Define mass and weight variables\nmass = ROOT.RooRealVar(\"CMS_hgg_mass\", \"CMS_hgg_mass\", 125, 100, 180)\nweight = ROOT.RooRealVar(\"weight\",\"weight\",0,0,1)\n\nmc = {}\n\n# Load the nominal dataset\nt = f.Get(\"ggH_Tag0\")\nmc['nominal'] = ROOT.RooDataSet(\"ggH_Tag0\",\"ggH_Tag0\", t, ROOT.RooArgSet(mass,weight), \"\", \"weight\" )\n\n# Load the systematic-varied datasets\nfor syst in ['JEC','photonID','scale','smear']:\n    for direction in ['Up','Down']:\n        key = \"%s%s01Sigma\"%(syst,direction)\n        name = \"ggH_Tag0_%s\"%(key)\n        t = f.Get(name)\n        mc[key] = ROOT.RooDataSet(name, name, t, ROOT.RooArgSet(mass,weight), \"\", \"weight\" )\n</code></pre> <p>The jet energy scale (JEC) and photon identification (photonID) uncertainties do not affect the shape of the m_{\\gamma\\gamma} distribution i.e. they only effect the signal yield estimate. We can calculate their impact by comparing the sum of weights to the nominal dataset. Note, the photonID uncertainty changes the weight of the events in the tree, whereas the JEC varied trees contain a different set of events, generated by shifting the jet energy scale in the simulation. In any case, the means for calculating the yield variations is equivalent:</p> <pre><code>for syst in ['JEC','photonID']:\n    for direction in ['Up','Down']:\n        yield_variation = mc['%s%s01Sigma'%(syst,direction)].sumEntries()/mc['nominal'].sumEntries()\n        print(\"Systematic varied yield (%s,%s): %.3f\"%(syst,direction,yield_variation))\n</code></pre> <pre><code>Systematic varied yield (JEC,Up): 1.056\nSystematic varied yield (JEC,Down): 0.951\nSystematic varied yield (photonID,Up): 1.050\nSystematic varied yield (photonID,Down): 0.950\n</code></pre> <p>We can write these yield variations in the datacard with the lines:</p> <pre><code>CMS_scale_j           lnN      0.951/1.056      -\nCMS_hgg_phoIdMva      lnN      1.05             -   \n</code></pre> <ul> <li>Why is the photonID uncertainty expressed as one number, whereas the JEC uncertainty is defined by two?</li> </ul> <p>Note in this analysis there are no systematic uncertainties affecting the background estimate (<code>-</code> in the datacard), as the background model has been derived directly from data.</p>"},{"location":"tutorial2023/parametric_exercise/#parametric-shape-uncertainties","title":"Parametric shape uncertainties","text":"<p>What about systematic uncertainties which affect the shape of the mass distribution?</p> <p>In a parametric analysis, we need to build the dependence directly into the model parameters. The example uncertainty sources in this tutorial are the photon energy scale and smearing uncertainties. From the names alone we can expect that the scale uncertainty will affect the mean of the signal Gaussian, and the smear uncertainty will impact the resolution (sigma). Let's first take a look at the <code>scaleUp01Sigma</code> dataset:</p> <pre><code># Build the model to fit the systematic-varied datasets\nmean = ROOT.RooRealVar(\"mean\", \"mean\", 125, 124, 126)\nsigma = ROOT.RooRealVar(\"sigma\", \"sigma\", 2, 1.5, 2.5)\ngaus = ROOT.RooGaussian(\"model\", \"model\", mass, mean, sigma)\n\n# Run the fits twice (second time from the best-fit of first run) to obtain more reliable results\ngaus.fitTo(mc['scaleUp01Sigma'], ROOT.RooFit.SumW2Error(True),ROOT.RooFit.PrintLevel(-1))\ngaus.fitTo(mc['scaleUp01Sigma'], ROOT.RooFit.SumW2Error(True),ROOT.RooFit.PrintLevel(-1))\nprint(\"Mean = %.3f +- %.3f GeV, Sigma = %.3f +- %.3f GeV\"%(mean.getVal(),mean.getError(),sigma.getVal(),sigma.getError()) )\n</code></pre> <p>Gives the output:</p> <pre><code>Mean = 125.370 +- 0.009 GeV, Sigma = 2.011 +- 0.006 GeV\n</code></pre> <p>Now let's compare the values to the nominal fit for all systematic-varied trees. We observe a significant variation in the mean for the scale uncertainty, and a significant variation in sigma for the smear uncertainty. </p> <pre><code># First fit the nominal dataset\ngaus.fitTo(mc['nominal'], ROOT.RooFit.SumW2Error(True), ROOT.RooFit.PrintLevel(-1) )\ngaus.fitTo(mc['nominal'], ROOT.RooFit.SumW2Error(True), ROOT.RooFit.PrintLevel(-1) )\n# Save the mean and sigma values and errors to python dicts\nmean_values, sigma_values = {}, {}\nmean_values['nominal'] = [mean.getVal(),mean.getError()]\nsigma_values['nominal'] = [sigma.getVal(),sigma.getError()]\n\n# Next for the systematic varied datasets\nfor syst in ['scale','smear']:\n    for direction in ['Up','Down']:\n        key = \"%s%s01Sigma\"%(syst,direction)\n        gaus.fitTo(mc[key] , ROOT.RooFit.SumW2Error(True),  ROOT.RooFit.PrintLevel(-1))\n        gaus.fitTo(mc[key], ROOT.RooFit.SumW2Error(True), ROOT.RooFit.PrintLevel(-1))\n        mean_values[key] = [mean.getVal(), mean.getError()]\n        sigma_values[key] = [sigma.getVal(), sigma.getError()]\n\n# Print the variations in mean and sigma\nfor key in mean_values.keys():\n    print(\"%s: mean = %.3f +- %.3f GeV, sigma = %.3f +- %.3f GeV\"%(key,mean_values[key][0],mean_values[key][1],sigma_values[key][0],sigma_values[key][1]))\n</code></pre> <p>Prints the output:</p> <pre><code>nominal: mean = 125.001 +- 0.009 GeV, sigma = 1.996 +- 0.006 GeV\nscaleUp01Sigma: mean = 125.370 +- 0.009 GeV, sigma = 2.011 +- 0.006 GeV\nscaleDown01Sigma: mean = 124.609 +- 0.009 GeV, sigma = 2.005 +- 0.006 GeV\nsmearUp01Sigma: mean = 125.005 +- 0.009 GeV, sigma = 2.097 +- 0.007 GeV\nsmearDown01Sigma: mean = 125.007 +- 0.009 GeV, sigma = 1.912 +- 0.006 GeV\n</code></pre> <p>The values tell us that the scale uncertainty (at \\pm 1 \\sigma) varies the signal peak mean by around 0.3%, and the smear uncertainty (at \\pm 1 \\sigma) varies the signal width (sigma) by around 4.5% (average of up and down variations). </p> <p>Now we need to bake these effects into the parametric signal model. The mean of the Gaussian was previously defined as:</p>  \\mu = m_H + \\delta <p>We introduce the nuisance parameter <code>nuisance_scale</code> = \\eta to account for a shift in the signal peak mean using:</p>  \\mu = (m_H + \\delta) \\cdot (1+0.003\\eta) <p>At \\eta = +1 (-1) the signal peak mean will shift up (down) by 0.3%. To build this into the RooFit signal model we simply define a new parameter, \\eta, and update the definition of the mean formula variable:</p> <pre><code># Building the workspace with systematic variations\nMH = ROOT.RooRealVar(\"MH\", \"MH\", 125, 120, 130 )\nMH.setConstant(True)\n\n# Define formula for mean of Gaussian\ndMH = ROOT.RooRealVar(\"dMH_ggH_Tag0\", \"dMH_ggH_Tag0\", 0, -5, 5 )\neta = ROOT.RooRealVar(\"nuisance_scale\", \"nuisance_scale\", 0, -5, 5)\neta.setConstant(True)\nmean_formula = ROOT.RooFormulaVar(\"mean_ggH_Tag0\", \"mean_ggH_Tag0\", \"(@0+@1)*(1+0.003*@2)\", ROOT.RooArgList(MH,dMH,eta))\n</code></pre> <ul> <li>Why do we set the nuisance parameter to constant at this stage?</li> </ul> <p>Similar for the width introducing a nuisance parameter, \\chi:</p>  \\sigma = \\sigma \\cdot (1+0.045\\chi) <pre><code>sigma = ROOT.RooRealVar(\"sigma_ggH_Tag0_nominal\", \"sigma_ggH_Tag0_nominal\", 2, 1, 5)\nchi = ROOT.RooRealVar(\"nuisance_smear\", \"nuisance_smear\", 0, -5, 5)\nchi.setConstant(True)\nsigma_formula = ROOT.RooFormulaVar(\"sigma_ggH_Tag0\", \"sigma_ggH_Tag0\", \"@0*(1+0.045*@1)\", ROOT.RooArgList(sigma,chi))\n</code></pre> <p>Let's now fit the new model to the signal Monte-Carlo dataset, build the normalisation object and save the workspace.</p> <pre><code># Define Gaussian\nmodel = ROOT.RooGaussian( \"model_ggH_Tag0\", \"model_ggH_Tag0\", mass, mean_formula, sigma_formula )\n\n# Fit model to MC\nmodel.fitTo( mc['nominal'], ROOT.RooFit.SumW2Error(True), ROOT.RooFit.PrintLevel(-1) )\n\n# Build signal model normalisation object\nxs_ggH = ROOT.RooRealVar(\"xs_ggH\", \"Cross section of ggH in [pb]\", 48.58 )\nbr_gamgam = ROOT.RooRealVar(\"BR_gamgam\", \"Branching ratio of Higgs to gamma gamma\", 0.0027 )\neff = mc['nominal'].sumEntries()/(xs_ggH.getVal()*br_gamgam.getVal())\neff_ggH_Tag0 = ROOT.RooRealVar(\"eff_ggH_Tag0\", \"Efficiency for ggH events to land in Tag0\", eff )\n# Set values to be constant\nxs_ggH.setConstant(True)\nbr_gamgam.setConstant(True)\neff_ggH_Tag0.setConstant(True)\n# Define normalisation component as product of these three variables\nnorm_sig = ROOT.RooProduct(\"model_ggH_Tag0_norm\", \"Normalisation term for ggH in Tag 0\", ROOT.RooArgList(xs_ggH,br_gamgam,eff_ggH_Tag0))\n\n# Set shape parameters of model to be constant (i.e. fixed in fit to data)\ndMH.setConstant(True)\nsigma.setConstant(True)\n\n# Build new signal model workspace with signal normalisation term. \nf_out = ROOT.TFile(\"workspace_sig_with_syst.root\", \"RECREATE\")\nw_sig = ROOT.RooWorkspace(\"workspace_sig\",\"workspace_sig\")\ngetattr(w_sig, \"import\")(model)\ngetattr(w_sig, \"import\")(norm_sig)\nw_sig.Print()\nw_sig.Write()\nf_out.Close()\n</code></pre> <p>The final step is to add the parametric uncertainties as Gaussian-constrained nuisance parameters into the datacard. The syntax means the Gaussian constraint term in the likelihood function will have a mean of 0 and a width of 1.</p> <pre><code>nuisance_scale        param    0.0    1.0\nnuisance_smear        param    0.0    1.0\n</code></pre> <ul> <li>Try adding these lines to <code>datacard_part1_with_norm.txt</code>, along with the lines for the JEC and photonID yield uncertainties above, and compiling with the <code>text2workspace</code> command. Open the workspace and look at its contents. You will need to change the signal process workspace file name in the datacard to point to the new workspace (<code>workspace_sig_with_syst.root</code>).</li> <li>Can you see the new objects in the compiled datacard that have been created for the systematic uncertainties? What do they correspond to?</li> </ul> <p>We can now run a fit with the systematic uncertainties included. The option <code>--saveSpecifiedNuis</code> can be called to save the postfit nuisance parameter values in the combine output limit tree. </p> <pre><code>combine -M MultiDimFit datacard_part1_with_norm.root -m 125 --freezeParameters MH --saveWorkspace -n .bestfit.with_syst --saveSpecifiedNuis CMS_scale_j,CMS_hgg_phoIdMva,nuisance_scale,nuisance_smear\n</code></pre> <ul> <li>What do the postfit values of the nuisances tell us here? You can check them by opening the output file (<code>root higgsCombine.bestfit.with_syst.MultiDimFit.mH125.root</code>) and running <code>limit-&gt;Show(0)</code>.</li> <li>Try plotting the postfit mass distribution (as detailed in part 2). Do you notice any difference?</li> </ul>"},{"location":"tutorial2023/parametric_exercise/#uncertainty-breakdown","title":"Uncertainty breakdown","text":"<p>A more complete datacard with additional nuisance parameters is stored in <code>datacard_part3.txt</code>. We will use this datacard for the rest of part 3. Open the text file and have a look at the contents.</p> <p>The following line has been appended to the end of the datacard to define the set of theory nuisance parameters. This will come in handy when calculating the uncertainty breakdown.</p> <pre><code>theory group = BR_hgg QCDscale_ggH pdf_Higgs_ggH alphaS_ggH UnderlyingEvent PartonShower\n</code></pre> <p>Compile the datacard and run an observed <code>MultiDimFit</code> likelihood scan over the signal strength, r:</p> <pre><code>text2workspace.py datacard_part3.txt -m 125\n\ncombine -M MultiDimFit datacard_part3.root -m 125 --freezeParameters MH -n .scan.with_syst --algo grid --points 20 --setParameterRanges r=0.5,2.5\n</code></pre> <p>Our aim is to break down the total uncertainty into the systematic and statistical components. To get the statistical-uncertainty-only scan it should be as simple as freezing the nuisance parameters in the fit... right? </p> <p>Try it by adding <code>,allConstrainedNuisances</code> to the <code>--freezeParameters</code> option. This will freeze all (constrained) nuisance parameters in the fit. You can also feed in regular expressions with wildcards using <code>rgx{.*}</code>. For instance to freeze only the <code>nuisance_scale</code> and <code>nuisance_smear</code> you could run with <code>--freezeParameters MH,rgx{nuisance_.*}</code>.</p> <pre><code>combine -M MultiDimFit datacard_part3.root -m 125 --freezeParameters MH,allConstrainedNuisances -n .scan.with_syst.statonly --algo grid --points 20 --setParameterRanges r=0.5,2.5\n</code></pre> <p>You can plot the two likelihood scans on the same axis with the command:</p> <pre><code>plot1DScan.py higgsCombine.scan.with_syst.MultiDimFit.mH125.root --main-label \"With systematics\" --main-color 1 --others higgsCombine.scan.with_syst.statonly.MultiDimFit.mH125.root:\"Stat-only\":2 -o part3_scan_v0\n</code></pre> <p></p> <ul> <li>Can you spot the problem? </li> </ul> <p>The nuisance parameters introduced into the model have pulled the best-fit signal strength point! Therefore we cannot simply subtract the uncertainties in quadrature to get an estimate for the systematic/statistical uncertainty breakdown. </p> <p>The correct approach is to freeze the nuisance parameters to their respective best-fit values in the stat-only scan. We can do this by first saving a postfit workspace with all nuisance parameters profiled in the fit. Then we load the postfit snapshot values of the nuisance parameters (with the option <code>--snapshotName MultiDimFit</code>) from the combine output of the previous step, and then freeze the nuisance parameters for the stat-only scan.</p> <pre><code>combine -M MultiDimFit datacard_part3.root -m 125 --freezeParameters MH -n .bestfit.with_syst --setParameterRanges r=0.5,2.5 --saveWorkspace\n\ncombine -M MultiDimFit higgsCombine.bestfit.with_syst.MultiDimFit.mH125.root -m 125 --freezeParameters MH,allConstrainedNuisances -n .scan.with_syst.statonly_correct --algo grid --points 20 --setParameterRanges r=0.5,2.5 --snapshotName MultiDimFit\n</code></pre> <p>Adding the option <code>--breakdown syst,stat</code> to the <code>plot1DScan.py</code> command will automatically calculate the uncertainty breakdown for you.</p> <pre><code>plot1DScan.py higgsCombine.scan.with_syst.MultiDimFit.mH125.root --main-label \"With systematics\" --main-color 1 --others higgsCombine.scan.with_syst.statonly_correct.MultiDimFit.mH125.root:\"Stat-only\":2 -o part3_scan_v1 --breakdown syst,stat\n</code></pre> <p></p> <p>We can also freeze groups of nuisance parameters defined in the datacard with the option <code>--freezeNuisanceGroups</code>. Let's run a scan freezing only the theory uncertainties (using the nuisance group we defined in the datacard):</p> <pre><code>combine -M MultiDimFit higgsCombine.bestfit.with_syst.MultiDimFit.mH125.root -m 125 --freezeParameters MH --freezeNuisanceGroups theory -n .scan.with_syst.freezeTheory --algo grid --points 20 --setParameterRanges r=0.5,2.5 --snapshotName MultiDimFit\n</code></pre> <p>To breakdown the total uncertainty into the theory, experimental and statistical components we can then use:</p> <pre><code>plot1DScan.py higgsCombine.scan.with_syst.MultiDimFit.mH125.root --main-label Total --main-color 1 --others higgsCombine.scan.with_syst.freezeTheory.MultiDimFit.mH125.root:\"Freeze theory\":4 higgsCombine.scan.with_syst.statonly_correct.MultiDimFit.mH125.root:\"Stat-only\":2 -o part3_scan_v2 --breakdown theory,exp,stat\n</code></pre> <p></p> <p>These methods are not limited to this particular grouping of systematics. We can use the above procedure to assess the impact of any nuisance parameter(s) on the signal strength confidence interval. </p> <ul> <li>Try and calculate the contribution to the total uncertainty from the luminosity estimate using this approach.</li> </ul>"},{"location":"tutorial2023/parametric_exercise/#impacts","title":"Impacts","text":"<p>It is often useful/required to check the impacts of the nuisance parameters (NP) on the parameter of interest, r. The impact of a NP is defined as the shift \\Delta r induced as the NP, \\theta, is fixed to its \\pm1\\sigma values, with all other parameters profiled as normal. More information can be found in the combine documentation via this link.</p> <p>Let's calculate the impacts for our analysis. We can use the <code>combineTool.py</code> from the <code>CombineHarvester</code> package to automate the scripts. The impacts are calculated in a few stages:</p> <p>1) Do an initial fit for the parameter of interest, adding the <code>--robustFit 1</code> option:</p> <pre><code>combineTool.py -M Impacts -d datacard_part3.root -m 125 --freezeParameters MH -n .impacts --setParameterRanges r=0.5,2.5 --doInitialFit --robustFit 1\n</code></pre> <ul> <li>What does the option <code>--robustFit 1</code> do? </li> </ul> <p>2) Next perform a similar scan for each NP with the <code>--doFits</code> option. This may take a few minutes:</p> <pre><code>combineTool.py -M Impacts -d datacard_part3.root -m 125 --freezeParameters MH -n .impacts --setParameterRanges r=0.5,2.5 --doFits --robustFit 1\n</code></pre> <p>3) Collect the outputs from the previous step and write the results to a json file:</p> <pre><code>combineTool.py -M Impacts -d datacard_part3.root -m 125 --freezeParameters MH -n .impacts --setParameterRanges r=0.5,2.5 -o impacts_part3.json\n</code></pre> <p>4) Produce a plot summarising the nuisance parameter values and impacts:</p> <pre><code>plotImpacts.py -i impacts_part3.json -o impacts_part3\n</code></pre> <p></p> <p>There is a lot of information in these plots, which can be of invaluable use to analysers in understanding the fit. Do you understand everything that the plot is showing?</p> <ul> <li>Which NP has the highest impact on the signal strength measurement?</li> <li>Which NP is pulled the most in the fit to data? What does this information imply about the signal model mean in relation to the data?</li> <li>Which NP is the most constrained in the fit to the data? What does it mean for a nuisance parameter to be constrained?</li> <li>Try adding the option <code>--summary</code> to the impacts plotting command. This is a nice new feature in combine!</li> </ul>"},{"location":"tutorial2023/parametric_exercise/#part-4-toy-generation-and-bias-studies","title":"Part 4: Toy generation and bias studies","text":"<p>With combine we can generate toy datasets from the compiled datacard workspace. Please read this section in the combine manual before proceeding.</p> <p>An interesting use case of toy generation is when performing bias studies. In the Higgs to two photon (Hgg) analysis, the background is fit with some functional form. However (due to the complexities of QCD) the exact form of this function is unknown. Therefore, we need to understand how our choice of background function may impact the fitted signal strength. This is performed using a bias study, which will indicate how much potential bias is present given a certain choice of functional form.</p> <p>In the classical bias studies we begin by building a set of workspaces which correspond to different background function choices. In addition to the <code>RooExponential</code> constructed in Section 1, let's also try a (4th order) <code>RooChebychev</code> polynomial and a simple power law function to fit the background m_{\\gamma\\gamma} distribution. </p> <p>The script used to fit the different functions and build the workspaces is <code>construct_models_bias_study_part4.py</code>. Take some time to look at the script and understand what the code is doing. In particular notice how we have saved the data as a <code>RooDataHist</code> in the workspace. This means we are now performing binned maximum likelihood fits (this is useful for part 4 to speed up fitting the many toys). If the binning is sufficiently granular, then there will be no noticeable difference in the results to the unbinned likelihood fits. Run the script with:</p> <pre><code>python3  construct_models_bias_study_part4.py\n</code></pre> <p>The outputs are a set of workspaces which correspond to different choices of background model functions, and a plot showing fits of the different functions to the data mass sidebands.</p> <p></p> <p>The datacards for the different background model functions are saved as <code>datacard_part4_{pdf}.txt</code> where <code>pdf = {exp,poly,pow}</code>. Have a look inside the .txt files and understand what changes have been made to pick up the different functions. Compile the datacards with:</p> <pre><code>for pdf in {exp,poly,pow}; do text2workspace.py datacard_part4_${pdf}.txt -m 125; done\n</code></pre>"},{"location":"tutorial2023/parametric_exercise/#bias-studies","title":"Bias studies","text":"<p>For the bias studies we want to generate (\"throw\") toy datasets with some choice of background function and fit back with another. The toys are thrown with a known value of the signal strength (r=1 in this example), which we will call r_{truth}. The fitted value of r is defined as r_{fit}, with some uncertainty \\sigma_{fit}. A pull value, P, is calculated for each toy dataset according to,</p>  P = (r_{truth}-r_{fit})/\\sigma_{fit} <p>By repeating the process for many toys we can build up a pull distribution. If there is no bias present then we would expect to obtain a normal distribution centred at 0, with a standard deviation of 1. Let's calculate the bias for our analysis.</p> <p>Firstly,  we generate N=1000 toys from each of the background function choices and save them in a ROOT file. For this we use the <code>GenerateOnly</code> method of combine. We will inject signal in the toys by setting <code>r=1</code> using the <code>--expectSignal 1</code> option. </p> <ul> <li>If time allows, repeat the bias studies with <code>--expectSignal 0</code>. This will inform us of the potential bias in the signal strength measurement given that there is no true signal.</li> </ul> <p>The following commands show the example of throwing 1000 toys from the exponential function, and then fitting back with the 4th-order Chebychev polynomial. We use the <code>singles</code> algorithm to obtain a value for r_{fit} and \\sigma_{fit} simultaneously.</p> <pre><code>combine -M GenerateOnly datacard_part4_exp.root -m 125 --freezeParameters MH -t 1000 -n .generate_exp --expectSignal 1 --saveToys\n\ncombine -M MultiDimFit datacard_part4_poly.root -m 125 --freezeParameters MH -t 1000 -n .bias_truth_exp_fit_poly --expectSignal 1 --toysFile higgsCombine.generate_exp.GenerateOnly.mH125.123456.root --algo singles\n</code></pre> <p>The script <code>plot_bias_pull.py</code> will plot the pull distribution and fit a Gaussian to it:</p> <pre><code>python3 plot_bias_pull.py\n</code></pre> <p></p> <p>The potential bias is defined as the (fitted) mean of the pull distribution. </p> <ul> <li>What is our bias value? Have we generated enough toys to be confident of the bias value? You could try generating more toys if not.</li> <li>What threshold do we use to define \"acceptable\" bias? </li> </ul> <p>From the pull definition, we see the bias value is defined relative to the total uncertainty in the signal strength (denominator of \\sigma_{fit}). Some analyses use 0.14 as the threshold because a bias below this value would change the total uncertainty (when added in quadrature) by less than 1% (see equation below). Other analyses use 0.2 as this will change the total uncertainty by less than 2%. We should define the threshold before performing the bias study.</p>  \\sqrt{ 1^2 + 0.14^2} = 1.0098  <ul> <li>How does our bias value compare to the thresholds? If we the bias is outside the acceptable region we should account for this using a spurious signal method (see advanced exercises TBA). </li> <li>Repeat the bias study for each possible truth and fitted background function combinations. Do the bias values induced by the choice of background function merit adding a spurious signal component into the fit?</li> <li>What would you expect the bias value to be for a background function that does not fit the data well? Should we be worried about such functions? What test could we use to reject such functions from the study beforehand?</li> </ul>"},{"location":"tutorial2023/parametric_exercise/#part-5-discrete-profiling","title":"Part 5: Discrete-profiling","text":"<p>If multiple pdfs exist to fit some distribution, we can store all pdfs in a single workspace by using a <code>RooMultiPdf</code> object. The script <code>construct_models_multipdf_part5.py</code> shows how to store the exponential, (4th order) Chebychev polynomial and the power law function from the previous section in a <code>RooMultiPdf</code> object. This requires a <code>RooCategory</code> index, which controls the pdf which is active at any one time. Look at the contents of the script and then run with:</p> <pre><code>python3 construct_models_multipdf_part5.py\n</code></pre> <p>The file <code>datacard_part5.txt</code> will load the multipdf as the background model. Notice the line at the end of the datacard (see below). This tells combine about the <code>RooCategory</code> index.</p> <pre><code>pdfindex_Tag0         discrete\n</code></pre> <p>Compile the datacard with:</p> <pre><code>text2workspace.py datacard_part5.txt -m 125\n</code></pre> <p>The <code>RooMultiPdf</code> is a handy object for performing bias studies as all functions can be stored in a single workspace. You can then set which function is used for generating the toys with the <code>--setParameters pdfindex_Tag0=i</code> option, and which function is used for fitting with <code>--setParameters pdfindex_Tag0=j --freezeParameters pdfindex_Tag0</code> options. </p> <ul> <li>It would be a useful exercise to repeat the bias studies from part 4 but using the RooMultiPdf workspace. What happens when you do not freeze the index in the fitting step?</li> </ul> <p>But simpler bias studies are not the only benefit of using the <code>RooMultiPdf</code>! It also allows us to apply the discrete profiling method in our analysis. In this method, the index labelling which pdf is active (a discrete nuisance parameter) is left floating in the fit, and will be profiled by looping through all the possible index values and finding the pdf which gives the best fit. In this manner, we are able to account for the uncertainty in the choice of the background function. </p> <p>Note, by default, the multipdf will tell combine to add 0.5 to the NLL for each parameter in the pdf. This is known as the penalty term (or correction factor) for the discrete profiling method. You can toggle this term when building the workspace with the command <code>multipdf.setCorrectionFactor(0.5)</code>. You may need to change the value of this term to obtain an acceptable bias in your fit!</p> <p>Let's run a likelihood scan using the compiled datacard with the <code>RooMultiPdf</code>:</p> <pre><code>combine -M MultiDimFit datacard_part5.root -m 125 --freezeParameters MH -n .scan.multidimfit --algo grid --points 20 --cminDefaultMinimizerStrategy 0 --saveSpecifiedIndex pdfindex_Tag0 --setParameterRanges r=0.5,2.5\n</code></pre> <p>The option <code>--cminDefaultMinimizerStrategy 0</code> is required to prevent HESSE being called as this cannot handle discrete nuisance parameters. HESSE is the full calculation of the second derivative matrix (Hessian) of the likelihood using finite difference methods.</p> <p>The option <code>--saveSpecifiedIndex pdfindex_Tag0</code> saves the value of the index at each point in the likelihood scan. Let's have a look at how the index value changes as a function of the signal strength. You can make the following plot by running:</p> <pre><code>python3 plot_pdfindex.py\n</code></pre> <p></p> <p>By floating the discrete nuisance parameter <code>pdfindex_Tag0</code>, at each point in the likelihood scan the pdfs will be iterated over and the one which gives the max likelihood (lowest 2NLL) including the correction factor will be used. The plot above shows that the <code>pdfindex_Tag0=0</code> (exponential) is chosen for the majority of r values, but this switches to <code>pdfindex_Tag0=1</code> (Chebychev polynomial) at the lower edge of the r range. We can see the impact on the likelihood scan by fixing the pdf to the exponential:</p> <pre><code>combine -M MultiDimFit datacard_part5.root -m 125 --freezeParameters MH,pdfindex_Tag0 --setParameters pdfindex_Tag0=0 -n .scan.multidimfit.fix_exp --algo grid --points 20 --cminDefaultMinimizerStrategy 0 --saveSpecifiedIndex pdfindex_Tag0 --setParameterRanges r=0.5,2.5\n</code></pre> <p>Plotting the two scans on the same axis:</p> <pre><code>plot1DScan.py higgsCombine.scan.multidimfit.MultiDimFit.mH125.root --main-label \"Pdf choice floating\" --main-color 1 --others higgsCombine.scan.multidimfit.fix_exp.MultiDimFit.mH125.root:\"Pdf fixed to exponential\":2 -o part5_scan --y-cut 35 --y-max 35\n</code></pre> <p></p> <p>The impact on the likelihood scan is evident at the lower edge, where the scan in which the index is floating flattens out. In this example, neither the 1\\sigma or 2\\sigma intervals are affected. But this is not always the case! Ultimately, this method allows us to account for the uncertainty in the choice of background function in the signal strength measurement. </p> <p>Coming back to the bias studies. Do you now understand what you are testing if you do not freeze the index in the fitting stage? In this case you are fitting the toys back with the discrete profiling method. This is the standard approach for the bias studies when we use the discrete-profiling method in an analysis.</p> <p>There are a number of options which can be added to the combine command to improve the performance when using discrete nuisance parameters. These are detailed at the end of this section in the combine manual.</p>"},{"location":"tutorial2023/parametric_exercise/#part-6-multi-signal-model","title":"Part 6: Multi-signal model","text":"<p>In reality, there are multiple Higgs boson processes which contribute to the total signal model, not only ggH. This section will explain how we can add an additional signal process (VBF) into the fit. Following this, we will add a second analysis category (Tag1), which has a higher purity of VBF events. To put this in context, the selection for Tag1 may require two jets with a large pseudorapidity separation and high invariant mass, which are typical properties of the VBF topology. By including this additional category with a different relative yield of VBF to ggH production, we are able to simultaneously constrain the rate of the two production modes.</p> <p>In the SM, the VBF process has a cross section which is roughly 10 times smaller than the ggH cross section. This explains why we need to use certain features of the event to boost the purity of VBF events. The LO Feynman diagram for VBF production is shown below.</p> <p></p>"},{"location":"tutorial2023/parametric_exercise/#building-the-models","title":"Building the models","text":"<p>Firstly, lets build the necessary inputs for this section using <code>construct_models_part6.py</code>. This script uses everything we have learnt in the previous sections: 1) Signal models (Gaussians) are built separately for each process (ggH and VBF) in each analysis category (Tag0 and Tag1). This uses separate <code>TTrees</code> for each contribution in the <code>mc_part6.root</code> file. The mean and width of the Gaussians include the effect of the parametric shape uncertainties, <code>nuisance_scale</code> and <code>nuisance_smear</code>. Each signal model is normalised according to the following equation, where \\epsilon_{ij} labels the fraction of process, i (=ggH,VBF), landing in analysis category, j (=Tag0,Tag1), and \\mathcal{L} is the integrated luminosity (defined in the datacard).</p>  N_{ij} = \\sigma_i \\cdot \\mathcal{B}^{\\gamma\\gamma} \\cdot \\epsilon_{ij} \\cdot \\mathcal{L} <p>2) A background model is constructed for each analysis category by fitting the mass sidebands in data. The input data is stored in the <code>data_part6.root</code> file. The models are <code>RooMultiPdfs</code> which contain an exponential, a 4th-order Chebychev polynomial and a power law function. The shape parameters and normalisation terms of the background models are freely floating in the final fit.</p> <ul> <li>Have a look through the <code>construct_models_part6.py</code> script and try to understand all parts of the model construction. When you are happy, go ahead and construct the models with:</li> </ul> <pre><code>python3 construct_models_part6.py\n</code></pre> <p>The datacards for the two analysis categories are saved separately as <code>datacard_part6_Tag0.txt</code> and <code>datacard_part6_Tag1.txt</code>. </p> <ul> <li>Do you understand the changes made to include multiple signal processes in the datacard? What value in the <code>process</code> line is used to label VBF as a signal?</li> <li>Try compiling the individual datacards. What are the prefit ggH and VBF yields in each analysis category? You can find these by opening the workspace and printing the contents.</li> <li>Run the best fits and plot the prefit and postfit S+B models along with the data (see code in part 2). How does the absolute number of data events in Tag1 compare to Tag0? What about the signal-to-background ratio, S/B? </li> </ul> <p>In order to combine the two categories into a single datacard, we make use of the <code>combineCards.py</code> script:</p> <pre><code>combineCards.py datacard_part6_Tag0.txt datacard_part6_Tag1.txt &gt; datacard_part6_combined.txt\n</code></pre>"},{"location":"tutorial2023/parametric_exercise/#running-the-fits","title":"Running the fits","text":"<p>If we use the default <code>text2workspace</code> command on the combined datacard, then this will introduce a single signal strength modifer which modifies the rate of all signal processes (ggH and VBF) by the same factor. </p> <ul> <li>Try compiling the combined datacard and running a likelihood scan. Does the sensitivity to the global signal strength improve by adding the additional analysis category \"Tag1\"?</li> </ul> <p>If we want to measure the independent rates of both processes simultaneously, then we need to introduce a separate signal strength for ggH and VBF. To do this we use the <code>multiSignalModel</code> physics model in combine by adding the following options to the <code>text2workspace</code> command:</p> <pre><code>text2workspace.py datacard_part6_combined.txt -m 125 -P HiggsAnalysis.CombinedLimit.PhysicsModel:multiSignalModel --PO \"map=.*/ggH:r_ggH[1,0,2]\" --PO \"map=.*/VBF:r_VBF[1,0,3]\" -o datacard_part6_combined_multiSignalModel.root\n</code></pre> <p>The syntax for the parameter to process mapping is <code>map=category/process/POI[default,min,max]</code>. We have used the wildcard <code>.*</code> to tell combine that the POI (parameter of interest) should scale all cases of that process, regardless of the analysis category. The output of this command tells us what is scaled by the two signal strengths:</p> <pre><code>Will scale  ch1/ggH  by  r_ggH\nWill scale  ch1/VBF  by  r_VBF\nWill scale  ch1/bkg_mass  by  1\nWill scale  ch2/ggH  by  r_ggH\nWill scale  ch2/VBF  by  r_VBF\nWill scale  ch2/bkg_mass  by  1\nWill scale  ch1/ggH  by  r_ggH\nWill scale  ch1/VBF  by  r_VBF\nWill scale  ch1/bkg_mass  by  1\nWill scale  ch2/ggH  by  r_ggH\nWill scale  ch2/VBF  by  r_VBF\nWill scale  ch2/bkg_mass  by  1\n</code></pre> <p>Exactly what we require!</p> <p>To run a 1D \"profiled\" likelihood scan for ggH we use the following command:</p> <pre><code>combine -M MultiDimFit datacard_part6_combined_multiSignalModel.root -m 125 --freezeParameters MH -n .scan.part6_multiSignalModel_ggH --algo grid --points 20 --cminDefaultMinimizerStrategy 0 --saveInactivePOI 1 -P r_ggH --floatOtherPOIs 1\n</code></pre> <ul> <li>\"Profiled\" here means we are profiling over the other parameter of interest, <code>r_VBF</code> in the fit. In other words, we are treating <code>r_VBF</code> as an additional nuisance parameter. The option <code>--saveInactivePOI 1</code> stores the value of <code>r_VBF</code> in the combine output. Take a look at the fit output. Does the value of <code>r_VBF</code> depend on <code>r_ggH</code>? Are the two parameters of interest correlated? Remember, to look at the contents of the TTree you can use <code>limit-&gt;Show(i)</code>, where i is an integer labelling the point in the likelihood scan.</li> <li>Run the profiled scan for the VBF signal strength. Plot the <code>r_ggH</code> and <code>r_VBF</code> likelihood scans using the <code>plot1DScan.py</code> script. You will need to change some of the input options, in particular the <code>--POI</code> option. You can list the full set of options by running:</li> </ul> <pre><code>plot1DScan.py --help\n</code></pre>"},{"location":"tutorial2023/parametric_exercise/#two-dimensional-likelihood-scan","title":"Two-dimensional likelihood scan","text":"<p>We can also run the fit at fixed points in (<code>r_ggH</code>,<code>r_VBF</code>) space. By using a sufficient number of points, we are able to up the 2D likelihood surface. Let's change the ranges of the parameters of interest to match what we have found in the profiled scans:</p> <pre><code>combine -M MultiDimFit datacard_part6_combined_multiSignalModel.root -m 125 --freezeParameters MH -n .scan2D.part6_multiSignalModel --algo grid --points 800 --cminDefaultMinimizerStrategy 0 -P r_ggH -P r_VBF --setParameterRanges r_ggH=0.5,2.5:r_VBF=-1,2\n</code></pre> <p>To plot the output you can use the <code>plot_2D_scan.py</code> script:</p> <pre><code>python3 plot_2D_scan.py\n</code></pre> <p>This script interpolates the 2NLL value between the points ran in the scan so that the plot shows a smooth likelihood surface. You may find in some cases, the number of scanned points and interpolation parameters need to be tuned to get a sensible looking surface. This basically depends on how complicated the likelihood surface is.</p> <p></p> <ul> <li>The plot shows that the data is in agreement with the SM within the 2\\sigma CL. Here, the 1\\sigma and 2\\sigma confidence interval contours corresponds to 2NLL values of 2.3 and 5.99, respectively. Do you understand why this? Think about Wilk's theorem.</li> <li>Does the plot show any correlation between the ggH and VBF signal strengths? Are the two positively or negatively correlated? Does this make sense for this pair of parameters given the analysis setup? Try repeating the 2D likelihood scan using the \"Tag0\" only datacard. How does the correlation behaviour change?</li> <li>How can we read off the \"profiled\" 1D likelihood scan constraints from this plot?</li> </ul>"},{"location":"tutorial2023/parametric_exercise/#correlations-between-parameters","title":"Correlations between parameters","text":"<p>For template-based analyses we can use the <code>FitDiagnostics</code> method in combine to extract the covariance matrix for the fit parameters. Unfortunately, this method is not compatible when using discrete nuisance parameters (<code>RooMultiPdf</code>). Instead, we can use the <code>robustHesse</code> method to find the Hessian matrix by finite difference methods. The matrix is then inverted to get the covariance. Subsequently, we can use the covariance to extract the correlations between fit parameters. </p> <pre><code>combine -M MultiDimFit datacard_part6_combined_multiSignalModel.root -m 125 --freezeParameters MH -n .robustHesse.part6_multiSignalModel --cminDefaultMinimizerStrategy 0 -P r_ggH -P r_VBF --setParameterRanges r_ggH=0.5,2.5:r_VBF=-1,2 --robustHesse 1 --robustHesseSave 1 --saveFitResult\n</code></pre> <p>The output file <code>robustHesse.robustHesse.part6_multiSignalModel.root</code> stores the correlation matrix (<code>h_correlation</code>). This contains the correlations between all parameters including the nuisances. So if we are interested in the correlation between <code>r_ggH</code> and <code>r_VBF</code>, we first need to find which bin corresponds to these parameters:</p> <pre><code>root robustHesse.robustHesse.part6_multiSignalModel.root\n\nroot [1] h_correlation-&gt;GetXaxis()-&gt;GetBinLabel(19)\n(const char *) \"r_VBF\"\nroot [2] h_correlation-&gt;GetYaxis()-&gt;GetBinLabel(20)\n(const char *) \"r_ggH\"\nroot [3] h_correlation-&gt;GetBinContent(19,20)\n(double) -0.19822058\n</code></pre> <ul> <li>The two parameters of interest have a correlation coefficient of -0.198. This means the two parameters are somewhat anti-correlated. Does this match what we see in the 2D likelihood scan?</li> </ul>"},{"location":"tutorial2023/parametric_exercise/#impacts_1","title":"Impacts","text":"<p>We extract the impacts for each parameter of interest using the following commands:</p> <pre><code>combineTool.py -M Impacts -d datacard_part6_combined_multiSignalModel.root -m 125 --freezeParameters MH -n .impacts_part6_multiSignal --robustFit 1 --cminDefaultMinimizerStrategy 0 -P r_ggH -P r_VBF --doInitialFit\n\ncombineTool.py -M Impacts -d datacard_part6_combined_multiSignalModel.root -m 125 --freezeParameters MH -n .impacts_part6_multiSignal --robustFit 1 --cminDefaultMinimizerStrategy 0 -P r_ggH -P r_VBF --doFits\n\ncombineTool.py -M Impacts -d datacard_part6_combined_multiSignalModel.root -m 125 --freezeParameters MH -n .impacts_part6_multiSignal --robustFit 1 --cminDefaultMinimizerStrategy 0 -P r_ggH -P r_VBF -o impacts_part6.json\n\nplotImpacts.py -i impacts_part6.json -o impacts_part6_r_ggH --POI r_ggH\nplotImpacts.py -i impacts_part6.json -o impacts_part6_r_VBF --POI r_VBF\n</code></pre> <ul> <li>Look at the output PDF files. How does the ranking of the nuisance parameters change for the different signal strengths? </li> </ul>"},{"location":"tutorial2023/parametric_exercise/#advanced-exercises-to-be-added","title":"Advanced exercises (to be added)","text":"<p>The combine experts will include additional exercises here in due course. These will include:</p> <ul> <li>Convolution of model pdfs: <code>RooAddPdf</code></li> <li>Application of the spurious signal method</li> <li>Advanced physics models including parametrised signal strengths e.g. SMEFT</li> <li>Mass fits</li> <li>Two-dimensional parametric models </li> </ul>"},{"location":"tutorial2023_unfolding/unfolding_exercise/","title":"Likelihood Based Unfolding Exercise in Combine","text":""},{"location":"tutorial2023_unfolding/unfolding_exercise/#getting-started","title":"Getting started","text":"<p>To get started, you should have a working setup of Combine and CombineHarvester. This setup can be done following any of the installation instructions.</p> <p>After setting up CMSSW, you can access the working directory for this tutorial which contains all of the inputs and scripts needed to run the unfolding fitting exercise:</p> <pre><code>cd $CMSSW_BASE/src/HiggsAnalysis/CombinedLimit/data/tutorials/tutorial_unfolding_2023/\n</code></pre>"},{"location":"tutorial2023_unfolding/unfolding_exercise/#exercise-outline","title":"Exercise outline","text":"<p>The hands-on exercise is split into seven parts: </p> <p>1) \"Simple\" Unfolding Experiment</p> <p>2) Producing the Migration matrix from the datacards</p> <p>3) Advanced Unfolding with more detector-level information and control regions</p> <p>4) Extracting the expected intervals</p> <p>5) Producing Impacts for multiple POIs</p> <p>6) Unfold to the generator-level quantities </p> <p>7) Extracting POI correlations from the FitDiagnostics output</p> <p>Throughout the tutorial there are a number of questions and exercises for you to complete. These are shown in the boxes like this one. </p> <p>Note that some additional information on unfolding in <code>Combine</code> are available here, which also includes some information on regularization, which is not discussed in this tutorial. </p>"},{"location":"tutorial2023_unfolding/unfolding_exercise/#analysis-overview","title":"Analysis overview","text":"<p>In this tutorial we will look at the cross section measurements of on of the SM Higgs processes VH, in H\\to b\\bar{b} (VHbb) final state. </p> <p>The measurement is performed within the Simplified Template Cross Section (STXS) framework, which provides the prediction in the bins of generator-level quantities p_{T}(V) and number of additional jets. The maximum likelihood based unfolding is performed to measure the cross section in the generator-level bins defined by STXS scheme. At the detector-level we define appropriate categories to match the STXS bins as closely as possible so that there is a good correspondence between the detector-level observable and the underlying generator-level quantity we are interested in.  </p> <p> </p> <p>Note that for this STXS measurement, as well as measuring the cross-section as a function of the p_{T} of the vector boson, the measurement includes some information on the number of additional jets and is performed over multiple different production modes, for different production processes. However, it is common to focus on a single distribution (e.g. p_{T}) for a signle process, (e.g. t\\bar{t}).</p> <p>In this tutorial we will focus on the ZH production, with the Z boson decaying to charged leptons, and Higgs boson reconstructed with the resolved b\\bar{b} pair. We will also use only a part of the Run 2 categories, we will not achieve the same sensitivity as the full analysis. Note that ggZH and ZH production modes are combined in the fit, since it is not possible to resolve them at this stage of the analysis. The STXS categories are defined independently of the Higgs decay channel, to streamline the combinations of the cross section measurement. </p> <p>In the first part of the tutorial, we will setup a relatively simple unfolding, where there is a single detector-level bin for every generator-level bin we are trying to measure. We will then perform a blind analysis using this setup to see the expected sensitivity. </p> <p>In this simple version of the analysis, we use a series of datacards, one for each detector-level bin, implemented as a counting experiment. We then combine the datacards for the full measurement. It is also possible to implement the same analysis as a single datacard, passing a histogram with each of the detector-level bins. Either method can be used, depending on which is more practical for the analysis being considered. </p> <p>In the second part of the tutorial we will perform the same measurement with a more advanced setup, making use of differential distributions per generator-level bin we are trying to measure, as well as control regions. By providing this additional information to the fit, we are able to achieve a better and more robust unfolding result. After checking the expected sensitivity, we will take a look at the impacts and pulls of the nuisance parameters. Then we will unblind and look at the results of the measurement, produce generator-level plots and provide the correlation matrix for our measured observables.</p>"},{"location":"tutorial2023_unfolding/unfolding_exercise/#simplified-unfolding","title":"Simplified unfolding","text":"<p>When determining the detector-level binning for any differential analysis the main goal is to chose a binning that distinguishes contributions from the various generator-level bins well. In the simplest case it can be done with the cut-based approach, i.e. applying the same binning for the detector-level observables as is being applied to the generator-level quantities being measured. In this case, that means binning in p_{T}(Z) and n_{\\text{add. jets}}.  Due to the good lepton p_{T} resolution we can follow the original STXS scheme quite closely with the detector-level selection, with one exception, it is not possible to access the very-low transverse momenta bin p_{T}(Z)&lt;75 GeV.  </p> <p>In <code>counting/regions</code> dicrectory you can find the datacards with five detector-level categories, each targetting a corresponding generator-level bin. Below you can find an example of the datacard for the detector-level bin with p_{T}(Z)&gt;400 GeV. </p> <pre><code>imax    1 number of bins\njmax    9 number of processes minus 1\nkmax    * number of nuisance parameters\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------\nbin          vhbb_Zmm_gt400_13TeV\nobservation  12.0\n--------------------------------------------------------------------------------\nbin                                   vhbb_Zmm_gt400_13TeV   vhbb_Zmm_gt400_13TeV vhbb_Zmm_gt400_13TeV   vhbb_Zmm_gt400_13TeV     vhbb_Zmm_gt400_13TeV vhbb_Zmm_gt400_13TeV vhbb_Zmm_gt400_13TeV vhbb_Zmm_gt400_13TeV vhbb_Zmm_gt400_13TeV vhbb_Zmm_gt400_13TeV\nprocess                               ggZH_lep_PTV_GT400_hbb ZH_lep_PTV_GT400_hbb ZH_lep_PTV_250_400_hbb ggZH_lep_PTV_250_400_hbb Zj1b            Zj0b_c          Zj0b_udsg       VVLF            Zj2b            VVHF\nprocess                               -3                     -2                   -1                     0                        1               2               3               4               5               6\nrate                                  0.0907733              0.668303             0.026293               0.00434588               3.78735         2.58885         4.09457         0.413716        7.02731         0.642605\n--------------------------------------------------------------------------------\n\n</code></pre> <p>You can see the contributions from various background processes, namely Z+jets, t\\bar{t} and the single top, as well as the signal processes (ggZH and ZH) corresponding to the STXS scheme discussed above. Note that for each generator-level bin being measured, we assign a different process in combine. This is so that the signal strengths for each of their contributions can float independently in the measurement. Also note, that due to migrations, each detector-level bin will receive contributions from multiple generator-level bins.</p> <p>One of the most important stages in the analysis design, is to make sure that the detector-level categories are well-chosen to target the corresponding generator-level processes.</p> <p>To explicitly check the correspondance between detector- and generator-level, one can plot the contributions of each of the generator-level bins in all of the detector-level bins. You can use the script provided in the tutorial git-lab page. This script uses <code>CombineHarvester</code> to loop over detector-level bins, and get the rate at which each of the signal processes (generator-level bins) contributes to that detector-level bin; which is then used to plot the migration matrix. </p> <pre><code>python scripts/get_migration_matrix.py counting/combined_ratesOnly.txt\n\n</code></pre> <p> </p> <p>The migration matrix shows the generator-level bins on the x-axis and the corresponding detector-level bins on the y-axis. The entries are normalized such that the sum of all contributions for a given generator-level bin sum up to 1. With this convention, the numbers in each bin represent the probability that an event from a given generator-level bin is reconstructed in a given detector-level bin if it is reconstructed at all within the considered bins.</p> <p>Now that we checked the response matrix we can attempt the maximum likelihood unfolding. We can use the <code>multiSignalModel</code> physics model available in <code>Combine</code>, which assigns a parameter of interest <code>poi</code> to a process <code>p</code> within a bin <code>b</code> using the syntax <code>--PO 'map=b/p:poi[init, min, max]'</code> to linearly scale the normalisation of this process under the parameter of interest (POI) variations. To create the workspace we can run the following command: </p> <pre><code>text2workspace.py -m 125  counting/combined_ratesOnly.txt -P HiggsAnalysis.CombinedLimit.PhysicsModel:multiSignalModel  --PO verbose --PO 'map=.*/.*ZH_lep_PTV_75_150_hbb:r_zh_75_150[1,-5,5]' --PO 'map=.*/.*ZH_lep_PTV_150_250_0J_hbb:r_zh_150_250noj[1,-5,5]'  --PO 'map=.*/.*ZH_lep_PTV_150_250_GE1J_hbb:r_zh_150_250wj[1,-5,5]' --PO 'map=.*/.*ZH_lep_PTV_250_400_hbb:r_zh_250_400[1,-5,5]' --PO 'map=.*/.*ZH_lep_PTV_GT400_hbb:r_zh_gt400[1,-5,5]' -o ws_counting.root\n</code></pre> <p>In the example given above a signal POI is assigned to each generator-level bin independent of detector-level bin. This allows the measurement to take into account migrations. </p> <p>To extract the measurement let's run the initial fit first using the <code>MultiDimFit</code> method implemented in <code>Combine</code> to extract the best-fit values and uncertainties on all floating parameters:  </p> <pre><code>combineTool.py -M MultiDimFit --datacard ws_counting.root --setParameters r_zh_250_400=1,r_zh_150_250noj=1,r_zh_75_150=1,r_zh_150_250wj=1,r_zh_gt400=1 --redefineSignalPOIs r_zh_75_150,r_zh_150_250noj,r_zh_150_250wj,r_zh_250_400,r_zh_gt400 -t -1 \n</code></pre> <p>With the option <code>-t -1</code> we set <code>Combine</code> to fit the asimov dataset instead of actual data. The <code>--setParameters &lt;param&gt;=&lt;value&gt;</code> set the initial value of parameter named . <code>--redefineSignalPOIs r_zh_75_150,r_zh_150_250noj,r_zh_150_250wj,r_zh_250_400,r_zh_gt400</code> set the POIs to the comma-separated list, instead of the default one <code>r</code>.</p> <p>While the uncertainties on the parameters of interest (POIs) can be extracted in multiple ways, the most robust way is to run the likelihood scans for a POI corresponding to each generator-level bin, it allows you to spot discontinuities in the likelihood shape in case of problems with the fit or the model. </p> <pre><code>combineTool.py -M MultiDimFit --datacard ws_counting.root -t -1 --setParameters r_zh_250_400=1,r_zh_150_250noj=1,r_zh_75_150=1,r_zh_150_250wj=1,r_zh_gt400=1 --redefineSignalPOIs r_zh_75_150,r_zh_150_250noj,r_zh_150_250wj,r_zh_250_400,r_zh_gt400 --algo=grid --points=100 -P r_zh_75_150 --floatOtherPOIs=1 -n scan_r_zh_75_150\n\n</code></pre> <p>Now we can plot the likelihood scan and extract the expected intervals.</p> <pre><code>python scripts/plot1DScan.py higgsCombinescan_r_zh_75_150.MultiDimFit.mH120.root -o r_zh_75_150 --POI r_zh_75_150\n</code></pre> <ul> <li>Repeat for all POIs</li> </ul>"},{"location":"tutorial2023_unfolding/unfolding_exercise/#shape-analysis-with-control-regions","title":"Shape analysis with control regions","text":"<p>One of the advantages of the maximum likelihood unfolding is the flexibility to choose the analysis observable and include more information on the event kinematics, consequently improving the analysis sensitivity. This analysis benefits from the shape information of the DNN output trained to differentiate the VH(bb) signal from the SM backgrounds. </p> <p>The datacards for this part of the exercise located <code>full_model_datacards/</code>, where you can find a separate datacard for each region within <code>full_model_datacards/regions</code> directory and also a combined datacard <code>full_model_datacards/comb_full_model.txt</code>. In this case, each of the detector-level bins being used in the unfolding above is now split into multiple bins according to the DNN output score. This provides extra discrimination power to separate the signal from background and improve the measurement.</p> <p>As you will find, the datacards also contain several background processes. To control them properly we will also add regions enriched in the respective backgrounds. Then we can define a common set of rate parameters for signal and control regions to scale the rates or other parameters affecting their shape.  </p> <p>For the shape datacards one has to specify the mapping of histograms and channels/processes as given described below:</p> <pre><code>shapes [process] [channel] [file] [nominal] [systematics_templates]\n</code></pre> <p>Then the <code>shape</code> nuisance parameters can be defined in the systematics block in the datacard. More details can be found in <code>Combine</code> documentation pages.</p> <p>In many CMS analyses there are hundreds of nuisance parameters corresponding to various source of systematics. </p> <p>When we unfold to the generator-level quantities we should remove the nuisances affecting the rate of the generator-level bins, i.e. when measuring a given cross-section such as \\sigma_{\\textrm{gen1}}, the nuisance parameters should not change the value of that parameter itself; they should only change the relationship between that parameter and the observations.  This means that, for example, effects of renormalization and factorization scales on the generator-level cross section within each bin need to be removed. Only their effects on the detector-level distribution through changes of shape within each bin as well as acceptances and efficiencies should be considered. </p> <p>For this analysis, that means removing the <code>lnN</code> nuisance parameters: <code>THU_ZH_mig*</code> and  <code>THU_ZH_inc</code>; keeping only the acceptance <code>shape</code> uncertainties: <code>THU_ZH_acc</code> and <code>THU_ggZH_acc</code>, which do not scale the inclusive cross sections by construction. In this analysis the normalisation effects in the <code>THU_ZH_acc</code> and <code>THU_ggZH_acc</code> templates were already removed from the shape histograms. Removing the normalization effects can be achieved by removing them from the datacard. Alternatively, freezing the respective nuisance parameters with the option <code>--freezeParameters par_name1,par_name2</code>. Or you can create a group following the syntax given below at the end of the combined datacard, and freeze the parameters with the <code>--freezeNuisanceGroups group_name</code> option.</p> <pre><code>[group_name] group = uncertainty_1 uncertainty_2 ... uncertainty_N\n</code></pre> <p>Now we can create the workspace using the same <code>multiSignalmodel</code> as before:</p> <pre><code>text2workspace.py -m 125  full_model_datacards/comb_full_model.txt -P HiggsAnalysis.CombinedLimit.PhysicsModel:multiSignalModel  --PO verbose --PO 'map=.*/.*ZH_lep_PTV_75_150_hbb:r_zh_75_150[1,-5,5]' --PO 'map=.*/.*ZH_lep_PTV_150_250_0J_hbb:r_zh_150_250noj[1,-5,5]'  --PO 'map=.*/.*ZH_lep_PTV_150_250_GE1J_hbb:r_zh_150_250wj[1,-5,5]' --PO 'map=.*/.*ZH_lep_PTV_250_400_hbb:r_zh_250_400[1,-5,5]' --PO 'map=.*/.*ZH_lep_PTV_GT400_hbb:r_zh_gt400[1,-5,5]' --for-fits --no-wrappers --X-pack-asympows --optimize-simpdf-constraints=cms --use-histsum -o ws_full.root\n</code></pre> <p>As you might have noticed we are using a few extra versions <code>--for-fits --no-wrappers --X-pack-asympows --optimize-simpdf-constraints=cms --use-histsum</code> to create a workspace. They are needed to construct a more optimised pdf using the <code>CMSHistSum</code> class implemented in Combine to significantly lower the memory consumption.</p> <ul> <li>Following the instructions given earlier, create the workspace and run the initial fit with <code>-t -1</code>. </li> </ul> <p>Since this time the datacards include shape uncertainties as well as additional categories to improve the background description the fit might take much longer, but we can submit jobs to a batch system by using the combine tool and have results ready to look at in a few minutes.  </p> <pre><code>combineTool.py -M MultiDimFit -d ws_full.root --setParameters r_zh_250_400=1,r_zh_150_250noj=1,r_zh_75_150=1,r_zh_150_250wj=1,r_zh_gt400=1 --redefineSignalPOIs r_zh_75_150,r_zh_150_250noj,r_zh_150_250wj,r_zh_250_400,r_zh_gt400  -t -1 --X-rtd FAST_VERTICAL_MORPH --algo=grid --points=50 --floatOtherPOIs=1 -n .scans_blinded --job-mode condor --task-name scans_zh  --split-points 1 --generate P:n::r_zh_gt400,r_zh_gt400:r_zh_250_400,r_zh_250_400:r_zh_150_250wj,r_zh_150_250wj:r_zh_150_250noj,r_zh_150_250noj:r_zh_75_150,r_zh_75_150\n</code></pre> <p>The option <code>--X-rtd FAST_VERTICAL_MORPH</code> is added here and for all <code>combineTool.py -M MultiDimFit ...</code> to speed up the minimisation. </p> <p>The job submission is handled by the <code>CombineHarvester</code>, the combination of options <code>--job-mode condor --task-name scans_zh  --split-points 1 --generate P:n::r_zh_gt400,r_zh_gt400:r_zh_250_400,r_zh_250_400:r_zh_150_250wj,r_zh_150_250wj:r_zh_150_250noj,r_zh_150_250noj:r_zh_75_150,r_zh_75_150</code> will submit the jobs to HTCondor for each POI.  The <code>--generate</code> option is is being used to automatically generate jobs attaching the options <code>-P &lt;POI&gt; -n &lt;name&gt;</code> with each of the pairs of values <code>&lt;POI&gt;,&lt;name&gt;</code> specified between the colons. You can add <code>--dry-run</code> option to create the submissions files first and check them, and then submit the jobs with <code>condor_submit condor_scans_zh.sub</code>. </p> <p>If you are running the tutorial from a cluster where HTCondor is not available you can also submit the jobs to the slurm system, just change the <code>--job-mode condor</code> to <code>--job-mode slurm</code>. </p> <p>After all jobs are completed we can combine the files for each POI: </p> <pre><code>for p in r_zh_75_150 r_zh_150_250noj r_zh_150_250wj r_zh_250_400 r_zh_gt400\ndo\n    hadd -k -f scan_${p}_blinded.root higgsCombine.scans_blinded.${p}.POINTS.*.MultiDimFit.mH120.root\ndone\n</code></pre> <p>And finally plot the likelihood scans </p> <pre><code>python scripts/plot1DScan.py scan_r_zh_75_150_blinded.root  -o scan_r_zh_75_150_blinded --POI r_zh_75_150 --json summary_zh_stxs_blinded.json\n</code></pre> <p></p>"},{"location":"tutorial2023_unfolding/unfolding_exercise/#impacts","title":"Impacts","text":"<p>One of the important tests before we move to the unblinding stage is to check the impacts of nuisance parameters on each POI. For this we can run the <code>combineTool.py</code> with <code>-M Impacts</code> method. We start with the initial fit, which should take about 20 minutes (good time to have a coffee break!):</p> <pre><code>combineTool.py -M Impacts -d ws_full.root -m 125 --robustFit 1 --doInitialFit --redefineSignalPOIs r_zh_75_150,r_zh_150_250noj,r_zh_150_250wj,r_zh_250_400,r_zh_gt400 --X-rtd FAST_VERTICAL_MORPH\n</code></pre> <p>Note that it is important to add the option <code>--redefineSignalPOIs [list of parameters]</code>, to produce the impacts for all POIs we defined when the workspace was created with the <code>multiSignalModel</code>.</p> <p>After the initial fit is completed we can perform the likelihood scans for each nuisance parameter.  We will submit the jobs to the HTCondor to speed up the process.</p> <pre><code>combineTool.py -M Impacts -d ws_full.root -m 125 --robustFit 1 --doFits --redefineSignalPOIs r_zh_75_150,r_zh_150_250noj,r_zh_150_250wj,r_zh_250_400,r_zh_gt400 --job-mode condor --task-name impacts_zh --X-rtd FAST_VERTICAL_MORPH \n</code></pre> <p>Now we can combine the results into the <code>.json</code> format and use it to produce the impact plots.</p> <pre><code>combineTool.py -M Impacts -d ws_full.root -m 125 --redefineSignalPOIs r_zh_75_150,r_zh_150_250noj,r_zh_150_250wj,r_zh_250_400,r_zh_gt400 --output impacts.json \n\nplotImpacts.py -i impacts.json -o impacts_r_zh_75_150 --POI r_zh_75_150\n</code></pre> <p> * Do you observe differences in impacts plots for different POIs, do these differences make sense to you? </p>"},{"location":"tutorial2023_unfolding/unfolding_exercise/#unfolded-measurements","title":"Unfolded measurements","text":"<p>Now that we studied the nuisance parameter impacts for each POI, we can finally perform the measurement. Note that for the purposes of the tutorial, we are skipping further checks and validation that you should do on your analysis. Namely the goodness of fit test and the post-fit plots of folded observables. Both of these checks were detailed in the previous exercises, which you can find under the following link. </p> <p>At this stage we'll run the <code>MultiDimFit</code> again scanning each POI to calculate the intervals, but this time we'll remove the <code>-t -1</code> option to extract the unblinded results. </p> <p>Also since we want to unfold the measurements to the generator-level observables, i.e. extract the cross sections, we remove the theoretical uncertainties affecting the rates of signal processes,  we can do this be freezing them <code>--freezeNuisanceGroups &lt;group_name&gt;</code>, using the <code>group_name</code> you assigned earlier in the tutorial. </p> <p>Now plot the scans and collect the measurements in the json file <code>summary_zh_stxs.json</code>. </p> <pre><code>python scripts/plot1DScan.py scan_r_zh_75_150.root -o r_zh_75_150 --POI r_zh_75_150 --json summary_zh_stxs.json  \n</code></pre> <p></p> <p>Repeat the same command for other POIs to fill the <code>summary_zh_stxs.json</code>, which can then be used to make the cross section plot by multiplying the standard model cross sections by the signal strengths' best-fit values as shown below. </p> <pre><code>python scripts/make_XSplot.py summary_zh_stxs.json\n</code></pre> <p> </p>"},{"location":"tutorial2023_unfolding/unfolding_exercise/#poi-correlations","title":"POI correlations","text":"<p>In addition to the cross-section measurements it is very important to publish covariance or correlation information of the measured cross sections.  This allows the measurement to be properly intepreted or reused in combined fits.  </p> <p>The correlation matrix or covariance matrix can be extracted from the results after the fit. Here we can use the <code>FitDiagnostics</code> or <code>MultiDimFit</code> method.</p> <pre><code>combineTool.py -M FitDiagnostics --datacard ws_full.root --setParameters r_zh_250_400=1,r_zh_150_250noj=1,r_zh_75_150=1,r_zh_150_250wj=1,r_zh_gt400=1 --redefineSignalPOIs r_zh_75_150,r_zh_150_250noj,r_zh_150_250wj,r_zh_250_400,r_zh_gt400  --robustHesse 1 -n .full_model --X-rtd FAST_VERTICAL_MORPH\n</code></pre> <p>Then the <code>RooFitResult</code>, containing correlations matrix, can be found in the <code>fitDiagnostics.full_model.root</code> file under the name <code>fit_s</code>. The script <code>plotCorrelations_pois.py</code> from the exercise git-lab repository can help to plot the correlation matrix.</p> <pre><code>python scripts/plotCorrelations_pois.py -i fitDiagnostics.full_model.root:fit_s -p r_zh_75_150,r_zh_150_250noj,r_zh_150_250wj,r_zh_250_400,r_zh_gt400\n\n</code></pre> <p></p>"}]}